module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 193);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	"use strict";
	/** PROMISIFY CALLBACK-STYLE FUNCTIONS TO ES6 PROMISES
	 *
	 * EXAMPLE:
	 * const fn = promisify( (callback) => callback(null, "Hello world!") );
	 * fn((err, str) => console.log(str));
	 * fn().then((str) => console.log(str));
	 * //Both functions, will log 'Hello world!'
	 *
	 * Note: The function you pass, may have any arguments you want, but the latest
	 * have to be the callback, which you will call with: next(err, value)
	 *
	 * @param method: Function/Array/Map = The function(s) to promisify
	 * @param options: Map =
	 *  "context" (default is function): The context which to apply the called function
	 *  "replace" (default is falsy): When passed an array/map, if to replace the original object
	 *
	 * @return: A promise if passed a function, otherwise the object with the promises
	 *
	 * @license: MIT
	 * @version: 1.0.1
	 * @author: Manuel Di Iorio
	 **/

	"use strict";

	var createCallback = function createCallback(method, context) {
	    return function () {
	        var args = Array.prototype.slice.call(arguments);

	        return new Promise(function (solve, reject) {
	            args.push(function (err, val) {
	                if (err) return reject(err);
	                solve(val);
	            });

	            method.apply(context, args);
	        });
	    };
	};

	module.exports = function (methods, options) {
	    options = options || {};
	    var type = Object.prototype.toString.call(methods);

	    if (type === "[object Object]" || type === "[object Array]") {
	        var obj = options.replace ? methods : {};

	        for (var key in methods) {
	            if (methods.hasOwnProperty(key)) obj[key] = createCallback(methods[key]);
	        }return obj;
	    }

	    return createCallback(methods, options.context || methods);
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	try {
	  var util = __webpack_require__(4);
	  if (typeof util.inherits !== 'function') throw '';
	  module.exports = util.inherits;
	} catch (e) {
	  module.exports = __webpack_require__(274);
	}


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var es5 = __webpack_require__(17);
	var canEvaluate = typeof navigator == "undefined";

	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;

	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);

	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];

	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };

	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];

	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);

	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}

	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};

	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };

	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}

	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";

	function env(key, def) {
	    return isNode ? process.env[key] : def;
	}

	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}

	function domainBind(self, cb) {
	    return self.bind(cb);
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();

	if (ret.isNode) ret.toFastProperties(process);

	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
	  'use strict';

	  // Utils
	  function assert (val, msg) {
	    if (!val) throw new Error(msg || 'Assertion failed');
	  }

	  // Could use `inherits` module, but don't want to move from single file
	  // architecture yet.
	  function inherits (ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  }

	  // BN

	  function BN (number, base, endian) {
	    if (BN.isBN(number)) {
	      return number;
	    }

	    this.negative = 0;
	    this.words = null;
	    this.length = 0;

	    // Reduction context
	    this.red = null;

	    if (number !== null) {
	      if (base === 'le' || base === 'be') {
	        endian = base;
	        base = 10;
	      }

	      this._init(number || 0, base || 10, endian || 'be');
	    }
	  }
	  if (typeof module === 'object') {
	    module.exports = BN;
	  } else {
	    exports.BN = BN;
	  }

	  BN.BN = BN;
	  BN.wordSize = 26;

	  var Buffer;
	  try {
	    Buffer = __webpack_require__(6).Buffer;
	  } catch (e) {
	  }

	  BN.isBN = function isBN (num) {
	    if (num instanceof BN) {
	      return true;
	    }

	    return num !== null && typeof num === 'object' &&
	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
	  };

	  BN.max = function max (left, right) {
	    if (left.cmp(right) > 0) return left;
	    return right;
	  };

	  BN.min = function min (left, right) {
	    if (left.cmp(right) < 0) return left;
	    return right;
	  };

	  BN.prototype._init = function init (number, base, endian) {
	    if (typeof number === 'number') {
	      return this._initNumber(number, base, endian);
	    }

	    if (typeof number === 'object') {
	      return this._initArray(number, base, endian);
	    }

	    if (base === 'hex') {
	      base = 16;
	    }
	    assert(base === (base | 0) && base >= 2 && base <= 36);

	    number = number.toString().replace(/\s+/g, '');
	    var start = 0;
	    if (number[0] === '-') {
	      start++;
	    }

	    if (base === 16) {
	      this._parseHex(number, start);
	    } else {
	      this._parseBase(number, base, start);
	    }

	    if (number[0] === '-') {
	      this.negative = 1;
	    }

	    this.strip();

	    if (endian !== 'le') return;

	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
	    if (number < 0) {
	      this.negative = 1;
	      number = -number;
	    }
	    if (number < 0x4000000) {
	      this.words = [ number & 0x3ffffff ];
	      this.length = 1;
	    } else if (number < 0x10000000000000) {
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff
	      ];
	      this.length = 2;
	    } else {
	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
	      this.words = [
	        number & 0x3ffffff,
	        (number / 0x4000000) & 0x3ffffff,
	        1
	      ];
	      this.length = 3;
	    }

	    if (endian !== 'le') return;

	    // Reverse the bytes
	    this._initArray(this.toArray(), base, endian);
	  };

	  BN.prototype._initArray = function _initArray (number, base, endian) {
	    // Perhaps a Uint8Array
	    assert(typeof number.length === 'number');
	    if (number.length <= 0) {
	      this.words = [ 0 ];
	      this.length = 1;
	      return this;
	    }

	    this.length = Math.ceil(number.length / 3);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    var off = 0;
	    if (endian === 'be') {
	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    } else if (endian === 'le') {
	      for (i = 0, j = 0; i < number.length; i += 3) {
	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
	        this.words[j] |= (w << off) & 0x3ffffff;
	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
	        off += 24;
	        if (off >= 26) {
	          off -= 26;
	          j++;
	        }
	      }
	    }
	    return this.strip();
	  };

	  function parseHex (str, start, end) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r <<= 4;

	      // 'a' - 'f'
	      if (c >= 49 && c <= 54) {
	        r |= c - 49 + 0xa;

	      // 'A' - 'F'
	      } else if (c >= 17 && c <= 22) {
	        r |= c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r |= c & 0xf;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseHex = function _parseHex (number, start) {
	    // Create possibly bigger array to ensure that it fits the number
	    this.length = Math.ceil((number.length - start) / 6);
	    this.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      this.words[i] = 0;
	    }

	    var j, w;
	    // Scan 24-bit chunks and add them to the number
	    var off = 0;
	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
	      w = parseHex(number, i, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	      off += 24;
	      if (off >= 26) {
	        off -= 26;
	        j++;
	      }
	    }
	    if (i + 6 !== start) {
	      w = parseHex(number, start, i + 6);
	      this.words[j] |= (w << off) & 0x3ffffff;
	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
	    }
	    this.strip();
	  };

	  function parseBase (str, start, end, mul) {
	    var r = 0;
	    var len = Math.min(str.length, end);
	    for (var i = start; i < len; i++) {
	      var c = str.charCodeAt(i) - 48;

	      r *= mul;

	      // 'a'
	      if (c >= 49) {
	        r += c - 49 + 0xa;

	      // 'A'
	      } else if (c >= 17) {
	        r += c - 17 + 0xa;

	      // '0' - '9'
	      } else {
	        r += c;
	      }
	    }
	    return r;
	  }

	  BN.prototype._parseBase = function _parseBase (number, base, start) {
	    // Initialize as zero
	    this.words = [ 0 ];
	    this.length = 1;

	    // Find length of limb in base
	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
	      limbLen++;
	    }
	    limbLen--;
	    limbPow = (limbPow / base) | 0;

	    var total = number.length - start;
	    var mod = total % limbLen;
	    var end = Math.min(total, total - mod) + start;

	    var word = 0;
	    for (var i = start; i < end; i += limbLen) {
	      word = parseBase(number, i, i + limbLen, base);

	      this.imuln(limbPow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }

	    if (mod !== 0) {
	      var pow = 1;
	      word = parseBase(number, i, number.length, base);

	      for (i = 0; i < mod; i++) {
	        pow *= base;
	      }

	      this.imuln(pow);
	      if (this.words[0] + word < 0x4000000) {
	        this.words[0] += word;
	      } else {
	        this._iaddn(word);
	      }
	    }
	  };

	  BN.prototype.copy = function copy (dest) {
	    dest.words = new Array(this.length);
	    for (var i = 0; i < this.length; i++) {
	      dest.words[i] = this.words[i];
	    }
	    dest.length = this.length;
	    dest.negative = this.negative;
	    dest.red = this.red;
	  };

	  BN.prototype.clone = function clone () {
	    var r = new BN(null);
	    this.copy(r);
	    return r;
	  };

	  BN.prototype._expand = function _expand (size) {
	    while (this.length < size) {
	      this.words[this.length++] = 0;
	    }
	    return this;
	  };

	  // Remove leading `0` from `this`
	  BN.prototype.strip = function strip () {
	    while (this.length > 1 && this.words[this.length - 1] === 0) {
	      this.length--;
	    }
	    return this._normSign();
	  };

	  BN.prototype._normSign = function _normSign () {
	    // -0 = 0
	    if (this.length === 1 && this.words[0] === 0) {
	      this.negative = 0;
	    }
	    return this;
	  };

	  BN.prototype.inspect = function inspect () {
	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
	  };

	  /*

	  var zeros = [];
	  var groupSizes = [];
	  var groupBases = [];

	  var s = '';
	  var i = -1;
	  while (++i < BN.wordSize) {
	    zeros[i] = s;
	    s += '0';
	  }
	  groupSizes[0] = 0;
	  groupSizes[1] = 0;
	  groupBases[0] = 0;
	  groupBases[1] = 0;
	  var base = 2 - 1;
	  while (++base < 36 + 1) {
	    var groupSize = 0;
	    var groupBase = 1;
	    while (groupBase < (1 << BN.wordSize) / base) {
	      groupBase *= base;
	      groupSize += 1;
	    }
	    groupSizes[base] = groupSize;
	    groupBases[base] = groupBase;
	  }

	  */

	  var zeros = [
	    '',
	    '0',
	    '00',
	    '000',
	    '0000',
	    '00000',
	    '000000',
	    '0000000',
	    '00000000',
	    '000000000',
	    '0000000000',
	    '00000000000',
	    '000000000000',
	    '0000000000000',
	    '00000000000000',
	    '000000000000000',
	    '0000000000000000',
	    '00000000000000000',
	    '000000000000000000',
	    '0000000000000000000',
	    '00000000000000000000',
	    '000000000000000000000',
	    '0000000000000000000000',
	    '00000000000000000000000',
	    '000000000000000000000000',
	    '0000000000000000000000000'
	  ];

	  var groupSizes = [
	    0, 0,
	    25, 16, 12, 11, 10, 9, 8,
	    8, 7, 7, 7, 7, 6, 6,
	    6, 6, 6, 6, 6, 5, 5,
	    5, 5, 5, 5, 5, 5, 5,
	    5, 5, 5, 5, 5, 5, 5
	  ];

	  var groupBases = [
	    0, 0,
	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
	  ];

	  BN.prototype.toString = function toString (base, padding) {
	    base = base || 10;
	    padding = padding | 0 || 1;

	    var out;
	    if (base === 16 || base === 'hex') {
	      out = '';
	      var off = 0;
	      var carry = 0;
	      for (var i = 0; i < this.length; i++) {
	        var w = this.words[i];
	        var word = (((w << off) | carry) & 0xffffff).toString(16);
	        carry = (w >>> (24 - off)) & 0xffffff;
	        if (carry !== 0 || i !== this.length - 1) {
	          out = zeros[6 - word.length] + word + out;
	        } else {
	          out = word + out;
	        }
	        off += 2;
	        if (off >= 26) {
	          off -= 26;
	          i--;
	        }
	      }
	      if (carry !== 0) {
	        out = carry.toString(16) + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    if (base === (base | 0) && base >= 2 && base <= 36) {
	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
	      var groupSize = groupSizes[base];
	      // var groupBase = Math.pow(base, groupSize);
	      var groupBase = groupBases[base];
	      out = '';
	      var c = this.clone();
	      c.negative = 0;
	      while (!c.isZero()) {
	        var r = c.modn(groupBase).toString(base);
	        c = c.idivn(groupBase);

	        if (!c.isZero()) {
	          out = zeros[groupSize - r.length] + r + out;
	        } else {
	          out = r + out;
	        }
	      }
	      if (this.isZero()) {
	        out = '0' + out;
	      }
	      while (out.length % padding !== 0) {
	        out = '0' + out;
	      }
	      if (this.negative !== 0) {
	        out = '-' + out;
	      }
	      return out;
	    }

	    assert(false, 'Base should be between 2 and 36');
	  };

	  BN.prototype.toNumber = function toNumber () {
	    var ret = this.words[0];
	    if (this.length === 2) {
	      ret += this.words[1] * 0x4000000;
	    } else if (this.length === 3 && this.words[2] === 0x01) {
	      // NOTE: at this stage it is known that the top bit is set
	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
	    } else if (this.length > 2) {
	      assert(false, 'Number can only safely store up to 53 bits');
	    }
	    return (this.negative !== 0) ? -ret : ret;
	  };

	  BN.prototype.toJSON = function toJSON () {
	    return this.toString(16);
	  };

	  BN.prototype.toBuffer = function toBuffer (endian, length) {
	    assert(typeof Buffer !== 'undefined');
	    return this.toArrayLike(Buffer, endian, length);
	  };

	  BN.prototype.toArray = function toArray (endian, length) {
	    return this.toArrayLike(Array, endian, length);
	  };

	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
	    var byteLength = this.byteLength();
	    var reqLength = length || Math.max(1, byteLength);
	    assert(byteLength <= reqLength, 'byte array longer than desired length');
	    assert(reqLength > 0, 'Requested array length <= 0');

	    this.strip();
	    var littleEndian = endian === 'le';
	    var res = new ArrayType(reqLength);

	    var b, i;
	    var q = this.clone();
	    if (!littleEndian) {
	      // Assume big-endian
	      for (i = 0; i < reqLength - byteLength; i++) {
	        res[i] = 0;
	      }

	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[reqLength - i - 1] = b;
	      }
	    } else {
	      for (i = 0; !q.isZero(); i++) {
	        b = q.andln(0xff);
	        q.iushrn(8);

	        res[i] = b;
	      }

	      for (; i < reqLength; i++) {
	        res[i] = 0;
	      }
	    }

	    return res;
	  };

	  if (Math.clz32) {
	    BN.prototype._countBits = function _countBits (w) {
	      return 32 - Math.clz32(w);
	    };
	  } else {
	    BN.prototype._countBits = function _countBits (w) {
	      var t = w;
	      var r = 0;
	      if (t >= 0x1000) {
	        r += 13;
	        t >>>= 13;
	      }
	      if (t >= 0x40) {
	        r += 7;
	        t >>>= 7;
	      }
	      if (t >= 0x8) {
	        r += 4;
	        t >>>= 4;
	      }
	      if (t >= 0x02) {
	        r += 2;
	        t >>>= 2;
	      }
	      return r + t;
	    };
	  }

	  BN.prototype._zeroBits = function _zeroBits (w) {
	    // Short-cut
	    if (w === 0) return 26;

	    var t = w;
	    var r = 0;
	    if ((t & 0x1fff) === 0) {
	      r += 13;
	      t >>>= 13;
	    }
	    if ((t & 0x7f) === 0) {
	      r += 7;
	      t >>>= 7;
	    }
	    if ((t & 0xf) === 0) {
	      r += 4;
	      t >>>= 4;
	    }
	    if ((t & 0x3) === 0) {
	      r += 2;
	      t >>>= 2;
	    }
	    if ((t & 0x1) === 0) {
	      r++;
	    }
	    return r;
	  };

	  // Return number of used bits in a BN
	  BN.prototype.bitLength = function bitLength () {
	    var w = this.words[this.length - 1];
	    var hi = this._countBits(w);
	    return (this.length - 1) * 26 + hi;
	  };

	  function toBitArray (num) {
	    var w = new Array(num.bitLength());

	    for (var bit = 0; bit < w.length; bit++) {
	      var off = (bit / 26) | 0;
	      var wbit = bit % 26;

	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
	    }

	    return w;
	  }

	  // Number of trailing zero bits
	  BN.prototype.zeroBits = function zeroBits () {
	    if (this.isZero()) return 0;

	    var r = 0;
	    for (var i = 0; i < this.length; i++) {
	      var b = this._zeroBits(this.words[i]);
	      r += b;
	      if (b !== 26) break;
	    }
	    return r;
	  };

	  BN.prototype.byteLength = function byteLength () {
	    return Math.ceil(this.bitLength() / 8);
	  };

	  BN.prototype.toTwos = function toTwos (width) {
	    if (this.negative !== 0) {
	      return this.abs().inotn(width).iaddn(1);
	    }
	    return this.clone();
	  };

	  BN.prototype.fromTwos = function fromTwos (width) {
	    if (this.testn(width - 1)) {
	      return this.notn(width).iaddn(1).ineg();
	    }
	    return this.clone();
	  };

	  BN.prototype.isNeg = function isNeg () {
	    return this.negative !== 0;
	  };

	  // Return negative clone of `this`
	  BN.prototype.neg = function neg () {
	    return this.clone().ineg();
	  };

	  BN.prototype.ineg = function ineg () {
	    if (!this.isZero()) {
	      this.negative ^= 1;
	    }

	    return this;
	  };

	  // Or `num` with `this` in-place
	  BN.prototype.iuor = function iuor (num) {
	    while (this.length < num.length) {
	      this.words[this.length++] = 0;
	    }

	    for (var i = 0; i < num.length; i++) {
	      this.words[i] = this.words[i] | num.words[i];
	    }

	    return this.strip();
	  };

	  BN.prototype.ior = function ior (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuor(num);
	  };

	  // Or `num` with `this`
	  BN.prototype.or = function or (num) {
	    if (this.length > num.length) return this.clone().ior(num);
	    return num.clone().ior(this);
	  };

	  BN.prototype.uor = function uor (num) {
	    if (this.length > num.length) return this.clone().iuor(num);
	    return num.clone().iuor(this);
	  };

	  // And `num` with `this` in-place
	  BN.prototype.iuand = function iuand (num) {
	    // b = min-length(num, this)
	    var b;
	    if (this.length > num.length) {
	      b = num;
	    } else {
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = this.words[i] & num.words[i];
	    }

	    this.length = b.length;

	    return this.strip();
	  };

	  BN.prototype.iand = function iand (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuand(num);
	  };

	  // And `num` with `this`
	  BN.prototype.and = function and (num) {
	    if (this.length > num.length) return this.clone().iand(num);
	    return num.clone().iand(this);
	  };

	  BN.prototype.uand = function uand (num) {
	    if (this.length > num.length) return this.clone().iuand(num);
	    return num.clone().iuand(this);
	  };

	  // Xor `num` with `this` in-place
	  BN.prototype.iuxor = function iuxor (num) {
	    // a.length > b.length
	    var a;
	    var b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    for (var i = 0; i < b.length; i++) {
	      this.words[i] = a.words[i] ^ b.words[i];
	    }

	    if (this !== a) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = a.length;

	    return this.strip();
	  };

	  BN.prototype.ixor = function ixor (num) {
	    assert((this.negative | num.negative) === 0);
	    return this.iuxor(num);
	  };

	  // Xor `num` with `this`
	  BN.prototype.xor = function xor (num) {
	    if (this.length > num.length) return this.clone().ixor(num);
	    return num.clone().ixor(this);
	  };

	  BN.prototype.uxor = function uxor (num) {
	    if (this.length > num.length) return this.clone().iuxor(num);
	    return num.clone().iuxor(this);
	  };

	  // Not ``this`` with ``width`` bitwidth
	  BN.prototype.inotn = function inotn (width) {
	    assert(typeof width === 'number' && width >= 0);

	    var bytesNeeded = Math.ceil(width / 26) | 0;
	    var bitsLeft = width % 26;

	    // Extend the buffer with leading zeroes
	    this._expand(bytesNeeded);

	    if (bitsLeft > 0) {
	      bytesNeeded--;
	    }

	    // Handle complete words
	    for (var i = 0; i < bytesNeeded; i++) {
	      this.words[i] = ~this.words[i] & 0x3ffffff;
	    }

	    // Handle the residue
	    if (bitsLeft > 0) {
	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
	    }

	    // And remove leading zeroes
	    return this.strip();
	  };

	  BN.prototype.notn = function notn (width) {
	    return this.clone().inotn(width);
	  };

	  // Set `bit` of `this`
	  BN.prototype.setn = function setn (bit, val) {
	    assert(typeof bit === 'number' && bit >= 0);

	    var off = (bit / 26) | 0;
	    var wbit = bit % 26;

	    this._expand(off + 1);

	    if (val) {
	      this.words[off] = this.words[off] | (1 << wbit);
	    } else {
	      this.words[off] = this.words[off] & ~(1 << wbit);
	    }

	    return this.strip();
	  };

	  // Add `num` to `this` in-place
	  BN.prototype.iadd = function iadd (num) {
	    var r;

	    // negative + positive
	    if (this.negative !== 0 && num.negative === 0) {
	      this.negative = 0;
	      r = this.isub(num);
	      this.negative ^= 1;
	      return this._normSign();

	    // positive + negative
	    } else if (this.negative === 0 && num.negative !== 0) {
	      num.negative = 0;
	      r = this.isub(num);
	      num.negative = 1;
	      return r._normSign();
	    }

	    // a.length > b.length
	    var a, b;
	    if (this.length > num.length) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      this.words[i] = r & 0x3ffffff;
	      carry = r >>> 26;
	    }

	    this.length = a.length;
	    if (carry !== 0) {
	      this.words[this.length] = carry;
	      this.length++;
	    // Copy the rest of the words
	    } else if (a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    return this;
	  };

	  // Add `num` to `this`
	  BN.prototype.add = function add (num) {
	    var res;
	    if (num.negative !== 0 && this.negative === 0) {
	      num.negative = 0;
	      res = this.sub(num);
	      num.negative ^= 1;
	      return res;
	    } else if (num.negative === 0 && this.negative !== 0) {
	      this.negative = 0;
	      res = num.sub(this);
	      this.negative = 1;
	      return res;
	    }

	    if (this.length > num.length) return this.clone().iadd(num);

	    return num.clone().iadd(this);
	  };

	  // Subtract `num` from `this` in-place
	  BN.prototype.isub = function isub (num) {
	    // this - (-num) = this + num
	    if (num.negative !== 0) {
	      num.negative = 0;
	      var r = this.iadd(num);
	      num.negative = 1;
	      return r._normSign();

	    // -this - num = -(this + num)
	    } else if (this.negative !== 0) {
	      this.negative = 0;
	      this.iadd(num);
	      this.negative = 1;
	      return this._normSign();
	    }

	    // At this point both numbers are positive
	    var cmp = this.cmp(num);

	    // Optimization - zeroify
	    if (cmp === 0) {
	      this.negative = 0;
	      this.length = 1;
	      this.words[0] = 0;
	      return this;
	    }

	    // a > b
	    var a, b;
	    if (cmp > 0) {
	      a = this;
	      b = num;
	    } else {
	      a = num;
	      b = this;
	    }

	    var carry = 0;
	    for (var i = 0; i < b.length; i++) {
	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }
	    for (; carry !== 0 && i < a.length; i++) {
	      r = (a.words[i] | 0) + carry;
	      carry = r >> 26;
	      this.words[i] = r & 0x3ffffff;
	    }

	    // Copy rest of the words
	    if (carry === 0 && i < a.length && a !== this) {
	      for (; i < a.length; i++) {
	        this.words[i] = a.words[i];
	      }
	    }

	    this.length = Math.max(this.length, i);

	    if (a !== this) {
	      this.negative = 1;
	    }

	    return this.strip();
	  };

	  // Subtract `num` from `this`
	  BN.prototype.sub = function sub (num) {
	    return this.clone().isub(num);
	  };

	  function smallMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    var len = (self.length + num.length) | 0;
	    out.length = len;
	    len = (len - 1) | 0;

	    // Peel one iteration (compiler can't do it, because of code complexity)
	    var a = self.words[0] | 0;
	    var b = num.words[0] | 0;
	    var r = a * b;

	    var lo = r & 0x3ffffff;
	    var carry = (r / 0x4000000) | 0;
	    out.words[0] = lo;

	    for (var k = 1; k < len; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = carry >>> 26;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = (k - j) | 0;
	        a = self.words[i] | 0;
	        b = num.words[j] | 0;
	        r = a * b + rword;
	        ncarry += (r / 0x4000000) | 0;
	        rword = r & 0x3ffffff;
	      }
	      out.words[k] = rword | 0;
	      carry = ncarry | 0;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry | 0;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  // TODO(indutny): it may be reasonable to omit it for users who don't need
	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
	  // multiplication (like elliptic secp256k1).
	  var comb10MulTo = function comb10MulTo (self, num, out) {
	    var a = self.words;
	    var b = num.words;
	    var o = out.words;
	    var c = 0;
	    var lo;
	    var mid;
	    var hi;
	    var a0 = a[0] | 0;
	    var al0 = a0 & 0x1fff;
	    var ah0 = a0 >>> 13;
	    var a1 = a[1] | 0;
	    var al1 = a1 & 0x1fff;
	    var ah1 = a1 >>> 13;
	    var a2 = a[2] | 0;
	    var al2 = a2 & 0x1fff;
	    var ah2 = a2 >>> 13;
	    var a3 = a[3] | 0;
	    var al3 = a3 & 0x1fff;
	    var ah3 = a3 >>> 13;
	    var a4 = a[4] | 0;
	    var al4 = a4 & 0x1fff;
	    var ah4 = a4 >>> 13;
	    var a5 = a[5] | 0;
	    var al5 = a5 & 0x1fff;
	    var ah5 = a5 >>> 13;
	    var a6 = a[6] | 0;
	    var al6 = a6 & 0x1fff;
	    var ah6 = a6 >>> 13;
	    var a7 = a[7] | 0;
	    var al7 = a7 & 0x1fff;
	    var ah7 = a7 >>> 13;
	    var a8 = a[8] | 0;
	    var al8 = a8 & 0x1fff;
	    var ah8 = a8 >>> 13;
	    var a9 = a[9] | 0;
	    var al9 = a9 & 0x1fff;
	    var ah9 = a9 >>> 13;
	    var b0 = b[0] | 0;
	    var bl0 = b0 & 0x1fff;
	    var bh0 = b0 >>> 13;
	    var b1 = b[1] | 0;
	    var bl1 = b1 & 0x1fff;
	    var bh1 = b1 >>> 13;
	    var b2 = b[2] | 0;
	    var bl2 = b2 & 0x1fff;
	    var bh2 = b2 >>> 13;
	    var b3 = b[3] | 0;
	    var bl3 = b3 & 0x1fff;
	    var bh3 = b3 >>> 13;
	    var b4 = b[4] | 0;
	    var bl4 = b4 & 0x1fff;
	    var bh4 = b4 >>> 13;
	    var b5 = b[5] | 0;
	    var bl5 = b5 & 0x1fff;
	    var bh5 = b5 >>> 13;
	    var b6 = b[6] | 0;
	    var bl6 = b6 & 0x1fff;
	    var bh6 = b6 >>> 13;
	    var b7 = b[7] | 0;
	    var bl7 = b7 & 0x1fff;
	    var bh7 = b7 >>> 13;
	    var b8 = b[8] | 0;
	    var bl8 = b8 & 0x1fff;
	    var bh8 = b8 >>> 13;
	    var b9 = b[9] | 0;
	    var bl9 = b9 & 0x1fff;
	    var bh9 = b9 >>> 13;

	    out.negative = self.negative ^ num.negative;
	    out.length = 19;
	    /* k = 0 */
	    lo = Math.imul(al0, bl0);
	    mid = Math.imul(al0, bh0);
	    mid = (mid + Math.imul(ah0, bl0)) | 0;
	    hi = Math.imul(ah0, bh0);
	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
	    w0 &= 0x3ffffff;
	    /* k = 1 */
	    lo = Math.imul(al1, bl0);
	    mid = Math.imul(al1, bh0);
	    mid = (mid + Math.imul(ah1, bl0)) | 0;
	    hi = Math.imul(ah1, bh0);
	    lo = (lo + Math.imul(al0, bl1)) | 0;
	    mid = (mid + Math.imul(al0, bh1)) | 0;
	    mid = (mid + Math.imul(ah0, bl1)) | 0;
	    hi = (hi + Math.imul(ah0, bh1)) | 0;
	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
	    w1 &= 0x3ffffff;
	    /* k = 2 */
	    lo = Math.imul(al2, bl0);
	    mid = Math.imul(al2, bh0);
	    mid = (mid + Math.imul(ah2, bl0)) | 0;
	    hi = Math.imul(ah2, bh0);
	    lo = (lo + Math.imul(al1, bl1)) | 0;
	    mid = (mid + Math.imul(al1, bh1)) | 0;
	    mid = (mid + Math.imul(ah1, bl1)) | 0;
	    hi = (hi + Math.imul(ah1, bh1)) | 0;
	    lo = (lo + Math.imul(al0, bl2)) | 0;
	    mid = (mid + Math.imul(al0, bh2)) | 0;
	    mid = (mid + Math.imul(ah0, bl2)) | 0;
	    hi = (hi + Math.imul(ah0, bh2)) | 0;
	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
	    w2 &= 0x3ffffff;
	    /* k = 3 */
	    lo = Math.imul(al3, bl0);
	    mid = Math.imul(al3, bh0);
	    mid = (mid + Math.imul(ah3, bl0)) | 0;
	    hi = Math.imul(ah3, bh0);
	    lo = (lo + Math.imul(al2, bl1)) | 0;
	    mid = (mid + Math.imul(al2, bh1)) | 0;
	    mid = (mid + Math.imul(ah2, bl1)) | 0;
	    hi = (hi + Math.imul(ah2, bh1)) | 0;
	    lo = (lo + Math.imul(al1, bl2)) | 0;
	    mid = (mid + Math.imul(al1, bh2)) | 0;
	    mid = (mid + Math.imul(ah1, bl2)) | 0;
	    hi = (hi + Math.imul(ah1, bh2)) | 0;
	    lo = (lo + Math.imul(al0, bl3)) | 0;
	    mid = (mid + Math.imul(al0, bh3)) | 0;
	    mid = (mid + Math.imul(ah0, bl3)) | 0;
	    hi = (hi + Math.imul(ah0, bh3)) | 0;
	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
	    w3 &= 0x3ffffff;
	    /* k = 4 */
	    lo = Math.imul(al4, bl0);
	    mid = Math.imul(al4, bh0);
	    mid = (mid + Math.imul(ah4, bl0)) | 0;
	    hi = Math.imul(ah4, bh0);
	    lo = (lo + Math.imul(al3, bl1)) | 0;
	    mid = (mid + Math.imul(al3, bh1)) | 0;
	    mid = (mid + Math.imul(ah3, bl1)) | 0;
	    hi = (hi + Math.imul(ah3, bh1)) | 0;
	    lo = (lo + Math.imul(al2, bl2)) | 0;
	    mid = (mid + Math.imul(al2, bh2)) | 0;
	    mid = (mid + Math.imul(ah2, bl2)) | 0;
	    hi = (hi + Math.imul(ah2, bh2)) | 0;
	    lo = (lo + Math.imul(al1, bl3)) | 0;
	    mid = (mid + Math.imul(al1, bh3)) | 0;
	    mid = (mid + Math.imul(ah1, bl3)) | 0;
	    hi = (hi + Math.imul(ah1, bh3)) | 0;
	    lo = (lo + Math.imul(al0, bl4)) | 0;
	    mid = (mid + Math.imul(al0, bh4)) | 0;
	    mid = (mid + Math.imul(ah0, bl4)) | 0;
	    hi = (hi + Math.imul(ah0, bh4)) | 0;
	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
	    w4 &= 0x3ffffff;
	    /* k = 5 */
	    lo = Math.imul(al5, bl0);
	    mid = Math.imul(al5, bh0);
	    mid = (mid + Math.imul(ah5, bl0)) | 0;
	    hi = Math.imul(ah5, bh0);
	    lo = (lo + Math.imul(al4, bl1)) | 0;
	    mid = (mid + Math.imul(al4, bh1)) | 0;
	    mid = (mid + Math.imul(ah4, bl1)) | 0;
	    hi = (hi + Math.imul(ah4, bh1)) | 0;
	    lo = (lo + Math.imul(al3, bl2)) | 0;
	    mid = (mid + Math.imul(al3, bh2)) | 0;
	    mid = (mid + Math.imul(ah3, bl2)) | 0;
	    hi = (hi + Math.imul(ah3, bh2)) | 0;
	    lo = (lo + Math.imul(al2, bl3)) | 0;
	    mid = (mid + Math.imul(al2, bh3)) | 0;
	    mid = (mid + Math.imul(ah2, bl3)) | 0;
	    hi = (hi + Math.imul(ah2, bh3)) | 0;
	    lo = (lo + Math.imul(al1, bl4)) | 0;
	    mid = (mid + Math.imul(al1, bh4)) | 0;
	    mid = (mid + Math.imul(ah1, bl4)) | 0;
	    hi = (hi + Math.imul(ah1, bh4)) | 0;
	    lo = (lo + Math.imul(al0, bl5)) | 0;
	    mid = (mid + Math.imul(al0, bh5)) | 0;
	    mid = (mid + Math.imul(ah0, bl5)) | 0;
	    hi = (hi + Math.imul(ah0, bh5)) | 0;
	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
	    w5 &= 0x3ffffff;
	    /* k = 6 */
	    lo = Math.imul(al6, bl0);
	    mid = Math.imul(al6, bh0);
	    mid = (mid + Math.imul(ah6, bl0)) | 0;
	    hi = Math.imul(ah6, bh0);
	    lo = (lo + Math.imul(al5, bl1)) | 0;
	    mid = (mid + Math.imul(al5, bh1)) | 0;
	    mid = (mid + Math.imul(ah5, bl1)) | 0;
	    hi = (hi + Math.imul(ah5, bh1)) | 0;
	    lo = (lo + Math.imul(al4, bl2)) | 0;
	    mid = (mid + Math.imul(al4, bh2)) | 0;
	    mid = (mid + Math.imul(ah4, bl2)) | 0;
	    hi = (hi + Math.imul(ah4, bh2)) | 0;
	    lo = (lo + Math.imul(al3, bl3)) | 0;
	    mid = (mid + Math.imul(al3, bh3)) | 0;
	    mid = (mid + Math.imul(ah3, bl3)) | 0;
	    hi = (hi + Math.imul(ah3, bh3)) | 0;
	    lo = (lo + Math.imul(al2, bl4)) | 0;
	    mid = (mid + Math.imul(al2, bh4)) | 0;
	    mid = (mid + Math.imul(ah2, bl4)) | 0;
	    hi = (hi + Math.imul(ah2, bh4)) | 0;
	    lo = (lo + Math.imul(al1, bl5)) | 0;
	    mid = (mid + Math.imul(al1, bh5)) | 0;
	    mid = (mid + Math.imul(ah1, bl5)) | 0;
	    hi = (hi + Math.imul(ah1, bh5)) | 0;
	    lo = (lo + Math.imul(al0, bl6)) | 0;
	    mid = (mid + Math.imul(al0, bh6)) | 0;
	    mid = (mid + Math.imul(ah0, bl6)) | 0;
	    hi = (hi + Math.imul(ah0, bh6)) | 0;
	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
	    w6 &= 0x3ffffff;
	    /* k = 7 */
	    lo = Math.imul(al7, bl0);
	    mid = Math.imul(al7, bh0);
	    mid = (mid + Math.imul(ah7, bl0)) | 0;
	    hi = Math.imul(ah7, bh0);
	    lo = (lo + Math.imul(al6, bl1)) | 0;
	    mid = (mid + Math.imul(al6, bh1)) | 0;
	    mid = (mid + Math.imul(ah6, bl1)) | 0;
	    hi = (hi + Math.imul(ah6, bh1)) | 0;
	    lo = (lo + Math.imul(al5, bl2)) | 0;
	    mid = (mid + Math.imul(al5, bh2)) | 0;
	    mid = (mid + Math.imul(ah5, bl2)) | 0;
	    hi = (hi + Math.imul(ah5, bh2)) | 0;
	    lo = (lo + Math.imul(al4, bl3)) | 0;
	    mid = (mid + Math.imul(al4, bh3)) | 0;
	    mid = (mid + Math.imul(ah4, bl3)) | 0;
	    hi = (hi + Math.imul(ah4, bh3)) | 0;
	    lo = (lo + Math.imul(al3, bl4)) | 0;
	    mid = (mid + Math.imul(al3, bh4)) | 0;
	    mid = (mid + Math.imul(ah3, bl4)) | 0;
	    hi = (hi + Math.imul(ah3, bh4)) | 0;
	    lo = (lo + Math.imul(al2, bl5)) | 0;
	    mid = (mid + Math.imul(al2, bh5)) | 0;
	    mid = (mid + Math.imul(ah2, bl5)) | 0;
	    hi = (hi + Math.imul(ah2, bh5)) | 0;
	    lo = (lo + Math.imul(al1, bl6)) | 0;
	    mid = (mid + Math.imul(al1, bh6)) | 0;
	    mid = (mid + Math.imul(ah1, bl6)) | 0;
	    hi = (hi + Math.imul(ah1, bh6)) | 0;
	    lo = (lo + Math.imul(al0, bl7)) | 0;
	    mid = (mid + Math.imul(al0, bh7)) | 0;
	    mid = (mid + Math.imul(ah0, bl7)) | 0;
	    hi = (hi + Math.imul(ah0, bh7)) | 0;
	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
	    w7 &= 0x3ffffff;
	    /* k = 8 */
	    lo = Math.imul(al8, bl0);
	    mid = Math.imul(al8, bh0);
	    mid = (mid + Math.imul(ah8, bl0)) | 0;
	    hi = Math.imul(ah8, bh0);
	    lo = (lo + Math.imul(al7, bl1)) | 0;
	    mid = (mid + Math.imul(al7, bh1)) | 0;
	    mid = (mid + Math.imul(ah7, bl1)) | 0;
	    hi = (hi + Math.imul(ah7, bh1)) | 0;
	    lo = (lo + Math.imul(al6, bl2)) | 0;
	    mid = (mid + Math.imul(al6, bh2)) | 0;
	    mid = (mid + Math.imul(ah6, bl2)) | 0;
	    hi = (hi + Math.imul(ah6, bh2)) | 0;
	    lo = (lo + Math.imul(al5, bl3)) | 0;
	    mid = (mid + Math.imul(al5, bh3)) | 0;
	    mid = (mid + Math.imul(ah5, bl3)) | 0;
	    hi = (hi + Math.imul(ah5, bh3)) | 0;
	    lo = (lo + Math.imul(al4, bl4)) | 0;
	    mid = (mid + Math.imul(al4, bh4)) | 0;
	    mid = (mid + Math.imul(ah4, bl4)) | 0;
	    hi = (hi + Math.imul(ah4, bh4)) | 0;
	    lo = (lo + Math.imul(al3, bl5)) | 0;
	    mid = (mid + Math.imul(al3, bh5)) | 0;
	    mid = (mid + Math.imul(ah3, bl5)) | 0;
	    hi = (hi + Math.imul(ah3, bh5)) | 0;
	    lo = (lo + Math.imul(al2, bl6)) | 0;
	    mid = (mid + Math.imul(al2, bh6)) | 0;
	    mid = (mid + Math.imul(ah2, bl6)) | 0;
	    hi = (hi + Math.imul(ah2, bh6)) | 0;
	    lo = (lo + Math.imul(al1, bl7)) | 0;
	    mid = (mid + Math.imul(al1, bh7)) | 0;
	    mid = (mid + Math.imul(ah1, bl7)) | 0;
	    hi = (hi + Math.imul(ah1, bh7)) | 0;
	    lo = (lo + Math.imul(al0, bl8)) | 0;
	    mid = (mid + Math.imul(al0, bh8)) | 0;
	    mid = (mid + Math.imul(ah0, bl8)) | 0;
	    hi = (hi + Math.imul(ah0, bh8)) | 0;
	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
	    w8 &= 0x3ffffff;
	    /* k = 9 */
	    lo = Math.imul(al9, bl0);
	    mid = Math.imul(al9, bh0);
	    mid = (mid + Math.imul(ah9, bl0)) | 0;
	    hi = Math.imul(ah9, bh0);
	    lo = (lo + Math.imul(al8, bl1)) | 0;
	    mid = (mid + Math.imul(al8, bh1)) | 0;
	    mid = (mid + Math.imul(ah8, bl1)) | 0;
	    hi = (hi + Math.imul(ah8, bh1)) | 0;
	    lo = (lo + Math.imul(al7, bl2)) | 0;
	    mid = (mid + Math.imul(al7, bh2)) | 0;
	    mid = (mid + Math.imul(ah7, bl2)) | 0;
	    hi = (hi + Math.imul(ah7, bh2)) | 0;
	    lo = (lo + Math.imul(al6, bl3)) | 0;
	    mid = (mid + Math.imul(al6, bh3)) | 0;
	    mid = (mid + Math.imul(ah6, bl3)) | 0;
	    hi = (hi + Math.imul(ah6, bh3)) | 0;
	    lo = (lo + Math.imul(al5, bl4)) | 0;
	    mid = (mid + Math.imul(al5, bh4)) | 0;
	    mid = (mid + Math.imul(ah5, bl4)) | 0;
	    hi = (hi + Math.imul(ah5, bh4)) | 0;
	    lo = (lo + Math.imul(al4, bl5)) | 0;
	    mid = (mid + Math.imul(al4, bh5)) | 0;
	    mid = (mid + Math.imul(ah4, bl5)) | 0;
	    hi = (hi + Math.imul(ah4, bh5)) | 0;
	    lo = (lo + Math.imul(al3, bl6)) | 0;
	    mid = (mid + Math.imul(al3, bh6)) | 0;
	    mid = (mid + Math.imul(ah3, bl6)) | 0;
	    hi = (hi + Math.imul(ah3, bh6)) | 0;
	    lo = (lo + Math.imul(al2, bl7)) | 0;
	    mid = (mid + Math.imul(al2, bh7)) | 0;
	    mid = (mid + Math.imul(ah2, bl7)) | 0;
	    hi = (hi + Math.imul(ah2, bh7)) | 0;
	    lo = (lo + Math.imul(al1, bl8)) | 0;
	    mid = (mid + Math.imul(al1, bh8)) | 0;
	    mid = (mid + Math.imul(ah1, bl8)) | 0;
	    hi = (hi + Math.imul(ah1, bh8)) | 0;
	    lo = (lo + Math.imul(al0, bl9)) | 0;
	    mid = (mid + Math.imul(al0, bh9)) | 0;
	    mid = (mid + Math.imul(ah0, bl9)) | 0;
	    hi = (hi + Math.imul(ah0, bh9)) | 0;
	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
	    w9 &= 0x3ffffff;
	    /* k = 10 */
	    lo = Math.imul(al9, bl1);
	    mid = Math.imul(al9, bh1);
	    mid = (mid + Math.imul(ah9, bl1)) | 0;
	    hi = Math.imul(ah9, bh1);
	    lo = (lo + Math.imul(al8, bl2)) | 0;
	    mid = (mid + Math.imul(al8, bh2)) | 0;
	    mid = (mid + Math.imul(ah8, bl2)) | 0;
	    hi = (hi + Math.imul(ah8, bh2)) | 0;
	    lo = (lo + Math.imul(al7, bl3)) | 0;
	    mid = (mid + Math.imul(al7, bh3)) | 0;
	    mid = (mid + Math.imul(ah7, bl3)) | 0;
	    hi = (hi + Math.imul(ah7, bh3)) | 0;
	    lo = (lo + Math.imul(al6, bl4)) | 0;
	    mid = (mid + Math.imul(al6, bh4)) | 0;
	    mid = (mid + Math.imul(ah6, bl4)) | 0;
	    hi = (hi + Math.imul(ah6, bh4)) | 0;
	    lo = (lo + Math.imul(al5, bl5)) | 0;
	    mid = (mid + Math.imul(al5, bh5)) | 0;
	    mid = (mid + Math.imul(ah5, bl5)) | 0;
	    hi = (hi + Math.imul(ah5, bh5)) | 0;
	    lo = (lo + Math.imul(al4, bl6)) | 0;
	    mid = (mid + Math.imul(al4, bh6)) | 0;
	    mid = (mid + Math.imul(ah4, bl6)) | 0;
	    hi = (hi + Math.imul(ah4, bh6)) | 0;
	    lo = (lo + Math.imul(al3, bl7)) | 0;
	    mid = (mid + Math.imul(al3, bh7)) | 0;
	    mid = (mid + Math.imul(ah3, bl7)) | 0;
	    hi = (hi + Math.imul(ah3, bh7)) | 0;
	    lo = (lo + Math.imul(al2, bl8)) | 0;
	    mid = (mid + Math.imul(al2, bh8)) | 0;
	    mid = (mid + Math.imul(ah2, bl8)) | 0;
	    hi = (hi + Math.imul(ah2, bh8)) | 0;
	    lo = (lo + Math.imul(al1, bl9)) | 0;
	    mid = (mid + Math.imul(al1, bh9)) | 0;
	    mid = (mid + Math.imul(ah1, bl9)) | 0;
	    hi = (hi + Math.imul(ah1, bh9)) | 0;
	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
	    w10 &= 0x3ffffff;
	    /* k = 11 */
	    lo = Math.imul(al9, bl2);
	    mid = Math.imul(al9, bh2);
	    mid = (mid + Math.imul(ah9, bl2)) | 0;
	    hi = Math.imul(ah9, bh2);
	    lo = (lo + Math.imul(al8, bl3)) | 0;
	    mid = (mid + Math.imul(al8, bh3)) | 0;
	    mid = (mid + Math.imul(ah8, bl3)) | 0;
	    hi = (hi + Math.imul(ah8, bh3)) | 0;
	    lo = (lo + Math.imul(al7, bl4)) | 0;
	    mid = (mid + Math.imul(al7, bh4)) | 0;
	    mid = (mid + Math.imul(ah7, bl4)) | 0;
	    hi = (hi + Math.imul(ah7, bh4)) | 0;
	    lo = (lo + Math.imul(al6, bl5)) | 0;
	    mid = (mid + Math.imul(al6, bh5)) | 0;
	    mid = (mid + Math.imul(ah6, bl5)) | 0;
	    hi = (hi + Math.imul(ah6, bh5)) | 0;
	    lo = (lo + Math.imul(al5, bl6)) | 0;
	    mid = (mid + Math.imul(al5, bh6)) | 0;
	    mid = (mid + Math.imul(ah5, bl6)) | 0;
	    hi = (hi + Math.imul(ah5, bh6)) | 0;
	    lo = (lo + Math.imul(al4, bl7)) | 0;
	    mid = (mid + Math.imul(al4, bh7)) | 0;
	    mid = (mid + Math.imul(ah4, bl7)) | 0;
	    hi = (hi + Math.imul(ah4, bh7)) | 0;
	    lo = (lo + Math.imul(al3, bl8)) | 0;
	    mid = (mid + Math.imul(al3, bh8)) | 0;
	    mid = (mid + Math.imul(ah3, bl8)) | 0;
	    hi = (hi + Math.imul(ah3, bh8)) | 0;
	    lo = (lo + Math.imul(al2, bl9)) | 0;
	    mid = (mid + Math.imul(al2, bh9)) | 0;
	    mid = (mid + Math.imul(ah2, bl9)) | 0;
	    hi = (hi + Math.imul(ah2, bh9)) | 0;
	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
	    w11 &= 0x3ffffff;
	    /* k = 12 */
	    lo = Math.imul(al9, bl3);
	    mid = Math.imul(al9, bh3);
	    mid = (mid + Math.imul(ah9, bl3)) | 0;
	    hi = Math.imul(ah9, bh3);
	    lo = (lo + Math.imul(al8, bl4)) | 0;
	    mid = (mid + Math.imul(al8, bh4)) | 0;
	    mid = (mid + Math.imul(ah8, bl4)) | 0;
	    hi = (hi + Math.imul(ah8, bh4)) | 0;
	    lo = (lo + Math.imul(al7, bl5)) | 0;
	    mid = (mid + Math.imul(al7, bh5)) | 0;
	    mid = (mid + Math.imul(ah7, bl5)) | 0;
	    hi = (hi + Math.imul(ah7, bh5)) | 0;
	    lo = (lo + Math.imul(al6, bl6)) | 0;
	    mid = (mid + Math.imul(al6, bh6)) | 0;
	    mid = (mid + Math.imul(ah6, bl6)) | 0;
	    hi = (hi + Math.imul(ah6, bh6)) | 0;
	    lo = (lo + Math.imul(al5, bl7)) | 0;
	    mid = (mid + Math.imul(al5, bh7)) | 0;
	    mid = (mid + Math.imul(ah5, bl7)) | 0;
	    hi = (hi + Math.imul(ah5, bh7)) | 0;
	    lo = (lo + Math.imul(al4, bl8)) | 0;
	    mid = (mid + Math.imul(al4, bh8)) | 0;
	    mid = (mid + Math.imul(ah4, bl8)) | 0;
	    hi = (hi + Math.imul(ah4, bh8)) | 0;
	    lo = (lo + Math.imul(al3, bl9)) | 0;
	    mid = (mid + Math.imul(al3, bh9)) | 0;
	    mid = (mid + Math.imul(ah3, bl9)) | 0;
	    hi = (hi + Math.imul(ah3, bh9)) | 0;
	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
	    w12 &= 0x3ffffff;
	    /* k = 13 */
	    lo = Math.imul(al9, bl4);
	    mid = Math.imul(al9, bh4);
	    mid = (mid + Math.imul(ah9, bl4)) | 0;
	    hi = Math.imul(ah9, bh4);
	    lo = (lo + Math.imul(al8, bl5)) | 0;
	    mid = (mid + Math.imul(al8, bh5)) | 0;
	    mid = (mid + Math.imul(ah8, bl5)) | 0;
	    hi = (hi + Math.imul(ah8, bh5)) | 0;
	    lo = (lo + Math.imul(al7, bl6)) | 0;
	    mid = (mid + Math.imul(al7, bh6)) | 0;
	    mid = (mid + Math.imul(ah7, bl6)) | 0;
	    hi = (hi + Math.imul(ah7, bh6)) | 0;
	    lo = (lo + Math.imul(al6, bl7)) | 0;
	    mid = (mid + Math.imul(al6, bh7)) | 0;
	    mid = (mid + Math.imul(ah6, bl7)) | 0;
	    hi = (hi + Math.imul(ah6, bh7)) | 0;
	    lo = (lo + Math.imul(al5, bl8)) | 0;
	    mid = (mid + Math.imul(al5, bh8)) | 0;
	    mid = (mid + Math.imul(ah5, bl8)) | 0;
	    hi = (hi + Math.imul(ah5, bh8)) | 0;
	    lo = (lo + Math.imul(al4, bl9)) | 0;
	    mid = (mid + Math.imul(al4, bh9)) | 0;
	    mid = (mid + Math.imul(ah4, bl9)) | 0;
	    hi = (hi + Math.imul(ah4, bh9)) | 0;
	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
	    w13 &= 0x3ffffff;
	    /* k = 14 */
	    lo = Math.imul(al9, bl5);
	    mid = Math.imul(al9, bh5);
	    mid = (mid + Math.imul(ah9, bl5)) | 0;
	    hi = Math.imul(ah9, bh5);
	    lo = (lo + Math.imul(al8, bl6)) | 0;
	    mid = (mid + Math.imul(al8, bh6)) | 0;
	    mid = (mid + Math.imul(ah8, bl6)) | 0;
	    hi = (hi + Math.imul(ah8, bh6)) | 0;
	    lo = (lo + Math.imul(al7, bl7)) | 0;
	    mid = (mid + Math.imul(al7, bh7)) | 0;
	    mid = (mid + Math.imul(ah7, bl7)) | 0;
	    hi = (hi + Math.imul(ah7, bh7)) | 0;
	    lo = (lo + Math.imul(al6, bl8)) | 0;
	    mid = (mid + Math.imul(al6, bh8)) | 0;
	    mid = (mid + Math.imul(ah6, bl8)) | 0;
	    hi = (hi + Math.imul(ah6, bh8)) | 0;
	    lo = (lo + Math.imul(al5, bl9)) | 0;
	    mid = (mid + Math.imul(al5, bh9)) | 0;
	    mid = (mid + Math.imul(ah5, bl9)) | 0;
	    hi = (hi + Math.imul(ah5, bh9)) | 0;
	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
	    w14 &= 0x3ffffff;
	    /* k = 15 */
	    lo = Math.imul(al9, bl6);
	    mid = Math.imul(al9, bh6);
	    mid = (mid + Math.imul(ah9, bl6)) | 0;
	    hi = Math.imul(ah9, bh6);
	    lo = (lo + Math.imul(al8, bl7)) | 0;
	    mid = (mid + Math.imul(al8, bh7)) | 0;
	    mid = (mid + Math.imul(ah8, bl7)) | 0;
	    hi = (hi + Math.imul(ah8, bh7)) | 0;
	    lo = (lo + Math.imul(al7, bl8)) | 0;
	    mid = (mid + Math.imul(al7, bh8)) | 0;
	    mid = (mid + Math.imul(ah7, bl8)) | 0;
	    hi = (hi + Math.imul(ah7, bh8)) | 0;
	    lo = (lo + Math.imul(al6, bl9)) | 0;
	    mid = (mid + Math.imul(al6, bh9)) | 0;
	    mid = (mid + Math.imul(ah6, bl9)) | 0;
	    hi = (hi + Math.imul(ah6, bh9)) | 0;
	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
	    w15 &= 0x3ffffff;
	    /* k = 16 */
	    lo = Math.imul(al9, bl7);
	    mid = Math.imul(al9, bh7);
	    mid = (mid + Math.imul(ah9, bl7)) | 0;
	    hi = Math.imul(ah9, bh7);
	    lo = (lo + Math.imul(al8, bl8)) | 0;
	    mid = (mid + Math.imul(al8, bh8)) | 0;
	    mid = (mid + Math.imul(ah8, bl8)) | 0;
	    hi = (hi + Math.imul(ah8, bh8)) | 0;
	    lo = (lo + Math.imul(al7, bl9)) | 0;
	    mid = (mid + Math.imul(al7, bh9)) | 0;
	    mid = (mid + Math.imul(ah7, bl9)) | 0;
	    hi = (hi + Math.imul(ah7, bh9)) | 0;
	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
	    w16 &= 0x3ffffff;
	    /* k = 17 */
	    lo = Math.imul(al9, bl8);
	    mid = Math.imul(al9, bh8);
	    mid = (mid + Math.imul(ah9, bl8)) | 0;
	    hi = Math.imul(ah9, bh8);
	    lo = (lo + Math.imul(al8, bl9)) | 0;
	    mid = (mid + Math.imul(al8, bh9)) | 0;
	    mid = (mid + Math.imul(ah8, bl9)) | 0;
	    hi = (hi + Math.imul(ah8, bh9)) | 0;
	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
	    w17 &= 0x3ffffff;
	    /* k = 18 */
	    lo = Math.imul(al9, bl9);
	    mid = Math.imul(al9, bh9);
	    mid = (mid + Math.imul(ah9, bl9)) | 0;
	    hi = Math.imul(ah9, bh9);
	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
	    w18 &= 0x3ffffff;
	    o[0] = w0;
	    o[1] = w1;
	    o[2] = w2;
	    o[3] = w3;
	    o[4] = w4;
	    o[5] = w5;
	    o[6] = w6;
	    o[7] = w7;
	    o[8] = w8;
	    o[9] = w9;
	    o[10] = w10;
	    o[11] = w11;
	    o[12] = w12;
	    o[13] = w13;
	    o[14] = w14;
	    o[15] = w15;
	    o[16] = w16;
	    o[17] = w17;
	    o[18] = w18;
	    if (c !== 0) {
	      o[19] = c;
	      out.length++;
	    }
	    return out;
	  };

	  // Polyfill comb
	  if (!Math.imul) {
	    comb10MulTo = smallMulTo;
	  }

	  function bigMulTo (self, num, out) {
	    out.negative = num.negative ^ self.negative;
	    out.length = self.length + num.length;

	    var carry = 0;
	    var hncarry = 0;
	    for (var k = 0; k < out.length - 1; k++) {
	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
	      // note that ncarry could be >= 0x3ffffff
	      var ncarry = hncarry;
	      hncarry = 0;
	      var rword = carry & 0x3ffffff;
	      var maxJ = Math.min(k, num.length - 1);
	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
	        var i = k - j;
	        var a = self.words[i] | 0;
	        var b = num.words[j] | 0;
	        var r = a * b;

	        var lo = r & 0x3ffffff;
	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
	        lo = (lo + rword) | 0;
	        rword = lo & 0x3ffffff;
	        ncarry = (ncarry + (lo >>> 26)) | 0;

	        hncarry += ncarry >>> 26;
	        ncarry &= 0x3ffffff;
	      }
	      out.words[k] = rword;
	      carry = ncarry;
	      ncarry = hncarry;
	    }
	    if (carry !== 0) {
	      out.words[k] = carry;
	    } else {
	      out.length--;
	    }

	    return out.strip();
	  }

	  function jumboMulTo (self, num, out) {
	    var fftm = new FFTM();
	    return fftm.mulp(self, num, out);
	  }

	  BN.prototype.mulTo = function mulTo (num, out) {
	    var res;
	    var len = this.length + num.length;
	    if (this.length === 10 && num.length === 10) {
	      res = comb10MulTo(this, num, out);
	    } else if (len < 63) {
	      res = smallMulTo(this, num, out);
	    } else if (len < 1024) {
	      res = bigMulTo(this, num, out);
	    } else {
	      res = jumboMulTo(this, num, out);
	    }

	    return res;
	  };

	  // Cooley-Tukey algorithm for FFT
	  // slightly revisited to rely on looping instead of recursion

	  function FFTM (x, y) {
	    this.x = x;
	    this.y = y;
	  }

	  FFTM.prototype.makeRBT = function makeRBT (N) {
	    var t = new Array(N);
	    var l = BN.prototype._countBits(N) - 1;
	    for (var i = 0; i < N; i++) {
	      t[i] = this.revBin(i, l, N);
	    }

	    return t;
	  };

	  // Returns binary-reversed representation of `x`
	  FFTM.prototype.revBin = function revBin (x, l, N) {
	    if (x === 0 || x === N - 1) return x;

	    var rb = 0;
	    for (var i = 0; i < l; i++) {
	      rb |= (x & 1) << (l - i - 1);
	      x >>= 1;
	    }

	    return rb;
	  };

	  // Performs "tweedling" phase, therefore 'emulating'
	  // behaviour of the recursive algorithm
	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
	    for (var i = 0; i < N; i++) {
	      rtws[i] = rws[rbt[i]];
	      itws[i] = iws[rbt[i]];
	    }
	  };

	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
	    this.permute(rbt, rws, iws, rtws, itws, N);

	    for (var s = 1; s < N; s <<= 1) {
	      var l = s << 1;

	      var rtwdf = Math.cos(2 * Math.PI / l);
	      var itwdf = Math.sin(2 * Math.PI / l);

	      for (var p = 0; p < N; p += l) {
	        var rtwdf_ = rtwdf;
	        var itwdf_ = itwdf;

	        for (var j = 0; j < s; j++) {
	          var re = rtws[p + j];
	          var ie = itws[p + j];

	          var ro = rtws[p + j + s];
	          var io = itws[p + j + s];

	          var rx = rtwdf_ * ro - itwdf_ * io;

	          io = rtwdf_ * io + itwdf_ * ro;
	          ro = rx;

	          rtws[p + j] = re + ro;
	          itws[p + j] = ie + io;

	          rtws[p + j + s] = re - ro;
	          itws[p + j + s] = ie - io;

	          /* jshint maxdepth : false */
	          if (j !== l) {
	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
	            rtwdf_ = rx;
	          }
	        }
	      }
	    }
	  };

	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
	    var N = Math.max(m, n) | 1;
	    var odd = N & 1;
	    var i = 0;
	    for (N = N / 2 | 0; N; N = N >>> 1) {
	      i++;
	    }

	    return 1 << i + 1 + odd;
	  };

	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
	    if (N <= 1) return;

	    for (var i = 0; i < N / 2; i++) {
	      var t = rws[i];

	      rws[i] = rws[N - i - 1];
	      rws[N - i - 1] = t;

	      t = iws[i];

	      iws[i] = -iws[N - i - 1];
	      iws[N - i - 1] = -t;
	    }
	  };

	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
	    var carry = 0;
	    for (var i = 0; i < N / 2; i++) {
	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
	        Math.round(ws[2 * i] / N) +
	        carry;

	      ws[i] = w & 0x3ffffff;

	      if (w < 0x4000000) {
	        carry = 0;
	      } else {
	        carry = w / 0x4000000 | 0;
	      }
	    }

	    return ws;
	  };

	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
	    var carry = 0;
	    for (var i = 0; i < len; i++) {
	      carry = carry + (ws[i] | 0);

	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
	    }

	    // Pad with zeroes
	    for (i = 2 * len; i < N; ++i) {
	      rws[i] = 0;
	    }

	    assert(carry === 0);
	    assert((carry & ~0x1fff) === 0);
	  };

	  FFTM.prototype.stub = function stub (N) {
	    var ph = new Array(N);
	    for (var i = 0; i < N; i++) {
	      ph[i] = 0;
	    }

	    return ph;
	  };

	  FFTM.prototype.mulp = function mulp (x, y, out) {
	    var N = 2 * this.guessLen13b(x.length, y.length);

	    var rbt = this.makeRBT(N);

	    var _ = this.stub(N);

	    var rws = new Array(N);
	    var rwst = new Array(N);
	    var iwst = new Array(N);

	    var nrws = new Array(N);
	    var nrwst = new Array(N);
	    var niwst = new Array(N);

	    var rmws = out.words;
	    rmws.length = N;

	    this.convert13b(x.words, x.length, rws, N);
	    this.convert13b(y.words, y.length, nrws, N);

	    this.transform(rws, _, rwst, iwst, N, rbt);
	    this.transform(nrws, _, nrwst, niwst, N, rbt);

	    for (var i = 0; i < N; i++) {
	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
	      rwst[i] = rx;
	    }

	    this.conjugate(rwst, iwst, N);
	    this.transform(rwst, iwst, rmws, _, N, rbt);
	    this.conjugate(rmws, _, N);
	    this.normalize13b(rmws, N);

	    out.negative = x.negative ^ y.negative;
	    out.length = x.length + y.length;
	    return out.strip();
	  };

	  // Multiply `this` by `num`
	  BN.prototype.mul = function mul (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return this.mulTo(num, out);
	  };

	  // Multiply employing FFT
	  BN.prototype.mulf = function mulf (num) {
	    var out = new BN(null);
	    out.words = new Array(this.length + num.length);
	    return jumboMulTo(this, num, out);
	  };

	  // In-place Multiplication
	  BN.prototype.imul = function imul (num) {
	    return this.clone().mulTo(num, this);
	  };

	  BN.prototype.imuln = function imuln (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);

	    // Carry
	    var carry = 0;
	    for (var i = 0; i < this.length; i++) {
	      var w = (this.words[i] | 0) * num;
	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
	      carry >>= 26;
	      carry += (w / 0x4000000) | 0;
	      // NOTE: lo is 27bit maximum
	      carry += lo >>> 26;
	      this.words[i] = lo & 0x3ffffff;
	    }

	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }

	    return this;
	  };

	  BN.prototype.muln = function muln (num) {
	    return this.clone().imuln(num);
	  };

	  // `this` * `this`
	  BN.prototype.sqr = function sqr () {
	    return this.mul(this);
	  };

	  // `this` * `this` in-place
	  BN.prototype.isqr = function isqr () {
	    return this.imul(this.clone());
	  };

	  // Math.pow(`this`, `num`)
	  BN.prototype.pow = function pow (num) {
	    var w = toBitArray(num);
	    if (w.length === 0) return new BN(1);

	    // Skip leading zeroes
	    var res = this;
	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
	      if (w[i] !== 0) break;
	    }

	    if (++i < w.length) {
	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
	        if (w[i] === 0) continue;

	        res = res.mul(q);
	      }
	    }

	    return res;
	  };

	  // Shift-left in-place
	  BN.prototype.iushln = function iushln (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;
	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
	    var i;

	    if (r !== 0) {
	      var carry = 0;

	      for (i = 0; i < this.length; i++) {
	        var newCarry = this.words[i] & carryMask;
	        var c = ((this.words[i] | 0) - newCarry) << r;
	        this.words[i] = c | carry;
	        carry = newCarry >>> (26 - r);
	      }

	      if (carry) {
	        this.words[i] = carry;
	        this.length++;
	      }
	    }

	    if (s !== 0) {
	      for (i = this.length - 1; i >= 0; i--) {
	        this.words[i + s] = this.words[i];
	      }

	      for (i = 0; i < s; i++) {
	        this.words[i] = 0;
	      }

	      this.length += s;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishln = function ishln (bits) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushln(bits);
	  };

	  // Shift-right in-place
	  // NOTE: `hint` is a lowest bit before trailing zeroes
	  // NOTE: if `extended` is present - it will be filled with destroyed bits
	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var h;
	    if (hint) {
	      h = (hint - (hint % 26)) / 26;
	    } else {
	      h = 0;
	    }

	    var r = bits % 26;
	    var s = Math.min((bits - r) / 26, this.length);
	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	    var maskedWords = extended;

	    h -= s;
	    h = Math.max(0, h);

	    // Extended mode, copy masked part
	    if (maskedWords) {
	      for (var i = 0; i < s; i++) {
	        maskedWords.words[i] = this.words[i];
	      }
	      maskedWords.length = s;
	    }

	    if (s === 0) {
	      // No-op, we should not move anything at all
	    } else if (this.length > s) {
	      this.length -= s;
	      for (i = 0; i < this.length; i++) {
	        this.words[i] = this.words[i + s];
	      }
	    } else {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    var carry = 0;
	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
	      var word = this.words[i] | 0;
	      this.words[i] = (carry << (26 - r)) | (word >>> r);
	      carry = word & mask;
	    }

	    // Push carried bits as a mask
	    if (maskedWords && carry !== 0) {
	      maskedWords.words[maskedWords.length++] = carry;
	    }

	    if (this.length === 0) {
	      this.words[0] = 0;
	      this.length = 1;
	    }

	    return this.strip();
	  };

	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
	    // TODO(indutny): implement me
	    assert(this.negative === 0);
	    return this.iushrn(bits, hint, extended);
	  };

	  // Shift-left
	  BN.prototype.shln = function shln (bits) {
	    return this.clone().ishln(bits);
	  };

	  BN.prototype.ushln = function ushln (bits) {
	    return this.clone().iushln(bits);
	  };

	  // Shift-right
	  BN.prototype.shrn = function shrn (bits) {
	    return this.clone().ishrn(bits);
	  };

	  BN.prototype.ushrn = function ushrn (bits) {
	    return this.clone().iushrn(bits);
	  };

	  // Test if n bit is set
	  BN.prototype.testn = function testn (bit) {
	    assert(typeof bit === 'number' && bit >= 0);
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) return false;

	    // Check bit and return
	    var w = this.words[s];

	    return !!(w & q);
	  };

	  // Return only lowers bits of number (in-place)
	  BN.prototype.imaskn = function imaskn (bits) {
	    assert(typeof bits === 'number' && bits >= 0);
	    var r = bits % 26;
	    var s = (bits - r) / 26;

	    assert(this.negative === 0, 'imaskn works only with positive numbers');

	    if (this.length <= s) {
	      return this;
	    }

	    if (r !== 0) {
	      s++;
	    }
	    this.length = Math.min(s, this.length);

	    if (r !== 0) {
	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
	      this.words[this.length - 1] &= mask;
	    }

	    return this.strip();
	  };

	  // Return only lowers bits of number
	  BN.prototype.maskn = function maskn (bits) {
	    return this.clone().imaskn(bits);
	  };

	  // Add plain number `num` to `this`
	  BN.prototype.iaddn = function iaddn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.isubn(-num);

	    // Possible sign change
	    if (this.negative !== 0) {
	      if (this.length === 1 && (this.words[0] | 0) < num) {
	        this.words[0] = num - (this.words[0] | 0);
	        this.negative = 0;
	        return this;
	      }

	      this.negative = 0;
	      this.isubn(num);
	      this.negative = 1;
	      return this;
	    }

	    // Add without checks
	    return this._iaddn(num);
	  };

	  BN.prototype._iaddn = function _iaddn (num) {
	    this.words[0] += num;

	    // Carry
	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
	      this.words[i] -= 0x4000000;
	      if (i === this.length - 1) {
	        this.words[i + 1] = 1;
	      } else {
	        this.words[i + 1]++;
	      }
	    }
	    this.length = Math.max(this.length, i + 1);

	    return this;
	  };

	  // Subtract plain number `num` from `this`
	  BN.prototype.isubn = function isubn (num) {
	    assert(typeof num === 'number');
	    assert(num < 0x4000000);
	    if (num < 0) return this.iaddn(-num);

	    if (this.negative !== 0) {
	      this.negative = 0;
	      this.iaddn(num);
	      this.negative = 1;
	      return this;
	    }

	    this.words[0] -= num;

	    if (this.length === 1 && this.words[0] < 0) {
	      this.words[0] = -this.words[0];
	      this.negative = 1;
	    } else {
	      // Carry
	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
	        this.words[i] += 0x4000000;
	        this.words[i + 1] -= 1;
	      }
	    }

	    return this.strip();
	  };

	  BN.prototype.addn = function addn (num) {
	    return this.clone().iaddn(num);
	  };

	  BN.prototype.subn = function subn (num) {
	    return this.clone().isubn(num);
	  };

	  BN.prototype.iabs = function iabs () {
	    this.negative = 0;

	    return this;
	  };

	  BN.prototype.abs = function abs () {
	    return this.clone().iabs();
	  };

	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
	    var len = num.length + shift;
	    var i;

	    this._expand(len);

	    var w;
	    var carry = 0;
	    for (i = 0; i < num.length; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      var right = (num.words[i] | 0) * mul;
	      w -= right & 0x3ffffff;
	      carry = (w >> 26) - ((right / 0x4000000) | 0);
	      this.words[i + shift] = w & 0x3ffffff;
	    }
	    for (; i < this.length - shift; i++) {
	      w = (this.words[i + shift] | 0) + carry;
	      carry = w >> 26;
	      this.words[i + shift] = w & 0x3ffffff;
	    }

	    if (carry === 0) return this.strip();

	    // Subtraction overflow
	    assert(carry === -1);
	    carry = 0;
	    for (i = 0; i < this.length; i++) {
	      w = -(this.words[i] | 0) + carry;
	      carry = w >> 26;
	      this.words[i] = w & 0x3ffffff;
	    }
	    this.negative = 1;

	    return this.strip();
	  };

	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
	    var shift = this.length - num.length;

	    var a = this.clone();
	    var b = num;

	    // Normalize
	    var bhi = b.words[b.length - 1] | 0;
	    var bhiBits = this._countBits(bhi);
	    shift = 26 - bhiBits;
	    if (shift !== 0) {
	      b = b.ushln(shift);
	      a.iushln(shift);
	      bhi = b.words[b.length - 1] | 0;
	    }

	    // Initialize quotient
	    var m = a.length - b.length;
	    var q;

	    if (mode !== 'mod') {
	      q = new BN(null);
	      q.length = m + 1;
	      q.words = new Array(q.length);
	      for (var i = 0; i < q.length; i++) {
	        q.words[i] = 0;
	      }
	    }

	    var diff = a.clone()._ishlnsubmul(b, 1, m);
	    if (diff.negative === 0) {
	      a = diff;
	      if (q) {
	        q.words[m] = 1;
	      }
	    }

	    for (var j = m - 1; j >= 0; j--) {
	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
	        (a.words[b.length + j - 1] | 0);

	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
	      // (0x7ffffff)
	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

	      a._ishlnsubmul(b, qj, j);
	      while (a.negative !== 0) {
	        qj--;
	        a.negative = 0;
	        a._ishlnsubmul(b, 1, j);
	        if (!a.isZero()) {
	          a.negative ^= 1;
	        }
	      }
	      if (q) {
	        q.words[j] = qj;
	      }
	    }
	    if (q) {
	      q.strip();
	    }
	    a.strip();

	    // Denormalize
	    if (mode !== 'div' && shift !== 0) {
	      a.iushrn(shift);
	    }

	    return {
	      div: q || null,
	      mod: a
	    };
	  };

	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
	  //       to `div` to request div only, or be absent to
	  //       request both div & mod
	  //       2) `positive` is true if unsigned mod is requested
	  BN.prototype.divmod = function divmod (num, mode, positive) {
	    assert(!num.isZero());

	    if (this.isZero()) {
	      return {
	        div: new BN(0),
	        mod: new BN(0)
	      };
	    }

	    var div, mod, res;
	    if (this.negative !== 0 && num.negative === 0) {
	      res = this.neg().divmod(num, mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.iadd(num);
	        }
	      }

	      return {
	        div: div,
	        mod: mod
	      };
	    }

	    if (this.negative === 0 && num.negative !== 0) {
	      res = this.divmod(num.neg(), mode);

	      if (mode !== 'mod') {
	        div = res.div.neg();
	      }

	      return {
	        div: div,
	        mod: res.mod
	      };
	    }

	    if ((this.negative & num.negative) !== 0) {
	      res = this.neg().divmod(num.neg(), mode);

	      if (mode !== 'div') {
	        mod = res.mod.neg();
	        if (positive && mod.negative !== 0) {
	          mod.isub(num);
	        }
	      }

	      return {
	        div: res.div,
	        mod: mod
	      };
	    }

	    // Both numbers are positive at this point

	    // Strip both numbers to approximate shift value
	    if (num.length > this.length || this.cmp(num) < 0) {
	      return {
	        div: new BN(0),
	        mod: this
	      };
	    }

	    // Very short reduction
	    if (num.length === 1) {
	      if (mode === 'div') {
	        return {
	          div: this.divn(num.words[0]),
	          mod: null
	        };
	      }

	      if (mode === 'mod') {
	        return {
	          div: null,
	          mod: new BN(this.modn(num.words[0]))
	        };
	      }

	      return {
	        div: this.divn(num.words[0]),
	        mod: new BN(this.modn(num.words[0]))
	      };
	    }

	    return this._wordDiv(num, mode);
	  };

	  // Find `this` / `num`
	  BN.prototype.div = function div (num) {
	    return this.divmod(num, 'div', false).div;
	  };

	  // Find `this` % `num`
	  BN.prototype.mod = function mod (num) {
	    return this.divmod(num, 'mod', false).mod;
	  };

	  BN.prototype.umod = function umod (num) {
	    return this.divmod(num, 'mod', true).mod;
	  };

	  // Find Round(`this` / `num`)
	  BN.prototype.divRound = function divRound (num) {
	    var dm = this.divmod(num);

	    // Fast case - exact division
	    if (dm.mod.isZero()) return dm.div;

	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

	    var half = num.ushrn(1);
	    var r2 = num.andln(1);
	    var cmp = mod.cmp(half);

	    // Round down
	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

	    // Round up
	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
	  };

	  BN.prototype.modn = function modn (num) {
	    assert(num <= 0x3ffffff);
	    var p = (1 << 26) % num;

	    var acc = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      acc = (p * acc + (this.words[i] | 0)) % num;
	    }

	    return acc;
	  };

	  // In-place division by number
	  BN.prototype.idivn = function idivn (num) {
	    assert(num <= 0x3ffffff);

	    var carry = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var w = (this.words[i] | 0) + carry * 0x4000000;
	      this.words[i] = (w / num) | 0;
	      carry = w % num;
	    }

	    return this.strip();
	  };

	  BN.prototype.divn = function divn (num) {
	    return this.clone().idivn(num);
	  };

	  BN.prototype.egcd = function egcd (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var x = this;
	    var y = p.clone();

	    if (x.negative !== 0) {
	      x = x.umod(p);
	    } else {
	      x = x.clone();
	    }

	    // A * x + B * y = x
	    var A = new BN(1);
	    var B = new BN(0);

	    // C * x + D * y = y
	    var C = new BN(0);
	    var D = new BN(1);

	    var g = 0;

	    while (x.isEven() && y.isEven()) {
	      x.iushrn(1);
	      y.iushrn(1);
	      ++g;
	    }

	    var yp = y.clone();
	    var xp = x.clone();

	    while (!x.isZero()) {
	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        x.iushrn(i);
	        while (i-- > 0) {
	          if (A.isOdd() || B.isOdd()) {
	            A.iadd(yp);
	            B.isub(xp);
	          }

	          A.iushrn(1);
	          B.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        y.iushrn(j);
	        while (j-- > 0) {
	          if (C.isOdd() || D.isOdd()) {
	            C.iadd(yp);
	            D.isub(xp);
	          }

	          C.iushrn(1);
	          D.iushrn(1);
	        }
	      }

	      if (x.cmp(y) >= 0) {
	        x.isub(y);
	        A.isub(C);
	        B.isub(D);
	      } else {
	        y.isub(x);
	        C.isub(A);
	        D.isub(B);
	      }
	    }

	    return {
	      a: C,
	      b: D,
	      gcd: y.iushln(g)
	    };
	  };

	  // This is reduced incarnation of the binary EEA
	  // above, designated to invert members of the
	  // _prime_ fields F(p) at a maximal speed
	  BN.prototype._invmp = function _invmp (p) {
	    assert(p.negative === 0);
	    assert(!p.isZero());

	    var a = this;
	    var b = p.clone();

	    if (a.negative !== 0) {
	      a = a.umod(p);
	    } else {
	      a = a.clone();
	    }

	    var x1 = new BN(1);
	    var x2 = new BN(0);

	    var delta = b.clone();

	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
	      if (i > 0) {
	        a.iushrn(i);
	        while (i-- > 0) {
	          if (x1.isOdd()) {
	            x1.iadd(delta);
	          }

	          x1.iushrn(1);
	        }
	      }

	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
	      if (j > 0) {
	        b.iushrn(j);
	        while (j-- > 0) {
	          if (x2.isOdd()) {
	            x2.iadd(delta);
	          }

	          x2.iushrn(1);
	        }
	      }

	      if (a.cmp(b) >= 0) {
	        a.isub(b);
	        x1.isub(x2);
	      } else {
	        b.isub(a);
	        x2.isub(x1);
	      }
	    }

	    var res;
	    if (a.cmpn(1) === 0) {
	      res = x1;
	    } else {
	      res = x2;
	    }

	    if (res.cmpn(0) < 0) {
	      res.iadd(p);
	    }

	    return res;
	  };

	  BN.prototype.gcd = function gcd (num) {
	    if (this.isZero()) return num.abs();
	    if (num.isZero()) return this.abs();

	    var a = this.clone();
	    var b = num.clone();
	    a.negative = 0;
	    b.negative = 0;

	    // Remove common factor of two
	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
	      a.iushrn(1);
	      b.iushrn(1);
	    }

	    do {
	      while (a.isEven()) {
	        a.iushrn(1);
	      }
	      while (b.isEven()) {
	        b.iushrn(1);
	      }

	      var r = a.cmp(b);
	      if (r < 0) {
	        // Swap `a` and `b` to make `a` always bigger than `b`
	        var t = a;
	        a = b;
	        b = t;
	      } else if (r === 0 || b.cmpn(1) === 0) {
	        break;
	      }

	      a.isub(b);
	    } while (true);

	    return b.iushln(shift);
	  };

	  // Invert number in the field F(num)
	  BN.prototype.invm = function invm (num) {
	    return this.egcd(num).a.umod(num);
	  };

	  BN.prototype.isEven = function isEven () {
	    return (this.words[0] & 1) === 0;
	  };

	  BN.prototype.isOdd = function isOdd () {
	    return (this.words[0] & 1) === 1;
	  };

	  // And first word and num
	  BN.prototype.andln = function andln (num) {
	    return this.words[0] & num;
	  };

	  // Increment at the bit position in-line
	  BN.prototype.bincn = function bincn (bit) {
	    assert(typeof bit === 'number');
	    var r = bit % 26;
	    var s = (bit - r) / 26;
	    var q = 1 << r;

	    // Fast case: bit is much higher than all existing words
	    if (this.length <= s) {
	      this._expand(s + 1);
	      this.words[s] |= q;
	      return this;
	    }

	    // Add bit and propagate, if needed
	    var carry = q;
	    for (var i = s; carry !== 0 && i < this.length; i++) {
	      var w = this.words[i] | 0;
	      w += carry;
	      carry = w >>> 26;
	      w &= 0x3ffffff;
	      this.words[i] = w;
	    }
	    if (carry !== 0) {
	      this.words[i] = carry;
	      this.length++;
	    }
	    return this;
	  };

	  BN.prototype.isZero = function isZero () {
	    return this.length === 1 && this.words[0] === 0;
	  };

	  BN.prototype.cmpn = function cmpn (num) {
	    var negative = num < 0;

	    if (this.negative !== 0 && !negative) return -1;
	    if (this.negative === 0 && negative) return 1;

	    this.strip();

	    var res;
	    if (this.length > 1) {
	      res = 1;
	    } else {
	      if (negative) {
	        num = -num;
	      }

	      assert(num <= 0x3ffffff, 'Number is too big');

	      var w = this.words[0] | 0;
	      res = w === num ? 0 : w < num ? -1 : 1;
	    }
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Compare two numbers and return:
	  // 1 - if `this` > `num`
	  // 0 - if `this` == `num`
	  // -1 - if `this` < `num`
	  BN.prototype.cmp = function cmp (num) {
	    if (this.negative !== 0 && num.negative === 0) return -1;
	    if (this.negative === 0 && num.negative !== 0) return 1;

	    var res = this.ucmp(num);
	    if (this.negative !== 0) return -res | 0;
	    return res;
	  };

	  // Unsigned comparison
	  BN.prototype.ucmp = function ucmp (num) {
	    // At this point both numbers have the same sign
	    if (this.length > num.length) return 1;
	    if (this.length < num.length) return -1;

	    var res = 0;
	    for (var i = this.length - 1; i >= 0; i--) {
	      var a = this.words[i] | 0;
	      var b = num.words[i] | 0;

	      if (a === b) continue;
	      if (a < b) {
	        res = -1;
	      } else if (a > b) {
	        res = 1;
	      }
	      break;
	    }
	    return res;
	  };

	  BN.prototype.gtn = function gtn (num) {
	    return this.cmpn(num) === 1;
	  };

	  BN.prototype.gt = function gt (num) {
	    return this.cmp(num) === 1;
	  };

	  BN.prototype.gten = function gten (num) {
	    return this.cmpn(num) >= 0;
	  };

	  BN.prototype.gte = function gte (num) {
	    return this.cmp(num) >= 0;
	  };

	  BN.prototype.ltn = function ltn (num) {
	    return this.cmpn(num) === -1;
	  };

	  BN.prototype.lt = function lt (num) {
	    return this.cmp(num) === -1;
	  };

	  BN.prototype.lten = function lten (num) {
	    return this.cmpn(num) <= 0;
	  };

	  BN.prototype.lte = function lte (num) {
	    return this.cmp(num) <= 0;
	  };

	  BN.prototype.eqn = function eqn (num) {
	    return this.cmpn(num) === 0;
	  };

	  BN.prototype.eq = function eq (num) {
	    return this.cmp(num) === 0;
	  };

	  //
	  // A reduce context, could be using montgomery or something better, depending
	  // on the `m` itself.
	  //
	  BN.red = function red (num) {
	    return new Red(num);
	  };

	  BN.prototype.toRed = function toRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    assert(this.negative === 0, 'red works only with positives');
	    return ctx.convertTo(this)._forceRed(ctx);
	  };

	  BN.prototype.fromRed = function fromRed () {
	    assert(this.red, 'fromRed works only with numbers in reduction context');
	    return this.red.convertFrom(this);
	  };

	  BN.prototype._forceRed = function _forceRed (ctx) {
	    this.red = ctx;
	    return this;
	  };

	  BN.prototype.forceRed = function forceRed (ctx) {
	    assert(!this.red, 'Already a number in reduction context');
	    return this._forceRed(ctx);
	  };

	  BN.prototype.redAdd = function redAdd (num) {
	    assert(this.red, 'redAdd works only with red numbers');
	    return this.red.add(this, num);
	  };

	  BN.prototype.redIAdd = function redIAdd (num) {
	    assert(this.red, 'redIAdd works only with red numbers');
	    return this.red.iadd(this, num);
	  };

	  BN.prototype.redSub = function redSub (num) {
	    assert(this.red, 'redSub works only with red numbers');
	    return this.red.sub(this, num);
	  };

	  BN.prototype.redISub = function redISub (num) {
	    assert(this.red, 'redISub works only with red numbers');
	    return this.red.isub(this, num);
	  };

	  BN.prototype.redShl = function redShl (num) {
	    assert(this.red, 'redShl works only with red numbers');
	    return this.red.shl(this, num);
	  };

	  BN.prototype.redMul = function redMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.mul(this, num);
	  };

	  BN.prototype.redIMul = function redIMul (num) {
	    assert(this.red, 'redMul works only with red numbers');
	    this.red._verify2(this, num);
	    return this.red.imul(this, num);
	  };

	  BN.prototype.redSqr = function redSqr () {
	    assert(this.red, 'redSqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqr(this);
	  };

	  BN.prototype.redISqr = function redISqr () {
	    assert(this.red, 'redISqr works only with red numbers');
	    this.red._verify1(this);
	    return this.red.isqr(this);
	  };

	  // Square root over p
	  BN.prototype.redSqrt = function redSqrt () {
	    assert(this.red, 'redSqrt works only with red numbers');
	    this.red._verify1(this);
	    return this.red.sqrt(this);
	  };

	  BN.prototype.redInvm = function redInvm () {
	    assert(this.red, 'redInvm works only with red numbers');
	    this.red._verify1(this);
	    return this.red.invm(this);
	  };

	  // Return negative clone of `this` % `red modulo`
	  BN.prototype.redNeg = function redNeg () {
	    assert(this.red, 'redNeg works only with red numbers');
	    this.red._verify1(this);
	    return this.red.neg(this);
	  };

	  BN.prototype.redPow = function redPow (num) {
	    assert(this.red && !num.red, 'redPow(normalNum)');
	    this.red._verify1(this);
	    return this.red.pow(this, num);
	  };

	  // Prime numbers with efficient reduction
	  var primes = {
	    k256: null,
	    p224: null,
	    p192: null,
	    p25519: null
	  };

	  // Pseudo-Mersenne prime
	  function MPrime (name, p) {
	    // P = 2 ^ N - K
	    this.name = name;
	    this.p = new BN(p, 16);
	    this.n = this.p.bitLength();
	    this.k = new BN(1).iushln(this.n).isub(this.p);

	    this.tmp = this._tmp();
	  }

	  MPrime.prototype._tmp = function _tmp () {
	    var tmp = new BN(null);
	    tmp.words = new Array(Math.ceil(this.n / 13));
	    return tmp;
	  };

	  MPrime.prototype.ireduce = function ireduce (num) {
	    // Assumes that `num` is less than `P^2`
	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
	    var r = num;
	    var rlen;

	    do {
	      this.split(r, this.tmp);
	      r = this.imulK(r);
	      r = r.iadd(this.tmp);
	      rlen = r.bitLength();
	    } while (rlen > this.n);

	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
	    if (cmp === 0) {
	      r.words[0] = 0;
	      r.length = 1;
	    } else if (cmp > 0) {
	      r.isub(this.p);
	    } else {
	      r.strip();
	    }

	    return r;
	  };

	  MPrime.prototype.split = function split (input, out) {
	    input.iushrn(this.n, 0, out);
	  };

	  MPrime.prototype.imulK = function imulK (num) {
	    return num.imul(this.k);
	  };

	  function K256 () {
	    MPrime.call(
	      this,
	      'k256',
	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
	  }
	  inherits(K256, MPrime);

	  K256.prototype.split = function split (input, output) {
	    // 256 = 9 * 26 + 22
	    var mask = 0x3fffff;

	    var outLen = Math.min(input.length, 9);
	    for (var i = 0; i < outLen; i++) {
	      output.words[i] = input.words[i];
	    }
	    output.length = outLen;

	    if (input.length <= 9) {
	      input.words[0] = 0;
	      input.length = 1;
	      return;
	    }

	    // Shift by 9 limbs
	    var prev = input.words[9];
	    output.words[output.length++] = prev & mask;

	    for (i = 10; i < input.length; i++) {
	      var next = input.words[i] | 0;
	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
	      prev = next;
	    }
	    prev >>>= 22;
	    input.words[i - 10] = prev;
	    if (prev === 0 && input.length > 10) {
	      input.length -= 10;
	    } else {
	      input.length -= 9;
	    }
	  };

	  K256.prototype.imulK = function imulK (num) {
	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
	    num.words[num.length] = 0;
	    num.words[num.length + 1] = 0;
	    num.length += 2;

	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
	    var lo = 0;
	    for (var i = 0; i < num.length; i++) {
	      var w = num.words[i] | 0;
	      lo += w * 0x3d1;
	      num.words[i] = lo & 0x3ffffff;
	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
	    }

	    // Fast length reduction
	    if (num.words[num.length - 1] === 0) {
	      num.length--;
	      if (num.words[num.length - 1] === 0) {
	        num.length--;
	      }
	    }
	    return num;
	  };

	  function P224 () {
	    MPrime.call(
	      this,
	      'p224',
	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
	  }
	  inherits(P224, MPrime);

	  function P192 () {
	    MPrime.call(
	      this,
	      'p192',
	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
	  }
	  inherits(P192, MPrime);

	  function P25519 () {
	    // 2 ^ 255 - 19
	    MPrime.call(
	      this,
	      '25519',
	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
	  }
	  inherits(P25519, MPrime);

	  P25519.prototype.imulK = function imulK (num) {
	    // K = 0x13
	    var carry = 0;
	    for (var i = 0; i < num.length; i++) {
	      var hi = (num.words[i] | 0) * 0x13 + carry;
	      var lo = hi & 0x3ffffff;
	      hi >>>= 26;

	      num.words[i] = lo;
	      carry = hi;
	    }
	    if (carry !== 0) {
	      num.words[num.length++] = carry;
	    }
	    return num;
	  };

	  // Exported mostly for testing purposes, use plain name instead
	  BN._prime = function prime (name) {
	    // Cached version of prime
	    if (primes[name]) return primes[name];

	    var prime;
	    if (name === 'k256') {
	      prime = new K256();
	    } else if (name === 'p224') {
	      prime = new P224();
	    } else if (name === 'p192') {
	      prime = new P192();
	    } else if (name === 'p25519') {
	      prime = new P25519();
	    } else {
	      throw new Error('Unknown prime ' + name);
	    }
	    primes[name] = prime;

	    return prime;
	  };

	  //
	  // Base reduction engine
	  //
	  function Red (m) {
	    if (typeof m === 'string') {
	      var prime = BN._prime(m);
	      this.m = prime.p;
	      this.prime = prime;
	    } else {
	      assert(m.gtn(1), 'modulus must be greater than 1');
	      this.m = m;
	      this.prime = null;
	    }
	  }

	  Red.prototype._verify1 = function _verify1 (a) {
	    assert(a.negative === 0, 'red works only with positives');
	    assert(a.red, 'red works only with red numbers');
	  };

	  Red.prototype._verify2 = function _verify2 (a, b) {
	    assert((a.negative | b.negative) === 0, 'red works only with positives');
	    assert(a.red && a.red === b.red,
	      'red works only with red numbers');
	  };

	  Red.prototype.imod = function imod (a) {
	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
	    return a.umod(this.m)._forceRed(this);
	  };

	  Red.prototype.neg = function neg (a) {
	    if (a.isZero()) {
	      return a.clone();
	    }

	    return this.m.sub(a)._forceRed(this);
	  };

	  Red.prototype.add = function add (a, b) {
	    this._verify2(a, b);

	    var res = a.add(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.iadd = function iadd (a, b) {
	    this._verify2(a, b);

	    var res = a.iadd(b);
	    if (res.cmp(this.m) >= 0) {
	      res.isub(this.m);
	    }
	    return res;
	  };

	  Red.prototype.sub = function sub (a, b) {
	    this._verify2(a, b);

	    var res = a.sub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res._forceRed(this);
	  };

	  Red.prototype.isub = function isub (a, b) {
	    this._verify2(a, b);

	    var res = a.isub(b);
	    if (res.cmpn(0) < 0) {
	      res.iadd(this.m);
	    }
	    return res;
	  };

	  Red.prototype.shl = function shl (a, num) {
	    this._verify1(a);
	    return this.imod(a.ushln(num));
	  };

	  Red.prototype.imul = function imul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.imul(b));
	  };

	  Red.prototype.mul = function mul (a, b) {
	    this._verify2(a, b);
	    return this.imod(a.mul(b));
	  };

	  Red.prototype.isqr = function isqr (a) {
	    return this.imul(a, a.clone());
	  };

	  Red.prototype.sqr = function sqr (a) {
	    return this.mul(a, a);
	  };

	  Red.prototype.sqrt = function sqrt (a) {
	    if (a.isZero()) return a.clone();

	    var mod3 = this.m.andln(3);
	    assert(mod3 % 2 === 1);

	    // Fast case
	    if (mod3 === 3) {
	      var pow = this.m.add(new BN(1)).iushrn(2);
	      return this.pow(a, pow);
	    }

	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
	    //
	    // Find Q and S, that Q * 2 ^ S = (P - 1)
	    var q = this.m.subn(1);
	    var s = 0;
	    while (!q.isZero() && q.andln(1) === 0) {
	      s++;
	      q.iushrn(1);
	    }
	    assert(!q.isZero());

	    var one = new BN(1).toRed(this);
	    var nOne = one.redNeg();

	    // Find quadratic non-residue
	    // NOTE: Max is such because of generalized Riemann hypothesis.
	    var lpow = this.m.subn(1).iushrn(1);
	    var z = this.m.bitLength();
	    z = new BN(2 * z * z).toRed(this);

	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
	      z.redIAdd(nOne);
	    }

	    var c = this.pow(z, q);
	    var r = this.pow(a, q.addn(1).iushrn(1));
	    var t = this.pow(a, q);
	    var m = s;
	    while (t.cmp(one) !== 0) {
	      var tmp = t;
	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
	        tmp = tmp.redSqr();
	      }
	      assert(i < m);
	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

	      r = r.redMul(b);
	      c = b.redSqr();
	      t = t.redMul(c);
	      m = i;
	    }

	    return r;
	  };

	  Red.prototype.invm = function invm (a) {
	    var inv = a._invmp(this.m);
	    if (inv.negative !== 0) {
	      inv.negative = 0;
	      return this.imod(inv).redNeg();
	    } else {
	      return this.imod(inv);
	    }
	  };

	  Red.prototype.pow = function pow (a, num) {
	    if (num.isZero()) return new BN(1);
	    if (num.cmpn(1) === 0) return a.clone();

	    var windowSize = 4;
	    var wnd = new Array(1 << windowSize);
	    wnd[0] = new BN(1).toRed(this);
	    wnd[1] = a;
	    for (var i = 2; i < wnd.length; i++) {
	      wnd[i] = this.mul(wnd[i - 1], a);
	    }

	    var res = wnd[0];
	    var current = 0;
	    var currentLen = 0;
	    var start = num.bitLength() % 26;
	    if (start === 0) {
	      start = 26;
	    }

	    for (i = num.length - 1; i >= 0; i--) {
	      var word = num.words[i];
	      for (var j = start - 1; j >= 0; j--) {
	        var bit = (word >> j) & 1;
	        if (res !== wnd[0]) {
	          res = this.sqr(res);
	        }

	        if (bit === 0 && current === 0) {
	          currentLen = 0;
	          continue;
	        }

	        current <<= 1;
	        current |= bit;
	        currentLen++;
	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

	        res = this.mul(res, wnd[current]);
	        currentLen = 0;
	        current = 0;
	      }
	      start = 26;
	    }

	    return res;
	  };

	  Red.prototype.convertTo = function convertTo (num) {
	    var r = num.umod(this.m);

	    return r === num ? r.clone() : r;
	  };

	  Red.prototype.convertFrom = function convertFrom (num) {
	    var res = num.clone();
	    res.red = null;
	    return res;
	  };

	  //
	  // Montgomery method engine
	  //

	  BN.mont = function mont (num) {
	    return new Mont(num);
	  };

	  function Mont (m) {
	    Red.call(this, m);

	    this.shift = this.m.bitLength();
	    if (this.shift % 26 !== 0) {
	      this.shift += 26 - (this.shift % 26);
	    }

	    this.r = new BN(1).iushln(this.shift);
	    this.r2 = this.imod(this.r.sqr());
	    this.rinv = this.r._invmp(this.m);

	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
	    this.minv = this.minv.umod(this.r);
	    this.minv = this.r.sub(this.minv);
	  }
	  inherits(Mont, Red);

	  Mont.prototype.convertTo = function convertTo (num) {
	    return this.imod(num.ushln(this.shift));
	  };

	  Mont.prototype.convertFrom = function convertFrom (num) {
	    var r = this.imod(num.mul(this.rinv));
	    r.red = null;
	    return r;
	  };

	  Mont.prototype.imul = function imul (a, b) {
	    if (a.isZero() || b.isZero()) {
	      a.words[0] = 0;
	      a.length = 1;
	      return a;
	    }

	    var t = a.imul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;

	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.mul = function mul (a, b) {
	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

	    var t = a.mul(b);
	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
	    var u = t.isub(c).iushrn(this.shift);
	    var res = u;
	    if (u.cmp(this.m) >= 0) {
	      res = u.isub(this.m);
	    } else if (u.cmpn(0) < 0) {
	      res = u.iadd(this.m);
	    }

	    return res._forceRed(this);
	  };

	  Mont.prototype.invm = function invm (a) {
	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
	    var res = this.imod(a._invmp(this.m).mul(this.r2));
	    return res._forceRed(this);
	  };
	})(typeof module === 'undefined' || module, this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 7 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var elliptic = exports;

	elliptic.version = __webpack_require__(281).version;
	elliptic.utils = __webpack_require__(255);
	elliptic.rand = __webpack_require__(230);
	elliptic.hmacDRBG = __webpack_require__(253);
	elliptic.curve = __webpack_require__(33);
	elliptic.curves = __webpack_require__(246);

	// Protocols
	elliptic.ec = __webpack_require__(247);
	elliptic.eddsa = __webpack_require__(250);


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var es5 = __webpack_require__(17);
	var Objectfreeze = es5.freeze;
	var util = __webpack_require__(2);
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var hash = exports;

	hash.utils = __webpack_require__(271);
	hash.common = __webpack_require__(267);
	hash.sha = __webpack_require__(270);
	hash.ripemd = __webpack_require__(269);
	hash.hmac = __webpack_require__(268);

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(47);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var Readable = __webpack_require__(103);
	var Writable = __webpack_require__(105);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	// Base class

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Post = function Post(type) {
	  _classCallCheck(this, Post);

	  this.type = type;
	};

	module.exports = Post;

/***/ },
/* 17 */
/***/ function(module, exports) {

	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var basex = __webpack_require__(196)
	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
	var base58 = basex(ALPHABET)

	module.exports = {
	  encode: base58.encode,
	  decode: base58.decode
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(6).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var fs = __webpack_require__(11);
	var format = __webpack_require__(4).format;

	var isNodejs = process.version ? true : false;

	var LogLevels = {
	  'DEBUG': 'DEBUG',
	  'INFO': 'INFO',
	  'WARN': 'WARN',
	  'ERROR': 'ERROR',
	  'NONE': 'NONE'
	};

	// Global log level
	var GlobalLogLevel = LogLevels.DEBUG;

	// Global log file name
	var GlobalLogfile = null;

	// ANSI colors
	var Colors = {
	  'Black': 0,
	  'Red': 1,
	  'Green': 2,
	  'Yellow': 3,
	  'Blue': 4,
	  'Magenta': 5,
	  'Cyan': 6,
	  'Grey': 7,
	  'White': 9,
	  'Default': 9
	};

	// CSS colors
	if (!isNodejs) {
	  Colors = {
	    'Black': 'Black',
	    'Red': 'IndianRed',
	    'Green': 'LimeGreen',
	    'Yellow': 'Orange',
	    'Blue': 'RoyalBlue',
	    'Magenta': 'Orchid',
	    'Cyan': 'SkyBlue',
	    'Grey': 'DimGrey',
	    'White': 'White',
	    'Default': 'Black'
	  };
	}

	var loglevelColors = [Colors.Cyan, Colors.Green, Colors.Yellow, Colors.Red, Colors.Default];

	var defaultOptions = {
	  useColors: true,
	  color: Colors.Default,
	  showTimestamp: true,
	  showLevel: true,
	  filename: GlobalLogfile,
	  appendFile: true
	};

	var Logger = function () {
	  function Logger(category, options) {
	    _classCallCheck(this, Logger);

	    this.category = category;
	    var opts = {};
	    Object.assign(opts, defaultOptions);
	    Object.assign(opts, options);
	    this.options = opts;
	  }

	  _createClass(Logger, [{
	    key: 'debug',
	    value: function debug() {
	      this._write(LogLevels.DEBUG, format.apply(null, arguments));
	    }
	  }, {
	    key: 'log',
	    value: function log() {
	      this.debug.apply(this, arguments);
	    }
	  }, {
	    key: 'info',
	    value: function info() {
	      this._write(LogLevels.INFO, format.apply(null, arguments));
	    }
	  }, {
	    key: 'warn',
	    value: function warn() {
	      this._write(LogLevels.WARN, format.apply(null, arguments));
	    }
	  }, {
	    key: 'error',
	    value: function error() {
	      this._write(LogLevels.ERROR, format.apply(null, arguments));
	    }
	  }, {
	    key: '_write',
	    value: function _write(level, text) {
	      if (!this._shouldLog(level)) return;

	      if ((this.options.filename || GlobalLogfile) && !this.fileWriter) this.fileWriter = fs.openSync(this.options.filename || GlobalLogfile, this.options.appendFile ? 'a+' : 'w+');

	      var format = this._format(level, text);
	      var unformattedText = this._createLogMessage(level, text);
	      var formattedText = this._createLogMessage(level, text, format.timestamp, format.level, format.category, format.text);

	      if (this.fileWriter) fs.writeSync(this.fileWriter, unformattedText + '\n', null, 'utf-8');

	      if (isNodejs) {
	        console.log(formattedText);
	      } else {
	        // TODO: clean this up
	        if (level === LogLevels.ERROR) {
	          if (this.options.showTimestamp && this.options.showLevel) {
	            console.error(formattedText, format.timestamp, format.level, format.category, format.text);
	          } else if (this.options.showTimestamp && !this.options.showLevel) {
	            console.error(formattedText, format.timestamp, format.category, format.text);
	          } else if (!this.options.showTimestamp && this.options.showLevel) {
	            console.error(formattedText, format.level, format.category, format.text);
	          } else {
	            console.error(formattedText, format.category, format.text);
	          }
	        } else {
	          if (this.options.showTimestamp && this.options.showLevel) {
	            console.log(formattedText, format.timestamp, format.level, format.category, format.text);
	          } else if (this.options.showTimestamp && !this.options.showLevel) {
	            console.log(formattedText, format.timestamp, format.category, format.text);
	          } else if (!this.options.showTimestamp && this.options.showLevel) {
	            console.log(formattedText, format.level, format.category, format.text);
	          } else {
	            console.log(formattedText, format.category, format.text);
	          }
	        }
	      }
	    }
	  }, {
	    key: '_format',
	    value: function _format(level, text) {
	      var timestampFormat = '';
	      var levelFormat = '';
	      var categoryFormat = '';
	      var textFormat = ': ';

	      if (this.options.useColors) {
	        var levelColor = Object.keys(LogLevels).map(function (f) {
	          return LogLevels[f];
	        }).indexOf(level);
	        var categoryColor = this.options.color;

	        if (isNodejs) {
	          if (this.options.showTimestamp) timestampFormat = '\u001b[3' + Colors.Grey + 'm';

	          if (this.options.showLevel) levelFormat = '\u001b[3' + loglevelColors[levelColor] + ';22m';

	          categoryFormat = '\u001b[3' + categoryColor + ';1m';
	          textFormat = '\u001b[0m: ';
	        } else {
	          if (this.options.showTimestamp) timestampFormat = 'color:' + Colors.Grey;

	          if (this.options.showLevel) levelFormat = 'color:' + loglevelColors[levelColor];

	          categoryFormat = 'color:' + categoryColor + '; font-weight: bold';
	        }
	      }

	      return {
	        timestamp: timestampFormat,
	        level: levelFormat,
	        category: categoryFormat,
	        text: textFormat
	      };
	    }
	  }, {
	    key: '_createLogMessage',
	    value: function _createLogMessage(level, text, timestampFormat, levelFormat, categoryFormat, textFormat) {
	      timestampFormat = timestampFormat || '';
	      levelFormat = levelFormat || '';
	      categoryFormat = categoryFormat || '';
	      textFormat = textFormat || ': ';

	      if (!isNodejs) {
	        if (this.options.showTimestamp) timestampFormat = '%c';

	        if (this.options.showLevel) levelFormat = '%c';

	        categoryFormat = '%c';
	        textFormat = ': %c';
	      }

	      var result = '';

	      if (this.options.showTimestamp) result += '' + new Date().toISOString() + ' ';

	      result = timestampFormat + result;

	      if (this.options.showLevel) result += levelFormat + '[' + level + ']' + (level === LogLevels.INFO || level === LogLevels.WARN ? ' ' : '') + ' ';

	      result += categoryFormat + this.category;
	      result += textFormat + text;
	      return result;
	    }
	  }, {
	    key: '_shouldLog',
	    value: function _shouldLog(level) {
	      var levels = Object.keys(LogLevels).map(function (f) {
	        return LogLevels[f];
	      });
	      var index = levels.indexOf(level);
	      var levelIdx = levels.indexOf(GlobalLogLevel);
	      return index >= levelIdx;
	    }
	  }]);

	  return Logger;
	}();

	;

	/* Public API */
	module.exports = {
	  Colors: Colors,
	  LogLevels: LogLevels,
	  setLogLevel: function setLogLevel(level) {
	    GlobalLogLevel = level;
	  },
	  setLogfile: function setLogfile(filename) {
	    GlobalLogfile = filename;
	  },
	  create: function create(category, options) {
	    var logger = new Logger(category, options);
	    return logger;
	  },
	  forceBrowserMode: function forceBrowserMode(force) {
	    return isNodejs = !force;
	  } };

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var base = exports;

	base.Reporter = __webpack_require__(117).Reporter;
	base.DecoderBuffer = __webpack_require__(59).DecoderBuffer;
	base.EncoderBuffer = __webpack_require__(59).EncoderBuffer;
	base.Node = __webpack_require__(116);


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Crypto = __webpack_require__(9);
	var Path = __webpack_require__(12);
	var Util = __webpack_require__(4);
	var Escape = __webpack_require__(125);

	// Declare internals

	var internals = {};

	// Clone object or array

	exports.clone = function (obj, seen) {

	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {

	        return obj;
	    }

	    seen = seen || new Map();

	    var lookup = seen.get(obj);
	    if (lookup) {
	        return lookup;
	    }

	    var newObj = void 0;
	    var cloneDeep = false;

	    if (!Array.isArray(obj)) {
	        if (Buffer.isBuffer(obj)) {
	            newObj = new Buffer(obj);
	        } else if (obj instanceof Date) {
	            newObj = new Date(obj.getTime());
	        } else if (obj instanceof RegExp) {
	            newObj = new RegExp(obj);
	        } else {
	            var proto = Object.getPrototypeOf(obj);
	            if (proto && proto.isImmutable) {

	                newObj = obj;
	            } else {
	                newObj = Object.create(proto);
	                cloneDeep = true;
	            }
	        }
	    } else {
	        newObj = [];
	        cloneDeep = true;
	    }

	    seen.set(obj, newObj);

	    if (cloneDeep) {
	        var keys = Object.getOwnPropertyNames(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	            if (descriptor && (descriptor.get || descriptor.set)) {

	                Object.defineProperty(newObj, key, descriptor);
	            } else {
	                newObj[key] = exports.clone(obj[key], seen);
	            }
	        }
	    }

	    return newObj;
	};

	// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied

	/*eslint-disable */
	exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
	    /*eslint-enable */

	    exports.assert(target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object', 'Invalid target value: must be an object');
	    exports.assert(source === null || source === undefined || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object', 'Invalid source value: must be null, undefined, or an object');

	    if (!source) {
	        return target;
	    }

	    if (Array.isArray(source)) {
	        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
	        if (isMergeArrays === false) {
	            // isMergeArrays defaults to true
	            target.length = 0; // Must not change target assignment
	        }

	        for (var i = 0; i < source.length; ++i) {
	            target.push(exports.clone(source[i]));
	        }

	        return target;
	    }

	    var keys = Object.keys(source);
	    for (var _i = 0; _i < keys.length; ++_i) {
	        var key = keys[_i];
	        var value = source[key];
	        if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {

	            if (!target[key] || _typeof(target[key]) !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {

	                target[key] = exports.clone(value);
	            } else {
	                exports.merge(target[key], value, isNullOverride, isMergeArrays);
	            }
	        } else {
	            if (value !== null && value !== undefined) {
	                // Explicit to preserve empty strings

	                target[key] = value;
	            } else if (isNullOverride !== false) {
	                // Defaults to true
	                target[key] = value;
	            }
	        }
	    }

	    return target;
	};

	// Apply options to a copy of the defaults

	exports.applyToDefaults = function (defaults, options, isNullOverride) {

	    exports.assert(defaults && (typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options value: must be true, falsy or an object');

	    if (!options) {
	        // If no options, return null
	        return null;
	    }

	    var copy = exports.clone(defaults);

	    if (options === true) {
	        // If options is set to true, use defaults
	        return copy;
	    }

	    return exports.merge(copy, options, isNullOverride === true, false);
	};

	// Clone an object except for the listed keys which are shallow copied

	exports.cloneWithShallow = function (source, keys) {

	    if (!source || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {

	        return source;
	    }

	    var storage = internals.store(source, keys); // Move shallow copy items to storage
	    var copy = exports.clone(source); // Deep copy the rest
	    internals.restore(copy, source, storage); // Shallow copy the stored items and restore
	    return copy;
	};

	internals.store = function (source, keys) {

	    var storage = {};
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = exports.reach(source, key);
	        if (value !== undefined) {
	            storage[key] = value;
	            internals.reachSet(source, key, undefined);
	        }
	    }

	    return storage;
	};

	internals.restore = function (copy, source, storage) {

	    var keys = Object.keys(storage);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        internals.reachSet(copy, key, storage[key]);
	        internals.reachSet(source, key, storage[key]);
	    }
	};

	internals.reachSet = function (obj, key, value) {

	    var path = key.split('.');
	    var ref = obj;
	    for (var i = 0; i < path.length; ++i) {
	        var segment = path[i];
	        if (i + 1 === path.length) {
	            ref[segment] = value;
	        }

	        ref = ref[segment];
	    }
	};

	// Apply options to defaults except for the listed keys which are shallow copied from option without merging

	exports.applyToDefaultsWithShallow = function (defaults, options, keys) {

	    exports.assert(defaults && (typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object', 'Invalid options value: must be true, falsy or an object');
	    exports.assert(keys && Array.isArray(keys), 'Invalid keys');

	    if (!options) {
	        // If no options, return null
	        return null;
	    }

	    var copy = exports.cloneWithShallow(defaults, keys);

	    if (options === true) {
	        // If options is set to true, use defaults
	        return copy;
	    }

	    var storage = internals.store(options, keys); // Move shallow copy items to storage
	    exports.merge(copy, options, false, false); // Deep copy the rest
	    internals.restore(copy, options, storage); // Shallow copy the stored items and restore
	    return copy;
	};

	// Deep object or array comparison

	exports.deepEqual = function (obj, ref, options, seen) {

	    options = options || { prototype: true };

	    var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);

	    if (type !== (typeof ref === 'undefined' ? 'undefined' : _typeof(ref))) {
	        return false;
	    }

	    if (type !== 'object' || obj === null || ref === null) {

	        if (obj === ref) {
	            // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
	            return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0
	        }

	        return obj !== obj && ref !== ref; // NaN
	    }

	    seen = seen || [];
	    if (seen.indexOf(obj) !== -1) {
	        return true; // If previous comparison failed, it would have stopped execution
	    }

	    seen.push(obj);

	    if (Array.isArray(obj)) {
	        if (!Array.isArray(ref)) {
	            return false;
	        }

	        if (!options.part && obj.length !== ref.length) {
	            return false;
	        }

	        for (var i = 0; i < obj.length; ++i) {
	            if (options.part) {
	                var found = false;
	                for (var j = 0; j < ref.length; ++j) {
	                    if (exports.deepEqual(obj[i], ref[j], options)) {
	                        found = true;
	                        break;
	                    }
	                }

	                return found;
	            }

	            if (!exports.deepEqual(obj[i], ref[i], options)) {
	                return false;
	            }
	        }

	        return true;
	    }

	    if (Buffer.isBuffer(obj)) {
	        if (!Buffer.isBuffer(ref)) {
	            return false;
	        }

	        if (obj.length !== ref.length) {
	            return false;
	        }

	        for (var _i2 = 0; _i2 < obj.length; ++_i2) {
	            if (obj[_i2] !== ref[_i2]) {
	                return false;
	            }
	        }

	        return true;
	    }

	    if (obj instanceof Date) {
	        return ref instanceof Date && obj.getTime() === ref.getTime();
	    }

	    if (obj instanceof RegExp) {
	        return ref instanceof RegExp && obj.toString() === ref.toString();
	    }

	    if (options.prototype) {
	        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
	            return false;
	        }
	    }

	    var keys = Object.getOwnPropertyNames(obj);

	    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
	        return false;
	    }

	    for (var _i3 = 0; _i3 < keys.length; ++_i3) {
	        var key = keys[_i3];
	        var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	        if (descriptor.get) {
	            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
	                return false;
	            }
	        } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
	            return false;
	        }
	    }

	    return true;
	};

	// Remove duplicate items from array

	exports.unique = function (array, key) {

	    var result = void 0;
	    if (key) {
	        (function () {
	            result = [];
	            var index = new Set();
	            array.forEach(function (item) {

	                var identifier = item[key];
	                if (!index.has(identifier)) {
	                    index.add(identifier);
	                    result.push(item);
	                }
	            });
	        })();
	    } else {
	        result = Array.from(new Set(array));
	    }

	    return result;
	};

	// Convert array into object

	exports.mapToObject = function (array, key) {

	    if (!array) {
	        return null;
	    }

	    var obj = {};
	    for (var i = 0; i < array.length; ++i) {
	        if (key) {
	            if (array[i][key]) {
	                obj[array[i][key]] = true;
	            }
	        } else {
	            obj[array[i]] = true;
	        }
	    }

	    return obj;
	};

	// Find the common unique items in two arrays

	exports.intersect = function (array1, array2, justFirst) {

	    if (!array1 || !array2) {
	        return [];
	    }

	    var common = [];
	    var hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;
	    var found = {};
	    for (var i = 0; i < array2.length; ++i) {
	        if (hash[array2[i]] && !found[array2[i]]) {
	            if (justFirst) {
	                return array2[i];
	            }

	            common.push(array2[i]);
	            found[array2[i]] = true;
	        }
	    }

	    return justFirst ? null : common;
	};

	// Test if the reference contains the values

	exports.contain = function (ref, values, options) {

	    /*
	        string -> string(s)
	        array -> item(s)
	        object -> key(s)
	        object -> object (key:value)
	    */

	    var valuePairs = null;
	    if ((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {

	        valuePairs = values;
	        values = Object.keys(values);
	    } else {
	        values = [].concat(values);
	    }

	    options = options || {}; // deep, once, only, part

	    exports.assert(arguments.length >= 2, 'Insufficient arguments');
	    exports.assert(typeof ref === 'string' || (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object', 'Reference must be string or an object');
	    exports.assert(values.length, 'Values array cannot be empty');

	    var compare = void 0;
	    var compareFlags = void 0;
	    if (options.deep) {
	        compare = exports.deepEqual;

	        var hasOnly = options.hasOwnProperty('only');
	        var hasPart = options.hasOwnProperty('part');

	        compareFlags = {
	            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
	            part: hasOnly ? !options.only : hasPart ? options.part : true
	        };
	    } else {
	        compare = function compare(a, b) {
	            return a === b;
	        };
	    }

	    var misses = false;
	    var matches = new Array(values.length);
	    for (var i = 0; i < matches.length; ++i) {
	        matches[i] = 0;
	    }

	    if (typeof ref === 'string') {
	        var pattern = '(';
	        for (var _i4 = 0; _i4 < values.length; ++_i4) {
	            var value = values[_i4];
	            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
	            pattern += (_i4 ? '|' : '') + exports.escapeRegex(value);
	        }

	        var regex = new RegExp(pattern + ')', 'g');
	        var leftovers = ref.replace(regex, function ($0, $1) {

	            var index = values.indexOf($1);
	            ++matches[index];
	            return ''; // Remove from string
	        });

	        misses = !!leftovers;
	    } else if (Array.isArray(ref)) {
	        for (var _i5 = 0; _i5 < ref.length; ++_i5) {
	            var matched = false;
	            for (var j = 0; j < values.length && matched === false; ++j) {
	                matched = compare(values[j], ref[_i5], compareFlags) && j;
	            }

	            if (matched !== false) {
	                ++matches[matched];
	            } else {
	                misses = true;
	            }
	        }
	    } else {
	        var keys = Object.keys(ref);
	        for (var _i6 = 0; _i6 < keys.length; ++_i6) {
	            var key = keys[_i6];
	            var pos = values.indexOf(key);
	            if (pos !== -1) {
	                if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {

	                    return false;
	                }

	                ++matches[pos];
	            } else {
	                misses = true;
	            }
	        }
	    }

	    var result = false;
	    for (var _i7 = 0; _i7 < matches.length; ++_i7) {
	        result = result || !!matches[_i7];
	        if (options.once && matches[_i7] > 1 || !options.part && !matches[_i7]) {

	            return false;
	        }
	    }

	    if (options.only && misses) {

	        return false;
	    }

	    return result;
	};

	// Flatten array

	exports.flatten = function (array, target) {

	    var result = target || [];

	    for (var i = 0; i < array.length; ++i) {
	        if (Array.isArray(array[i])) {
	            exports.flatten(array[i], result);
	        } else {
	            result.push(array[i]);
	        }
	    }

	    return result;
	};

	// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

	exports.reach = function (obj, chain, options) {

	    if (chain === false || chain === null || typeof chain === 'undefined') {

	        return obj;
	    }

	    options = options || {};
	    if (typeof options === 'string') {
	        options = { separator: options };
	    }

	    var path = chain.split(options.separator || '.');
	    var ref = obj;
	    for (var i = 0; i < path.length; ++i) {
	        var key = path[i];
	        if (key[0] === '-' && Array.isArray(ref)) {
	            key = key.slice(1, key.length);
	            key = ref.length - key;
	        }

	        if (!ref || !(((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' || typeof ref === 'function') && key in ref) || (typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) !== 'object' && options.functions === false) {
	            // Only object and function can have properties

	            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
	            exports.assert((typeof ref === 'undefined' ? 'undefined' : _typeof(ref)) === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
	            ref = options.default;
	            break;
	        }

	        ref = ref[key];
	    }

	    return ref;
	};

	exports.reachTemplate = function (obj, template, options) {

	    return template.replace(/{([^}]+)}/g, function ($0, chain) {

	        var value = exports.reach(obj, chain, options);
	        return value === undefined || value === null ? '' : value;
	    });
	};

	exports.formatStack = function (stack) {

	    var trace = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var item = stack[i];
	        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
	    }

	    return trace;
	};

	exports.formatTrace = function (trace) {

	    var display = [];

	    for (var i = 0; i < trace.length; ++i) {
	        var row = trace[i];
	        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
	    }

	    return display;
	};

	exports.callStack = function (slice) {

	    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

	    var v8 = Error.prepareStackTrace;
	    Error.prepareStackTrace = function (_, stack) {

	        return stack;
	    };

	    var capture = {};
	    Error.captureStackTrace(capture, this); // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result
	    var stack = capture.stack;

	    Error.prepareStackTrace = v8;

	    var trace = exports.formatStack(stack);

	    return trace.slice(1 + slice);
	};

	exports.displayStack = function (slice) {

	    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

	    return exports.formatTrace(trace);
	};

	exports.abortThrow = false;

	exports.abort = function (message, hideStack) {

	    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
	        throw new Error(message || 'Unknown error');
	    }

	    var stack = '';
	    if (!hideStack) {
	        stack = exports.displayStack(1).join('\n\t');
	    }
	    console.log('ABORT: ' + message + '\n\t' + stack);
	    process.exit(1);
	};

	exports.assert = function (condition /*, msg1, msg2, msg3 */) {

	    if (condition) {
	        return;
	    }

	    if (arguments.length === 2 && arguments[1] instanceof Error) {
	        throw arguments[1];
	    }

	    var msgs = [];
	    for (var i = 1; i < arguments.length; ++i) {
	        if (arguments[i] !== '') {
	            msgs.push(arguments[i]); // Avoids Array.slice arguments leak, allowing for V8 optimizations
	        }
	    }

	    msgs = msgs.map(function (msg) {

	        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
	    });

	    throw new Error(msgs.join(' ') || 'Unknown error');
	};

	exports.Timer = function () {

	    this.ts = 0;
	    this.reset();
	};

	exports.Timer.prototype.reset = function () {

	    this.ts = Date.now();
	};

	exports.Timer.prototype.elapsed = function () {

	    return Date.now() - this.ts;
	};

	exports.Bench = function () {

	    this.ts = 0;
	    this.reset();
	};

	exports.Bench.prototype.reset = function () {

	    this.ts = exports.Bench.now();
	};

	exports.Bench.prototype.elapsed = function () {

	    return exports.Bench.now() - this.ts;
	};

	exports.Bench.now = function () {

	    var ts = process.hrtime();
	    return ts[0] * 1e3 + ts[1] / 1e6;
	};

	// Escape string for Regex construction

	exports.escapeRegex = function (string) {

	    // Escape ^$.*+-?=!:|\/()[]{},
	    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
	};

	// Base64url (RFC 4648) encode

	exports.base64urlEncode = function (value, encoding) {

	    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');
	    var buf = Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary');
	    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
	};

	// Base64url (RFC 4648) decode

	exports.base64urlDecode = function (value, encoding) {

	    if (typeof value !== 'string') {

	        return new Error('Value not a string');
	    }

	    if (!/^[\w\-]*$/.test(value)) {

	        return new Error('Invalid character');
	    }

	    var buf = new Buffer(value, 'base64');
	    return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');
	};

	// Escape attribute value for use in HTTP header

	exports.escapeHeaderAttribute = function (attribute) {

	    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

	    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

	    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"'); // Escape quotes and slash
	};

	exports.escapeHtml = function (string) {

	    return Escape.escapeHtml(string);
	};

	exports.escapeJavaScript = function (string) {

	    return Escape.escapeJavaScript(string);
	};

	exports.nextTick = function (callback) {

	    return function () {

	        var args = arguments;
	        process.nextTick(function () {

	            callback.apply(null, args);
	        });
	    };
	};

	exports.once = function (method) {

	    if (method._hoekOnce) {
	        return method;
	    }

	    var once = false;
	    var wrapped = function wrapped() {

	        if (!once) {
	            once = true;
	            method.apply(null, arguments);
	        }
	    };

	    wrapped._hoekOnce = true;

	    return wrapped;
	};

	exports.isInteger = function (value) {

	    return typeof value === 'number' && parseFloat(value) === parseInt(value, 10) && !isNaN(value);
	};

	exports.ignore = function () {};

	exports.inherits = Util.inherits;

	exports.format = Util.format;

	exports.transform = function (source, transform, options) {

	    exports.assert(source === null || source === undefined || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');
	    var separator = (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options !== null ? options.separator || '.' : '.';

	    if (Array.isArray(source)) {
	        var results = [];
	        for (var i = 0; i < source.length; ++i) {
	            results.push(exports.transform(source[i], transform, options));
	        }
	        return results;
	    }

	    var result = {};
	    var keys = Object.keys(transform);

	    for (var _i8 = 0; _i8 < keys.length; ++_i8) {
	        var key = keys[_i8];
	        var path = key.split(separator);
	        var sourcePath = transform[key];

	        exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');

	        var segment = void 0;
	        var res = result;

	        while (path.length > 1) {
	            segment = path.shift();
	            if (!res[segment]) {
	                res[segment] = {};
	            }
	            res = res[segment];
	        }
	        segment = path.shift();
	        res[segment] = exports.reach(source, sourcePath, options);
	    }

	    return result;
	};

	exports.uniqueFilename = function (path, extension) {

	    if (extension) {
	        extension = extension[0] !== '.' ? '.' + extension : extension;
	    } else {
	        extension = '';
	    }

	    path = Path.resolve(path);
	    var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
	    return Path.join(path, name);
	};

	exports.stringify = function () {

	    try {
	        return JSON.stringify.apply(null, arguments);
	    } catch (err) {
	        return '[Cannot display object: ' + err.message + ']';
	    }
	};

	exports.shallow = function (source) {

	    var target = {};
	    var keys = Object.keys(source);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        target[key] = source[key];
	    }

	    return target;
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(302),
	    isLength = __webpack_require__(303);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var bs58 = __webpack_require__(18);

	var cs = __webpack_require__(313);

	exports.toHexString = function toHexString(m) {
	  if (!Buffer.isBuffer(m)) {
	    throw new Error('must be passed a buffer');
	  }

	  return m.toString('hex');
	};

	exports.fromHexString = function fromHexString(s) {
	  return new Buffer(s, 'hex');
	};

	exports.toB58String = function toB58String(m) {
	  if (!Buffer.isBuffer(m)) {
	    throw new Error('must be passed a buffer');
	  }

	  return bs58.encode(m);
	};

	exports.fromB58String = function fromB58String(s) {
	  var encoded = s;
	  if (Buffer.isBuffer(s)) {
	    encoded = s.toString();
	  }

	  return new Buffer(bs58.decode(encoded));
	};

	// Decode a hash from the given Multihash.
	exports.decode = function decode(buf) {
	  exports.validate(buf);

	  var code = buf[0];

	  return {
	    code: code,
	    name: cs.codes[code],
	    length: buf[1],
	    digest: buf.slice(2)
	  };
	};

	// Encode a hash digest along with the specified function code.
	// Note: the length is derived from the length of the digest itself.
	exports.encode = function encode(digest, code, length) {
	  if (!digest || !code) {
	    throw new Error('multihash encode requires at least two args: digest, code');
	  }

	  // ensure it's a hashfunction code.
	  var hashfn = exports.coerceCode(code);

	  if (!Buffer.isBuffer(digest)) {
	    throw new Error('digest should be a Buffer');
	  }

	  if (length == null) {
	    length = digest.length;
	  }

	  if (length && digest.length !== length) {
	    throw new Error('digest length should be equal to specified length.');
	  }

	  if (length > 127) {
	    throw new Error('multihash does not yet support digest lengths greater than 127 bytes.');
	  }

	  return Buffer.concat([new Buffer([hashfn, length]), digest]);
	};

	// Converts a hashfn name into the matching code
	exports.coerceCode = function coerceCode(name) {
	  var code = name;

	  if (typeof name === 'string') {
	    if (!cs.names[name]) {
	      throw new Error('Unrecognized hash function named: ' + name);
	    }
	    code = cs.names[name];
	  }

	  if (typeof code !== 'number') {
	    throw new Error('Hash function code should be a number. Got: ' + code);
	  }

	  if (!cs.codes[code] && !exports.isAppCode(code)) {
	    throw new Error('Unrecognized function code: ' + code);
	  }

	  return code;
	};

	// Checks wether a code is part of the app range
	exports.isAppCode = function appCode(code) {
	  return code > 0 && code < 0x10;
	};

	// Checks whether a multihash code is valid.
	exports.isValidCode = function validCode(code) {
	  if (exports.isAppCode(code)) {
	    return true;
	  }

	  if (cs.codes[code]) {
	    return true;
	  }

	  return false;
	};

	exports.validate = function validate(multihash) {
	  if (!Buffer.isBuffer(multihash)) {
	    throw new Error('multihash must be a Buffer');
	  }

	  if (multihash.length < 3) {
	    throw new Error('multihash too short. must be > 3 bytes.');
	  }

	  if (multihash.length > 129) {
	    throw new Error('multihash too long. must be < 129 bytes.');
	  }

	  var code = multihash[0];

	  if (!exports.isValidCode(code)) {
	    throw new Error('multihash unknown function code: 0x' + code.toString(16));
	  }

	  if (multihash.slice(2).length !== multihash[1]) {
	    throw new Error('multihash length inconsistent: 0x' + multihash.toString('hex'));
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	'use strict'

	module.exports = function drain (op, done) {
	  var read, abort

	  function sink (_read) {
	    read = _read
	    if(abort) return sink.abort()
	    //this function is much simpler to write if you
	    //just use recursion, but by using a while loop
	    //we do not blow the stack if the stream happens to be sync.
	    ;(function next() {
	        var loop = true, cbed = false
	        while(loop) {
	          cbed = false
	          read(null, function (end, data) {
	            cbed = true
	            if(end = end || abort) {
	              loop = false
	              if(done) done(end === true ? null : end)
	              else if(end && end !== true)
	                throw end
	            }
	            else if(op && false === op(data) || abort) {
	              loop = false
	              read(abort || true, done || function () {})
	            }
	            else if(!loop){
	              next()
	            }
	          })
	          if(!cbed) {
	            loop = false
	            return
	          }
	        }
	      })()
	  }

	  sink.abort = function (err, cb) {
	    if('function' == typeof err)
	      cb = err, err = true
	    abort = err || true
	    if(read) return read(abort, cb || function () {})
	  }

	  return sink
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function prop (key) {
	  return key && (
	    'string' == typeof key
	    ? function (data) { return data[key] }
	    : 'object' === typeof key && 'function' === typeof key.exec //regexp
	    ? function (data) { var v = key.exec(data); return v && v[0] }
	    : key
	  )
	}


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = (function (){
	  try {
	    return __webpack_require__(3); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(103);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(105);
	exports.Duplex = __webpack_require__(15);
	exports.Transform = __webpack_require__(104);
	exports.PassThrough = __webpack_require__(358);


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    encode: __webpack_require__(382)
	  , decode: __webpack_require__(381)
	  , encodingLength: __webpack_require__(383)
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var asn1 = exports;

	asn1.bignum = __webpack_require__(5);

	asn1.define = __webpack_require__(115).define;
	asn1.base = __webpack_require__(21);
	asn1.constants = __webpack_require__(60);
	asn1.decoders = __webpack_require__(119);
	asn1.encoders = __webpack_require__(121);


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var isStream = __webpack_require__(279);
	var addToDagNodesTransform = __webpack_require__(37);
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (files, callback) {
	    var good = Buffer.isBuffer(files) || isStream.isReadable(files) || Array.isArray(files);

	    if (!good) {
	      callback(new Error('"files" must be a buffer, readable stream, or array of objects'));
	    }

	    var sendWithTransform = send.withTransform(addToDagNodesTransform);

	    return sendWithTransform({
	      path: 'add',
	      files: files
	    }, callback);
	  });
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var DuplexStream = __webpack_require__(357)
	  , util         = __webpack_require__(4)


	function BufferList (callback) {
	  if (!(this instanceof BufferList))
	    return new BufferList(callback)

	  this._bufs  = []
	  this.length = 0

	  if (typeof callback == 'function') {
	    this._callback = callback

	    var piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err)
	        this._callback = null
	      }
	    }.bind(this)

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper)
	    })
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper)
	    })
	  } else {
	    this.append(callback)
	  }

	  DuplexStream.call(this)
	}


	util.inherits(BufferList, DuplexStream)


	BufferList.prototype._offset = function _offset (offset) {
	  var tot = 0, i = 0, _t
	  for (; i < this._bufs.length; i++) {
	    _t = tot + this._bufs[i].length
	    if (offset < _t)
	      return [ i, offset - tot ]
	    tot = _t
	  }
	}


	BufferList.prototype.append = function append (buf) {
	  var i = 0
	    , newBuf

	  if (Array.isArray(buf)) {
	    for (; i < buf.length; i++)
	      this.append(buf[i])
	  } else if (buf instanceof BufferList) {
	    // unwrap argument into individual BufferLists
	    for (; i < buf._bufs.length; i++)
	      this.append(buf._bufs[i])
	  } else if (buf != null) {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf == 'number')
	      buf = buf.toString()

	    newBuf = Buffer.isBuffer(buf) ? buf : new Buffer(buf)
	    this._bufs.push(newBuf)
	    this.length += newBuf.length
	  }

	  return this
	}


	BufferList.prototype._write = function _write (buf, encoding, callback) {
	  this.append(buf)

	  if (typeof callback == 'function')
	    callback()
	}


	BufferList.prototype._read = function _read (size) {
	  if (!this.length)
	    return this.push(null)

	  size = Math.min(size, this.length)
	  this.push(this.slice(0, size))
	  this.consume(size)
	}


	BufferList.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk)

	  if (this._callback) {
	    this._callback(null, this.slice())
	    this._callback = null
	  }
	}


	BufferList.prototype.get = function get (index) {
	  return this.slice(index, index + 1)[0]
	}


	BufferList.prototype.slice = function slice (start, end) {
	  return this.copy(null, 0, start, end)
	}


	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart != 'number' || srcStart < 0)
	    srcStart = 0
	  if (typeof srcEnd != 'number' || srcEnd > this.length)
	    srcEnd = this.length
	  if (srcStart >= this.length)
	    return dst || new Buffer(0)
	  if (srcEnd <= 0)
	    return dst || new Buffer(0)

	  var copy   = !!dst
	    , off    = this._offset(srcStart)
	    , len    = srcEnd - srcStart
	    , bytes  = len
	    , bufoff = (copy && dstStart) || 0
	    , start  = off[1]
	    , l
	    , i

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd == this.length) {
	    if (!copy) // slice, just return a full concat
	      return Buffer.concat(this._bufs)

	    // copy, need to copy individual buffers
	    for (i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff)
	      bufoff += this._bufs[i].length
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) // a slice, we need something to copy in to
	    dst = new Buffer(len)

	  for (i = off[0]; i < this._bufs.length; i++) {
	    l = this._bufs[i].length - start

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start)
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes)
	      break
	    }

	    bufoff += l
	    bytes -= l

	    if (start)
	      start = 0
	  }

	  return dst
	}

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	}

	BufferList.prototype.consume = function consume (bytes) {
	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length
	      this.length -= this._bufs[0].length
	      this._bufs.shift()
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes)
	      this.length -= bytes
	      break
	    }
	  }
	  return this
	}


	BufferList.prototype.duplicate = function duplicate () {
	  var i = 0
	    , copy = new BufferList()

	  for (; i < this._bufs.length; i++)
	    copy.append(this._bufs[i])

	  return copy
	}


	BufferList.prototype.destroy = function destroy () {
	  this._bufs.length = 0
	  this.length = 0
	  this.push(null)
	}


	;(function () {
	  var methods = {
	      'readDoubleBE' : 8
	    , 'readDoubleLE' : 8
	    , 'readFloatBE'  : 4
	    , 'readFloatLE'  : 4
	    , 'readInt32BE'  : 4
	    , 'readInt32LE'  : 4
	    , 'readUInt32BE' : 4
	    , 'readUInt32LE' : 4
	    , 'readInt16BE'  : 2
	    , 'readInt16LE'  : 2
	    , 'readUInt16BE' : 2
	    , 'readUInt16LE' : 2
	    , 'readInt8'     : 1
	    , 'readUInt8'    : 1
	  }

	  for (var m in methods) {
	    (function (m) {
	      BufferList.prototype[m] = function (offset) {
	        return this.slice(offset, offset + methods[m])[m](0)
	      }
	    }(m))
	  }
	}())


	module.exports = BufferList


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9).createHash;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var curve = exports;

	curve.base = __webpack_require__(242);
	curve.short = __webpack_require__(245);
	curve.mont = __webpack_require__(244);
	curve.edwards = __webpack_require__(243);


/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EC = __webpack_require__(8).ec;
	var ec = new EC('secp256k1');

	var keystore = void 0;

	if (typeof localStorage === "undefined" || localStorage === null) {
	  var LocalStorage = __webpack_require__(321).LocalStorage;
	  keystore = new LocalStorage('./');
	} else {
	  keystore = localStorage;
	}

	var OrbitCrypto = function () {
	  function OrbitCrypto() {
	    _classCallCheck(this, OrbitCrypto);
	  }

	  _createClass(OrbitCrypto, null, [{
	    key: 'useKeyStore',
	    value: function useKeyStore() {
	      var directory = arguments.length <= 0 || arguments[0] === undefined ? './' : arguments[0];

	      if (typeof localStorage === "undefined" || localStorage === null) {
	        keystore = new LocalStorage(directory);
	      }
	    }
	  }, {
	    key: 'importKeyFromIpfs',
	    value: function importKeyFromIpfs(ipfs, hash) {
	      return ipfs.object.get(hash, { enc: 'base58' }).then(function (obj) {
	        return JSON.parse(obj.toJSON().Data);
	      }).then(function (key) {
	        return OrbitCrypto.importPublicKey(key);
	      });
	    }
	  }, {
	    key: 'exportKeyToIpfs',
	    value: function exportKeyToIpfs(ipfs, key) {
	      return OrbitCrypto.exportPublicKey(key).then(function (k) {
	        return JSON.stringify(k, null, 2);
	      }).then(function (s) {
	        return new Buffer(s);
	      }).then(function (buffer) {
	        return ipfs.object.put(buffer);
	      }).then(function (res) {
	        return res.toJSON().Hash;
	      });
	    }
	  }, {
	    key: 'getKey',
	    value: function getKey() {
	      var id = arguments.length <= 0 || arguments[0] === undefined ? 'default' : arguments[0];

	      var savedKeys = JSON.parse(keystore.getItem(id));
	      var key = void 0,
	          publicKey = void 0,
	          privateKey = void 0;

	      if (savedKeys) {
	        return OrbitCrypto.importPrivateKey(savedKeys.privateKey).then(function (privKey) {
	          return privateKey = privKey;
	        }).then(function () {
	          return OrbitCrypto.importPublicKey(savedKeys.publicKey);
	        }).then(function (pubKey) {
	          return publicKey = pubKey;
	        }).then(function () {
	          return { publicKey: publicKey, privateKey: privateKey };
	        });
	      }

	      return OrbitCrypto.generateKey().then(function (keyPair) {
	        return key = keyPair;
	      }).then(function () {
	        return OrbitCrypto.exportPrivateKey(key);
	      }).then(function (privKey) {
	        return privateKey = privKey;
	      }).then(function () {
	        return OrbitCrypto.exportPublicKey(key);
	      }).then(function (pubKey) {
	        return publicKey = pubKey;
	      }).then(function () {
	        keystore.setItem(id, JSON.stringify({ publicKey: publicKey, privateKey: privateKey }));
	        return { publicKey: key, privateKey: key };
	      });
	    }
	  }, {
	    key: 'generateKey',
	    value: function generateKey() {
	      return Promise.resolve(ec.genKeyPair());
	    }
	  }, {
	    key: 'exportPublicKey',
	    value: function exportPublicKey(key) {
	      return Promise.resolve(key.getPublic('hex'));
	    }
	  }, {
	    key: 'exportPrivateKey',
	    value: function exportPrivateKey(key) {
	      return Promise.resolve(key.getPrivate('hex'));
	    }
	  }, {
	    key: 'importPublicKey',
	    value: function importPublicKey(key) {
	      return Promise.resolve(ec.keyFromPublic(key, 'hex'));
	    }
	  }, {
	    key: 'importPrivateKey',
	    value: function importPrivateKey(key) {
	      return Promise.resolve(ec.keyFromPrivate(key, 'hex'));
	    }
	  }, {
	    key: 'sign',
	    value: function sign(key, data) {
	      var sig = ec.sign(data, key);
	      return Promise.resolve(sig.toDER('hex'));
	    }
	  }, {
	    key: 'verify',
	    value: function verify(signature, key, data) {
	      Promise.resolve(ec.verify(data, signature, key));
	    }
	  }]);

	  return OrbitCrypto;
	}();

	module.exports = OrbitCrypto;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var map = __webpack_require__(166);
	var getDagNode = __webpack_require__(152);

	// transform { Hash: '...' } objects into { path: 'string', node: DAGNode }
	module.exports = function (err, res, send, done) {
	  if (err) {
	    return done(err);
	  }

	  map(res, function map(entry, next) {
	    getDagNode(send, entry.Hash, function (err, node) {
	      if (err) {
	        return next(err);
	      }
	      var obj = {
	        path: entry.Name,
	        hash: entry.Hash,
	        size: node.size()
	      };
	      next(null, obj);
	    });
	  }, function (err, res) {
	    done(err, res);
	  });
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var bs58 = __webpack_require__(18);
	var isIPFS = __webpack_require__(85);

	module.exports = function (multihash) {
	  if (!isIPFS.multihash(multihash)) {
	    throw new Error('not valid multihash');
	  }
	  if (Buffer.isBuffer(multihash)) {
	    return bs58.encode(multihash);
	  }
	  return multihash;
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	exports.DAGNode = __webpack_require__(71);
	exports.DAGLink = __webpack_require__(70);
	exports.DAGService = __webpack_require__(171);
	exports.util = __webpack_require__(72);

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EventEmitter = __webpack_require__(10).EventEmitter;
	var Log = __webpack_require__(170);
	var Index = __webpack_require__(186);

	var DefaultMaxHistory = 256;

	var Store = function () {
	  function Store(ipfs, id, dbname, options) {
	    _classCallCheck(this, Store);

	    this.id = id;
	    this.dbname = dbname;
	    this.events = new EventEmitter();

	    if (!options) options = {};
	    if (options.Index === undefined) Object.assign(options, { Index: Index });
	    if (options.maxHistory === undefined) Object.assign(options, { maxHistory: DefaultMaxHistory });

	    this.options = options;
	    this._ipfs = ipfs;
	    this._index = new this.options.Index(this.id);
	    this._oplog = new Log(this._ipfs, this.id, this.dbname, this.options);
	    this._lastWrite = [];
	  }

	  _createClass(Store, [{
	    key: 'loadHistory',
	    value: function loadHistory(hash) {
	      var _this = this;

	      if (this._lastWrite.indexOf(hash) > -1) return Promise.resolve([]);

	      this.events.emit('load', this.dbname);

	      if (hash) {
	        return Log.fromIpfsHash(this._ipfs, hash, this.options).then(function (log) {
	          return _this._oplog.join(log);
	        }).then(function (merged) {
	          _this._index.updateIndex(_this._oplog, merged);
	          _this.events.emit('history', _this.dbname, merged);
	        }).then(function () {
	          return _this.events.emit('ready', _this.dbname);
	        }).then(function () {
	          return _this;
	        });
	      } else {
	        this.events.emit('ready', this.dbname);
	        return Promise.resolve(this);
	      }
	    }
	  }, {
	    key: 'close',
	    value: function close() {
	      this.delete();
	      this.events.emit('close', this.dbname);
	    }
	  }, {
	    key: 'sync',
	    value: function sync(hash) {
	      var _this2 = this;

	      if (!hash || this._lastWrite.indexOf(hash) > -1) {
	        return Promise.resolve([]);
	      }

	      var newItems = [];
	      this.events.emit('sync', this.dbname);
	      this._lastWrite.push(hash);
	      var startTime = new Date().getTime();
	      return Log.fromIpfsHash(this._ipfs, hash, this.options).then(function (log) {
	        return _this2._oplog.join(log);
	      }).then(function (merged) {
	        return newItems = merged;
	      }).then(function () {
	        return _this2._index.updateIndex(_this2._oplog, newItems);
	      }).then(function () {
	        newItems.reverse().forEach(function (e) {
	          return _this2.events.emit('data', _this2.dbname, e);
	        });
	      }).then(function () {
	        return newItems;
	      });
	    }
	  }, {
	    key: 'delete',
	    value: function _delete() {
	      this._index = new this.options.Index(this.id);
	      this._oplog = new Log(this._ipfs, this.id, this.dbname, this.options);
	    }
	  }, {
	    key: '_addOperation',
	    value: function _addOperation(data) {
	      var _this3 = this;

	      var result = void 0,
	          logHash = void 0;
	      if (this._oplog) {
	        return this._oplog.add(data).then(function (res) {
	          return result = res;
	        }).then(function () {
	          return Log.getIpfsHash(_this3._ipfs, _this3._oplog);
	        }).then(function (hash) {
	          return logHash = hash;
	        }).then(function () {
	          return _this3._lastWrite.push(logHash);
	        }).then(function () {
	          return _this3._index.updateIndex(_this3._oplog, [result]);
	        }).then(function () {
	          return _this3.events.emit('write', _this3.dbname, logHash);
	        }).then(function () {
	          return _this3.events.emit('data', _this3.dbname, result);
	        }).then(function () {
	          return result.hash;
	        });
	      }
	    }
	  }]);

	  return Store;
	}();

	module.exports = Store;

/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = false;

	// Only Node.JS has a process variable that is of [[Class]] process
	try {
	 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
	} catch(e) {}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var fs     = __webpack_require__(11);
	var http   = __webpack_require__(56);
	var os     = __webpack_require__(57);
	var Stream = __webpack_require__(3);
	var URL    = __webpack_require__(110);
	var util   = __webpack_require__(4);

	// The starting point is everything that works in any environment (browser OR
	// Node.js)
	var Lazy = __webpack_require__(284);

	/**
	 * @constructor
	 */
	function StreamedSequence(stream) {
	  this.stream = stream;
	}

	StreamedSequence.prototype = new Lazy.StreamLikeSequence();

	StreamedSequence.prototype.openStream = function(callback) {
	  this.stream.resume();
	  callback(this.stream);
	};

	/**
	 * Handles every chunk of data in this sequence.
	 *
	 * @param {function(string):*} fn The function to call on each chunk of data as
	 *     it's read from the stream. Return false from the function to stop reading
	 *     the stream.
	 */
	StreamedSequence.prototype.each = function(fn) {
	  var cancelled = false;

	  var handle = new Lazy.AsyncHandle(function cancel() { cancelled = true; });

	  this.openStream(function(stream) {
	    if (stream.setEncoding) {
	      stream.setEncoding(this.encoding || 'utf8');
	    }

	    var listener = function(e) {
	      try {
	        if (cancelled || fn(e) === false) {
	          stream.removeListener("data", listener);
	          handle._resolve(false);
	        }
	      } catch (e) {
	        handle._reject(e);
	      }
	    };

	    stream.on("data", listener);

	    stream.on("end", function() {
	      handle._resolve(true);
	    });
	  });

	  return handle;
	};

	/**
	 * Creates a {@link Sequence} of lines as they are read from a file.
	 *
	 * @return {Sequence} A sequence comprising the lines in the underlying file, as
	 *     they are read.
	 */
	StreamedSequence.prototype.lines = function() {
	  return this.split(os.EOL || "\n");
	};

	function FileStreamSequence(path, encoding) {
	  this.path = path;
	  this.encoding = encoding;
	}

	FileStreamSequence.prototype = new StreamedSequence();

	FileStreamSequence.prototype.openStream = function(callback) {
	  var stream = fs.createReadStream(this.path, { autoClose: true });
	  callback(stream);
	};

	/**
	 * Creates a {@link Sequence} from a file stream, whose elements are chunks of
	 * data as the stream is read. This is an {@link AsyncSequence}, so methods such
	 * as {@link Sequence#reduce} return an {@link AsyncHandle} rather than a value.
	 *
	 * @param {string} path A path to a file.
	 * @param {string} encoding The text encoding of the file (e.g., "utf-8").
	 * @return {Sequence} The streamed sequence.
	 */
	Lazy.readFile = function(path, encoding) {
	  return new FileStreamSequence(path, encoding);
	};

	function HttpStreamSequence(url, encoding) {
	  this.url = url;
	  this.encoding = encoding;
	}

	HttpStreamSequence.prototype = new StreamedSequence();

	HttpStreamSequence.prototype.openStream = function(callback) {
	  http.get(URL.parse(this.url), callback);
	};

	/**
	 * Creates a {@link Sequence} from an HTTP stream, whose elements are chunks of
	 * data as the stream is read. This sequence works asynchronously, so
	 * synchronous methods such as {@code indexOf}, {@code any}, and {@code toArray}
	 * won't work.
	 *
	 * @param {string} url The URL for the HTTP request.
	 * @return {Sequence} The streamed sequence.
	 */
	Lazy.makeHttpRequest = function(url) {
	  return new HttpStreamSequence(url);
	};

	if (typeof Stream.Readable !== "undefined") {
	  Lazy.Sequence.prototype.toStream = function toStream(options) {
	    return new LazyStream(this, options);
	  };

	  Lazy.Sequence.prototype.pipe = function pipe(destination) {
	    this.toStream().pipe(destination);
	  };

	  function LazyStream(sequence, options) {
	    options = Lazy(options || {})
	      .extend({ objectMode: true })
	      .toObject();

	    Stream.Readable.call(this, options);

	    this.sequence = sequence;
	    this.started  = false;
	    
	    // Find delimiter on a (parent) sequence object if set
	    while (sequence) {
	      if (sequence.delimiter) {
	        this.delimiter = sequence.delimiter;
	        break;
	      }
	      sequence = sequence.parent;
	    }
	  }

	  util.inherits(LazyStream, Stream.Readable);

	  LazyStream.prototype._read = function() {
	    var self = this;

	    if (!this.started) {
	      var handle = this.sequence.each(function(line, i) {
	        if (self.delimiter != null) {
	          line += self.delimiter;
	        }
	        return self.push(line, i);
	      });
	      if (handle instanceof Lazy.AsyncHandle) {
	        handle.onComplete(function() {
	          self.push(null);
	        });
	      }
	      this.started = true;
	    }
	  };
	}

	/*
	 * Add support for `Lazy(Stream)`.
	 */
	Lazy.extensions || (Lazy.extensions = []);

	Lazy.extensions.push(function(source) {
	  if (source instanceof Stream) {
	    return new StreamedSequence(source);
	  }
	});

	module.exports = Lazy;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var result,
	      index = -1,
	      length = path.length;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);

	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = map;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch

	var path = { sep: '/' }
	try {
	  path = __webpack_require__(12)
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(229)

	var plTypes = {
	  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
	  '?': { open: '(?:', close: ')?' },
	  '+': { open: '(?:', close: ')+' },
	  '*': { open: '(?:', close: ')*' },
	  '@': { open: '(?:', close: ')' }
	}

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'

	// * => any number of characters
	var star = qmark + '*?'

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}

	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function () {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0

	  if (options.nonegate) return

	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}

	Minimatch.prototype.braceExpand = braceExpand

	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }

	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern

	  if (typeof pattern === 'undefined') {
	    throw new TypeError('undefined pattern')
	  }

	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  return expand(pattern)
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  if (pattern.length > 1024 * 64) {
	    throw new TypeError('pattern is too long')
	  }

	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''

	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue

	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }

	        if (!stateChar) {
	          re += '\\('
	          continue
	        }

	        patternListStack.push({
	          type: stateChar,
	          start: i - 1,
	          reStart: re.length,
	          open: plTypes[stateChar].open,
	          close: plTypes[stateChar].close
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        var pl = patternListStack.pop()
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        re += pl.close
	        if (pl.type === '!') {
	          negativeLists.push(pl)
	        }
	        pl.reEnd = re.length
	      continue

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += '|'
	      continue

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += '\\' + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }

	        re += c

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + pl.open.length)
	    this.debug('setting tail', re, pl)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })

	    this.debug('tail=%j\n   %s', tail, tail, pl, re)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]

	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)

	    nlLast += nlAfter

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter

	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }

	  if (addPatternStart) {
	    re = patternStart + re
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? 'i' : ''
	  try {
	    var regExp = new RegExp('^' + re + '$', flags)
	  } catch (er) {
	    // If it was an invalid regular expression, then it can't match
	    // anything.  This trick looks for a character after the end of
	    // the string, which is of course impossible, except in multi-line
	    // mode, but it's not a /m regex.
	    return new RegExp('$.')
	  }

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'

	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''

	  if (f === '/' && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, 'set', set)

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })

	  this.debug('matchOne', file.length, pattern.length)

	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error('wtf?')
	}

	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}

	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var map = __webpack_require__(43);

	module.exports = Protocols;

	function Protocols(proto) {
	  if (typeof proto === 'number') {
	    if (Protocols.codes[proto]) {
	      return Protocols.codes[proto];
	    }

	    throw new Error('no protocol with code: ' + proto);
	  } else if (typeof proto === 'string' || proto instanceof String) {
	    if (Protocols.names[proto]) {
	      return Protocols.names[proto];
	    }

	    throw new Error('no protocol with name: ' + proto);
	  }

	  throw new Error('invalid protocol id type: ' + proto);
	}

	Protocols.lengthPrefixedVarSize = -1;

	// replicating table here to:
	// 1. avoid parsing the csv
	// 2. ensuring errors in the csv don't screw up code.
	// 3. changing a number has to happen in two places.

	Protocols.table = [[4, 32, 'ip4'], [6, 16, 'tcp'], [17, 16, 'udp'], [33, 16, 'dccp'], [41, 128, 'ip6'], [132, 16, 'sctp'],
	// these require varint for the protocol code
	[302, 0, 'utp'], [421, Protocols.lengthPrefixedVarSize, 'ipfs'], [480, 0, 'http'], [443, 0, 'https'], [477, 0, 'ws'], [275, 0, 'libp2p-webrtc-star']];

	Protocols.names = {};
	Protocols.codes = {};

	// populate tables
	map(Protocols.table, function (e) {
	  var proto = p.apply(this, e);
	  Protocols.codes[proto.code] = proto;
	  Protocols.names[proto.name] = proto;
	});

	Protocols.object = p;

	function p(code, size, name) {
	  return { code: code, size: size, name: name };
	}

/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	function posix(path) {
		return path.charAt(0) === '/';
	};

	function win32(path) {
		// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = !!device && device.charAt(1) !== ':';

		// UNC paths are always absolute
		return !!result[2] || isUnc;
	};

	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;


/***/ },
/* 47 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}

	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	exports.publicEncrypt = __webpack_require__(333);
	exports.privateDecrypt = __webpack_require__(332);

	exports.privateEncrypt = function privateEncrypt(key, buf) {
	  return exports.publicEncrypt(key, buf, true);
	};

	exports.publicDecrypt = function publicDecrypt(key, buf) {
	  return exports.privateDecrypt(key, buf, true);
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var drain = __webpack_require__(25)

	module.exports = function reduce (reducer, acc, cb) {
	  return drain(function (data) {
	    acc = reducer(acc, data)
	  }, function (err) {
	    cb(err, acc)
	  })
	}



/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'
	var abortCb = __webpack_require__(101)

	module.exports = function values (array, onAbort) {
	  if(!array)
	    return function (abort, cb) {
	      if(abort) return abortCb(cb, abort, onAbort)
	      return cb(true)
	    }
	  if(!Array.isArray(array))
	    array = Object.keys(array).map(function (k) {
	      return array[k]
	    })
	  var i = 0
	  return function (abort, cb) {
	    if(abort)
	      return abortCb(cb, abort, onAbort)
	    if(i >= array.length)
	      cb(true)
	    else
	      cb(null, array[i++])
	  }
	}


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var tester = __webpack_require__(102)

	module.exports = function filter (test) {
	  //regexp
	  test = tester(test)
	  return function (read) {
	    return function next (end, cb) {
	      var sync, loop = true
	      while(loop) {
	        loop = false
	        sync = true
	        read(end, function (end, data) {
	          if(!end && !test(data))
	            return sync ? loop = true : next(end, cb)
	          cb(end, data)
	        })
	        sync = false
	      }
	    }
	  }
	}



/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9).randomBytes


/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			Object.defineProperty(module, "loaded", {
				enumerable: true,
				configurable: false,
				get: function() { return module.l; }
			});
			Object.defineProperty(module, "id", {
				enumerable: true,
				configurable: false,
				get: function() { return module.i; }
			});
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 54 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 58 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var OrbitUser = function OrbitUser(keys, profileData) {
	  _classCallCheck(this, OrbitUser);

	  this._keys = keys;
	  this.profile = profileData;
	};

	module.exports = OrbitUser;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);
	var Reporter = __webpack_require__(21).Reporter;
	var Buffer = __webpack_require__(6).Buffer;

	function DecoderBuffer(base, options) {
	  Reporter.call(this, options);
	  if (!Buffer.isBuffer(base)) {
	    this.error('Input not Buffer');
	    return;
	  }

	  this.base = base;
	  this.offset = 0;
	  this.length = base.length;
	}
	inherits(DecoderBuffer, Reporter);
	exports.DecoderBuffer = DecoderBuffer;

	DecoderBuffer.prototype.save = function save() {
	  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
	};

	DecoderBuffer.prototype.restore = function restore(save) {
	  // Return skipped data
	  var res = new DecoderBuffer(this.base);
	  res.offset = save.offset;
	  res.length = this.offset;

	  this.offset = save.offset;
	  Reporter.prototype.restore.call(this, save.reporter);

	  return res;
	};

	DecoderBuffer.prototype.isEmpty = function isEmpty() {
	  return this.offset === this.length;
	};

	DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
	  if (this.offset + 1 <= this.length)
	    return this.base.readUInt8(this.offset++, true);
	  else
	    return this.error(fail || 'DecoderBuffer overrun');
	}

	DecoderBuffer.prototype.skip = function skip(bytes, fail) {
	  if (!(this.offset + bytes <= this.length))
	    return this.error(fail || 'DecoderBuffer overrun');

	  var res = new DecoderBuffer(this.base);

	  // Share reporter state
	  res._reporterState = this._reporterState;

	  res.offset = this.offset;
	  res.length = this.offset + bytes;
	  this.offset += bytes;
	  return res;
	}

	DecoderBuffer.prototype.raw = function raw(save) {
	  return this.base.slice(save ? save.offset : this.offset, this.length);
	}

	function EncoderBuffer(value, reporter) {
	  if (Array.isArray(value)) {
	    this.length = 0;
	    this.value = value.map(function(item) {
	      if (!(item instanceof EncoderBuffer))
	        item = new EncoderBuffer(item, reporter);
	      this.length += item.length;
	      return item;
	    }, this);
	  } else if (typeof value === 'number') {
	    if (!(0 <= value && value <= 0xff))
	      return reporter.error('non-byte EncoderBuffer value');
	    this.value = value;
	    this.length = 1;
	  } else if (typeof value === 'string') {
	    this.value = value;
	    this.length = Buffer.byteLength(value);
	  } else if (Buffer.isBuffer(value)) {
	    this.value = value;
	    this.length = value.length;
	  } else {
	    return reporter.error('Unsupported type: ' + typeof value);
	  }
	}
	exports.EncoderBuffer = EncoderBuffer;

	EncoderBuffer.prototype.join = function join(out, offset) {
	  if (!out)
	    out = new Buffer(this.length);
	  if (!offset)
	    offset = 0;

	  if (this.length === 0)
	    return out;

	  if (Array.isArray(this.value)) {
	    this.value.forEach(function(item) {
	      item.join(out, offset);
	      offset += item.length;
	    });
	  } else {
	    if (typeof this.value === 'number')
	      out[offset] = this.value;
	    else if (typeof this.value === 'string')
	      out.write(this.value, offset);
	    else if (Buffer.isBuffer(this.value))
	      this.value.copy(out, offset);
	    offset += this.length;
	  }

	  return out;
	};


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var constants = exports;

	// Helper
	constants._reverse = function reverse(map) {
	  var res = {};

	  Object.keys(map).forEach(function(key) {
	    // Convert key to integer if it is stringified
	    if ((key | 0) == key)
	      key = key | 0;

	    var value = map[key];
	    res[value] = key;
	  });

	  return res;
	};

	constants.der = __webpack_require__(118);


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);

	var asn1 = __webpack_require__(29);
	var base = asn1.base;
	var bignum = asn1.bignum;

	// Import DER constants
	var der = asn1.constants.der;

	function DERDecoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	};
	module.exports = DERDecoder;

	DERDecoder.prototype.decode = function decode(data, options) {
	  if (!(data instanceof base.DecoderBuffer))
	    data = new base.DecoderBuffer(data, options);

	  return this.tree._decode(data, options);
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
	  if (buffer.isEmpty())
	    return false;

	  var state = buffer.save();
	  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  buffer.restore(state);

	  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
	    (decodedTag.tagStr + 'of') === tag || any;
	};

	DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
	  var decodedTag = derDecodeTag(buffer,
	                                'Failed to decode tag of "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  var len = derDecodeLen(buffer,
	                         decodedTag.primitive,
	                         'Failed to get length of "' + tag + '"');

	  // Failure
	  if (buffer.isError(len))
	    return len;

	  if (!any &&
	      decodedTag.tag !== tag &&
	      decodedTag.tagStr !== tag &&
	      decodedTag.tagStr + 'of' !== tag) {
	    return buffer.error('Failed to match tag: "' + tag + '"');
	  }

	  if (decodedTag.primitive || len !== null)
	    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

	  // Indefinite length... find END tag
	  var state = buffer.save();
	  var res = this._skipUntilEnd(
	      buffer,
	      'Failed to skip indefinite length body: "' + this.tag + '"');
	  if (buffer.isError(res))
	    return res;

	  len = buffer.offset - state.offset;
	  buffer.restore(state);
	  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
	};

	DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
	  while (true) {
	    var tag = derDecodeTag(buffer, fail);
	    if (buffer.isError(tag))
	      return tag;
	    var len = derDecodeLen(buffer, tag.primitive, fail);
	    if (buffer.isError(len))
	      return len;

	    var res;
	    if (tag.primitive || len !== null)
	      res = buffer.skip(len)
	    else
	      res = this._skipUntilEnd(buffer, fail);

	    // Failure
	    if (buffer.isError(res))
	      return res;

	    if (tag.tagStr === 'end')
	      break;
	  }
	};

	DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
	                                                    options) {
	  var result = [];
	  while (!buffer.isEmpty()) {
	    var possibleEnd = this._peekTag(buffer, 'end');
	    if (buffer.isError(possibleEnd))
	      return possibleEnd;

	    var res = decoder.decode(buffer, 'der', options);
	    if (buffer.isError(res) && possibleEnd)
	      break;
	    result.push(res);
	  }
	  return result;
	};

	DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
	  if (tag === 'bitstr') {
	    var unused = buffer.readUInt8();
	    if (buffer.isError(unused))
	      return unused;
	    return { unused: unused, data: buffer.raw() };
	  } else if (tag === 'bmpstr') {
	    var raw = buffer.raw();
	    if (raw.length % 2 === 1)
	      return buffer.error('Decoding of string type: bmpstr length mismatch');

	    var str = '';
	    for (var i = 0; i < raw.length / 2; i++) {
	      str += String.fromCharCode(raw.readUInt16BE(i * 2));
	    }
	    return str;
	  } else if (tag === 'numstr') {
	    var numstr = buffer.raw().toString('ascii');
	    if (!this._isNumstr(numstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'numstr unsupported characters');
	    }
	    return numstr;
	  } else if (tag === 'octstr') {
	    return buffer.raw();
	  } else if (tag === 'printstr') {
	    var printstr = buffer.raw().toString('ascii');
	    if (!this._isPrintstr(printstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'printstr unsupported characters');
	    }
	    return printstr;
	  } else if (/str$/.test(tag)) {
	    return buffer.raw().toString();
	  } else {
	    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
	  }
	};

	DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
	  var result;
	  var identifiers = [];
	  var ident = 0;
	  while (!buffer.isEmpty()) {
	    var subident = buffer.readUInt8();
	    ident <<= 7;
	    ident |= subident & 0x7f;
	    if ((subident & 0x80) === 0) {
	      identifiers.push(ident);
	      ident = 0;
	    }
	  }
	  if (subident & 0x80)
	    identifiers.push(ident);

	  var first = (identifiers[0] / 40) | 0;
	  var second = identifiers[0] % 40;

	  if (relative)
	    result = identifiers;
	  else
	    result = [first, second].concat(identifiers.slice(1));

	  if (values) {
	    var tmp = values[result.join(' ')];
	    if (tmp === undefined)
	      tmp = values[result.join('.')];
	    if (tmp !== undefined)
	      result = tmp;
	  }

	  return result;
	};

	DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
	  var str = buffer.raw().toString();
	  if (tag === 'gentime') {
	    var year = str.slice(0, 4) | 0;
	    var mon = str.slice(4, 6) | 0;
	    var day = str.slice(6, 8) | 0;
	    var hour = str.slice(8, 10) | 0;
	    var min = str.slice(10, 12) | 0;
	    var sec = str.slice(12, 14) | 0;
	  } else if (tag === 'utctime') {
	    var year = str.slice(0, 2) | 0;
	    var mon = str.slice(2, 4) | 0;
	    var day = str.slice(4, 6) | 0;
	    var hour = str.slice(6, 8) | 0;
	    var min = str.slice(8, 10) | 0;
	    var sec = str.slice(10, 12) | 0;
	    if (year < 70)
	      year = 2000 + year;
	    else
	      year = 1900 + year;
	  } else {
	    return buffer.error('Decoding ' + tag + ' time is not supported yet');
	  }

	  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
	};

	DERNode.prototype._decodeNull = function decodeNull(buffer) {
	  return null;
	};

	DERNode.prototype._decodeBool = function decodeBool(buffer) {
	  var res = buffer.readUInt8();
	  if (buffer.isError(res))
	    return res;
	  else
	    return res !== 0;
	};

	DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
	  // Bigint, return as it is (assume big endian)
	  var raw = buffer.raw();
	  var res = new bignum(raw);

	  if (values)
	    res = values[res.toString(10)] || res;

	  return res;
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getDecoder('der').tree;
	};

	// Utility methods

	function derDecodeTag(buf, fail) {
	  var tag = buf.readUInt8(fail);
	  if (buf.isError(tag))
	    return tag;

	  var cls = der.tagClass[tag >> 6];
	  var primitive = (tag & 0x20) === 0;

	  // Multi-octet tag - load
	  if ((tag & 0x1f) === 0x1f) {
	    var oct = tag;
	    tag = 0;
	    while ((oct & 0x80) === 0x80) {
	      oct = buf.readUInt8(fail);
	      if (buf.isError(oct))
	        return oct;

	      tag <<= 7;
	      tag |= oct & 0x7f;
	    }
	  } else {
	    tag &= 0x1f;
	  }
	  var tagStr = der.tag[tag];

	  return {
	    cls: cls,
	    primitive: primitive,
	    tag: tag,
	    tagStr: tagStr
	  };
	}

	function derDecodeLen(buf, primitive, fail) {
	  var len = buf.readUInt8(fail);
	  if (buf.isError(len))
	    return len;

	  // Indefinite form
	  if (!primitive && len === 0x80)
	    return null;

	  // Definite form
	  if ((len & 0x80) === 0) {
	    // Short form
	    return len;
	  }

	  // Long form
	  var num = len & 0x7f;
	  if (num >= 4)
	    return buf.error('length octect is too long');

	  len = 0;
	  for (var i = 0; i < num; i++) {
	    len <<= 8;
	    var j = buf.readUInt8(fail);
	    if (buf.isError(j))
	      return j;
	    len |= j;
	  }

	  return len;
	}


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);
	var Buffer = __webpack_require__(6).Buffer;

	var asn1 = __webpack_require__(29);
	var base = asn1.base;

	// Import DER constants
	var der = asn1.constants.der;

	function DEREncoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	};
	module.exports = DEREncoder;

	DEREncoder.prototype.encode = function encode(data, reporter) {
	  return this.tree._encode(data, reporter).join();
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._encodeComposite = function encodeComposite(tag,
	                                                              primitive,
	                                                              cls,
	                                                              content) {
	  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

	  // Short form
	  if (content.length < 0x80) {
	    var header = new Buffer(2);
	    header[0] = encodedTag;
	    header[1] = content.length;
	    return this._createEncoderBuffer([ header, content ]);
	  }

	  // Long form
	  // Count octets required to store length
	  var lenOctets = 1;
	  for (var i = content.length; i >= 0x100; i >>= 8)
	    lenOctets++;

	  var header = new Buffer(1 + 1 + lenOctets);
	  header[0] = encodedTag;
	  header[1] = 0x80 | lenOctets;

	  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
	    header[i] = j & 0xff;

	  return this._createEncoderBuffer([ header, content ]);
	};

	DERNode.prototype._encodeStr = function encodeStr(str, tag) {
	  if (tag === 'bitstr') {
	    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
	  } else if (tag === 'bmpstr') {
	    var buf = new Buffer(str.length * 2);
	    for (var i = 0; i < str.length; i++) {
	      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
	    }
	    return this._createEncoderBuffer(buf);
	  } else if (tag === 'numstr') {
	    if (!this._isNumstr(str)) {
	      return this.reporter.error('Encoding of string type: numstr supports ' +
	                                 'only digits and space');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'printstr') {
	    if (!this._isPrintstr(str)) {
	      return this.reporter.error('Encoding of string type: printstr supports ' +
	                                 'only latin upper and lower case letters, ' +
	                                 'digits, space, apostrophe, left and rigth ' +
	                                 'parenthesis, plus sign, comma, hyphen, ' +
	                                 'dot, slash, colon, equal sign, ' +
	                                 'question mark');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (/str$/.test(tag)) {
	    return this._createEncoderBuffer(str);
	  } else {
	    return this.reporter.error('Encoding of string type: ' + tag +
	                               ' unsupported');
	  }
	};

	DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
	  if (typeof id === 'string') {
	    if (!values)
	      return this.reporter.error('string objid given, but no values map found');
	    if (!values.hasOwnProperty(id))
	      return this.reporter.error('objid not found in values map');
	    id = values[id].split(/[\s\.]+/g);
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  } else if (Array.isArray(id)) {
	    id = id.slice();
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  }

	  if (!Array.isArray(id)) {
	    return this.reporter.error('objid() should be either array or string, ' +
	                               'got: ' + JSON.stringify(id));
	  }

	  if (!relative) {
	    if (id[1] >= 40)
	      return this.reporter.error('Second objid identifier OOB');
	    id.splice(0, 2, id[0] * 40 + id[1]);
	  }

	  // Count number of octets
	  var size = 0;
	  for (var i = 0; i < id.length; i++) {
	    var ident = id[i];
	    for (size++; ident >= 0x80; ident >>= 7)
	      size++;
	  }

	  var objid = new Buffer(size);
	  var offset = objid.length - 1;
	  for (var i = id.length - 1; i >= 0; i--) {
	    var ident = id[i];
	    objid[offset--] = ident & 0x7f;
	    while ((ident >>= 7) > 0)
	      objid[offset--] = 0x80 | (ident & 0x7f);
	  }

	  return this._createEncoderBuffer(objid);
	};

	function two(num) {
	  if (num < 10)
	    return '0' + num;
	  else
	    return num;
	}

	DERNode.prototype._encodeTime = function encodeTime(time, tag) {
	  var str;
	  var date = new Date(time);

	  if (tag === 'gentime') {
	    str = [
	      two(date.getFullYear()),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else if (tag === 'utctime') {
	    str = [
	      two(date.getFullYear() % 100),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else {
	    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
	  }

	  return this._encodeStr(str, 'octstr');
	};

	DERNode.prototype._encodeNull = function encodeNull() {
	  return this._createEncoderBuffer('');
	};

	DERNode.prototype._encodeInt = function encodeInt(num, values) {
	  if (typeof num === 'string') {
	    if (!values)
	      return this.reporter.error('String int or enum given, but no values map');
	    if (!values.hasOwnProperty(num)) {
	      return this.reporter.error('Values map doesn\'t contain: ' +
	                                 JSON.stringify(num));
	    }
	    num = values[num];
	  }

	  // Bignum, assume big endian
	  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
	    var numArray = num.toArray();
	    if (!num.sign && numArray[0] & 0x80) {
	      numArray.unshift(0);
	    }
	    num = new Buffer(numArray);
	  }

	  if (Buffer.isBuffer(num)) {
	    var size = num.length;
	    if (num.length === 0)
	      size++;

	    var out = new Buffer(size);
	    num.copy(out);
	    if (num.length === 0)
	      out[0] = 0
	    return this._createEncoderBuffer(out);
	  }

	  if (num < 0x80)
	    return this._createEncoderBuffer(num);

	  if (num < 0x100)
	    return this._createEncoderBuffer([0, num]);

	  var size = 1;
	  for (var i = num; i >= 0x100; i >>= 8)
	    size++;

	  var out = new Array(size);
	  for (var i = out.length - 1; i >= 0; i--) {
	    out[i] = num & 0xff;
	    num >>= 8;
	  }
	  if(out[0] & 0x80) {
	    out.unshift(0);
	  }

	  return this._createEncoderBuffer(new Buffer(out));
	};

	DERNode.prototype._encodeBool = function encodeBool(value) {
	  return this._createEncoderBuffer(value ? 0xff : 0);
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getEncoder('der').tree;
	};

	DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
	  var state = this._baseState;
	  var i;
	  if (state['default'] === null)
	    return false;

	  var data = dataBuffer.join();
	  if (state.defaultBuffer === undefined)
	    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

	  if (data.length !== state.defaultBuffer.length)
	    return false;

	  for (i=0; i < data.length; i++)
	    if (data[i] !== state.defaultBuffer[i])
	      return false;

	  return true;
	};

	// Utility methods

	function encodeTag(tag, primitive, cls, reporter) {
	  var res;

	  if (tag === 'seqof')
	    tag = 'seq';
	  else if (tag === 'setof')
	    tag = 'set';

	  if (der.tagByName.hasOwnProperty(tag))
	    res = der.tagByName[tag];
	  else if (typeof tag === 'number' && (tag | 0) === tag)
	    res = tag;
	  else
	    return reporter.error('Unknown tag: ' + tag);

	  if (res >= 0x1f)
	    return reporter.error('Multi-octet tag encoding unsupported');

	  if (!primitive)
	    res |= 0x20;

	  res |= (der.tagClassByName[cls || 'universal'] << 6);

	  return res;
	}


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var Hoek = __webpack_require__(22);

	// Declare internals

	var internals = {
	    STATUS_CODES: Object.setPrototypeOf({
	        '100': 'Continue',
	        '101': 'Switching Protocols',
	        '102': 'Processing',
	        '200': 'OK',
	        '201': 'Created',
	        '202': 'Accepted',
	        '203': 'Non-Authoritative Information',
	        '204': 'No Content',
	        '205': 'Reset Content',
	        '206': 'Partial Content',
	        '207': 'Multi-Status',
	        '300': 'Multiple Choices',
	        '301': 'Moved Permanently',
	        '302': 'Moved Temporarily',
	        '303': 'See Other',
	        '304': 'Not Modified',
	        '305': 'Use Proxy',
	        '307': 'Temporary Redirect',
	        '400': 'Bad Request',
	        '401': 'Unauthorized',
	        '402': 'Payment Required',
	        '403': 'Forbidden',
	        '404': 'Not Found',
	        '405': 'Method Not Allowed',
	        '406': 'Not Acceptable',
	        '407': 'Proxy Authentication Required',
	        '408': 'Request Time-out',
	        '409': 'Conflict',
	        '410': 'Gone',
	        '411': 'Length Required',
	        '412': 'Precondition Failed',
	        '413': 'Request Entity Too Large',
	        '414': 'Request-URI Too Large',
	        '415': 'Unsupported Media Type',
	        '416': 'Requested Range Not Satisfiable',
	        '417': 'Expectation Failed',
	        '418': 'I\'m a teapot',
	        '422': 'Unprocessable Entity',
	        '423': 'Locked',
	        '424': 'Failed Dependency',
	        '425': 'Unordered Collection',
	        '426': 'Upgrade Required',
	        '428': 'Precondition Required',
	        '429': 'Too Many Requests',
	        '431': 'Request Header Fields Too Large',
	        '451': 'Unavailable For Legal Reasons',
	        '500': 'Internal Server Error',
	        '501': 'Not Implemented',
	        '502': 'Bad Gateway',
	        '503': 'Service Unavailable',
	        '504': 'Gateway Time-out',
	        '505': 'HTTP Version Not Supported',
	        '506': 'Variant Also Negotiates',
	        '507': 'Insufficient Storage',
	        '509': 'Bandwidth Limit Exceeded',
	        '510': 'Not Extended',
	        '511': 'Network Authentication Required'
	    }, null)
	};

	exports.wrap = function (error, statusCode, message) {

	    Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');
	    return error.isBoom ? error : internals.initialize(error, statusCode || 500, message);
	};

	exports.create = function (statusCode, message, data) {

	    return internals.create(statusCode, message, data, exports.create);
	};

	internals.create = function (statusCode, message, data, ctor) {

	    var error = new Error(message ? message : undefined); // Avoids settings null message
	    Error.captureStackTrace(error, ctor); // Filter the stack to our external API
	    error.data = data || null;
	    internals.initialize(error, statusCode);
	    return error;
	};

	internals.initialize = function (error, statusCode, message) {

	    var numberCode = parseInt(statusCode, 10);
	    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);

	    error.isBoom = true;
	    error.isServer = numberCode >= 500;

	    if (!error.hasOwnProperty('data')) {
	        error.data = null;
	    }

	    error.output = {
	        statusCode: numberCode,
	        payload: {},
	        headers: {}
	    };

	    error.reformat = internals.reformat;
	    error.reformat();

	    if (!message && !error.message) {

	        message = error.output.payload.error;
	    }

	    if (message) {
	        error.message = message + (error.message ? ': ' + error.message : '');
	    }

	    return error;
	};

	internals.reformat = function () {

	    this.output.payload.statusCode = this.output.statusCode;
	    this.output.payload.error = internals.STATUS_CODES[this.output.statusCode] || 'Unknown';

	    if (this.output.statusCode === 500) {
	        this.output.payload.message = 'An internal server error occurred'; // Hide actual error from user
	    } else if (this.message) {
	        this.output.payload.message = this.message;
	    }
	};

	// 4xx Client Errors

	exports.badRequest = function (message, data) {

	    return internals.create(400, message, data, exports.badRequest);
	};

	exports.unauthorized = function (message, scheme, attributes) {
	    // Or function (message, wwwAuthenticate[])

	    var err = internals.create(401, message, undefined, exports.unauthorized);

	    if (!scheme) {
	        return err;
	    }

	    var wwwAuthenticate = '';

	    if (typeof scheme === 'string') {

	        // function (message, scheme, attributes)

	        wwwAuthenticate = scheme;

	        if (attributes || message) {
	            err.output.payload.attributes = {};
	        }

	        if (attributes) {
	            var names = Object.keys(attributes);
	            for (var i = 0; i < names.length; ++i) {
	                var name = names[i];
	                if (i) {
	                    wwwAuthenticate = wwwAuthenticate + ',';
	                }

	                var value = attributes[name];
	                if (value === null || value === undefined) {
	                    // Value can be zero

	                    value = '';
	                }
	                wwwAuthenticate = wwwAuthenticate + ' ' + name + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
	                err.output.payload.attributes[name] = value;
	            }
	        }

	        if (message) {
	            if (attributes) {
	                wwwAuthenticate = wwwAuthenticate + ',';
	            }
	            wwwAuthenticate = wwwAuthenticate + ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
	            err.output.payload.attributes.error = message;
	        } else {
	            err.isMissing = true;
	        }
	    } else {

	        // function (message, wwwAuthenticate[])

	        var wwwArray = scheme;
	        for (var _i = 0; _i < wwwArray.length; ++_i) {
	            if (_i) {
	                wwwAuthenticate = wwwAuthenticate + ', ';
	            }

	            wwwAuthenticate = wwwAuthenticate + wwwArray[_i];
	        }
	    }

	    err.output.headers['WWW-Authenticate'] = wwwAuthenticate;

	    return err;
	};

	exports.forbidden = function (message, data) {

	    return internals.create(403, message, data, exports.forbidden);
	};

	exports.notFound = function (message, data) {

	    return internals.create(404, message, data, exports.notFound);
	};

	exports.methodNotAllowed = function (message, data) {

	    return internals.create(405, message, data, exports.methodNotAllowed);
	};

	exports.notAcceptable = function (message, data) {

	    return internals.create(406, message, data, exports.notAcceptable);
	};

	exports.proxyAuthRequired = function (message, data) {

	    return internals.create(407, message, data, exports.proxyAuthRequired);
	};

	exports.clientTimeout = function (message, data) {

	    return internals.create(408, message, data, exports.clientTimeout);
	};

	exports.conflict = function (message, data) {

	    return internals.create(409, message, data, exports.conflict);
	};

	exports.resourceGone = function (message, data) {

	    return internals.create(410, message, data, exports.resourceGone);
	};

	exports.lengthRequired = function (message, data) {

	    return internals.create(411, message, data, exports.lengthRequired);
	};

	exports.preconditionFailed = function (message, data) {

	    return internals.create(412, message, data, exports.preconditionFailed);
	};

	exports.entityTooLarge = function (message, data) {

	    return internals.create(413, message, data, exports.entityTooLarge);
	};

	exports.uriTooLong = function (message, data) {

	    return internals.create(414, message, data, exports.uriTooLong);
	};

	exports.unsupportedMediaType = function (message, data) {

	    return internals.create(415, message, data, exports.unsupportedMediaType);
	};

	exports.rangeNotSatisfiable = function (message, data) {

	    return internals.create(416, message, data, exports.rangeNotSatisfiable);
	};

	exports.expectationFailed = function (message, data) {

	    return internals.create(417, message, data, exports.expectationFailed);
	};

	exports.badData = function (message, data) {

	    return internals.create(422, message, data, exports.badData);
	};

	exports.locked = function (message, data) {

	    return internals.create(423, message, data, exports.locked);
	};

	exports.preconditionRequired = function (message, data) {

	    return internals.create(428, message, data, exports.preconditionRequired);
	};

	exports.tooManyRequests = function (message, data) {

	    return internals.create(429, message, data, exports.tooManyRequests);
	};

	exports.illegal = function (message, data) {

	    return internals.create(451, message, data, exports.illegal);
	};

	// 5xx Server Errors

	exports.internal = function (message, data, statusCode) {

	    return internals.serverError(message, data, statusCode, exports.internal);
	};

	internals.serverError = function (message, data, statusCode, ctor) {

	    var error = void 0;
	    if (data instanceof Error) {
	        error = exports.wrap(data, statusCode, message);
	    } else {
	        error = internals.create(statusCode || 500, message, undefined, ctor);
	        error.data = data;
	    }

	    return error;
	};

	exports.notImplemented = function (message, data) {

	    return internals.serverError(message, data, 501, exports.notImplemented);
	};

	exports.badGateway = function (message, data) {

	    return internals.serverError(message, data, 502, exports.badGateway);
	};

	exports.serverUnavailable = function (message, data) {

	    return internals.serverError(message, data, 503, exports.serverUnavailable);
	};

	exports.gatewayTimeout = function (message, data) {

	    return internals.serverError(message, data, 504, exports.gatewayTimeout);
	};

	exports.badImplementation = function (message, data) {

	    var err = internals.serverError(message, data, 500, exports.badImplementation);
	    err.isDeveloperError = true;
	    return err;
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var addCmd = __webpack_require__(30);
	var Duplex = __webpack_require__(3).Duplex;
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  var add = addCmd(send);

	  return promisify(function (callback) {
	    var tuples = [];

	    var ds = new Duplex({ objectMode: true });
	    ds._read = function (n) {};

	    ds._write = function (file, enc, next) {
	      tuples.push(file);
	      next();
	    };

	    ds.end = function () {
	      add(tuples, function (err, res) {
	        if (err) {
	          return ds.emit('error', err);
	        }

	        res.forEach(function (tuple) {
	          ds.push(tuple);
	        });

	        ds.push(null);
	      });
	    };
	    callback(null, ds);
	  });
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var tarStreamToObjects = __webpack_require__(157);
	var cleanMultihash = __webpack_require__(38);
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function get(path, opts, callback) {
	    if (typeof opts === 'function' && !callback) {
	      callback = opts;
	      opts = {};
	    }

	    // opts is the real callback --
	    // 'callback' is being injected by promisify
	    if (typeof opts === 'function' && typeof callback === 'function') {
	      callback = opts;
	      opts = {};
	    }

	    try {
	      path = cleanMultihash(path);
	    } catch (err) {
	      return callback(err);
	    }

	    var sendWithTransform = send.withTransform(tarStreamToObjects);

	    sendWithTransform({
	      path: 'get',
	      args: path,
	      qs: opts
	    }, callback);
	  });
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (coll, iteratee, callback) {
	    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, iteratee, callback);
	};

	var _isArrayLike = __webpack_require__(23);

	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

	var _eachOfLimit = __webpack_require__(158);

	var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

	var _doLimit = __webpack_require__(159);

	var _doLimit2 = _interopRequireDefault(_doLimit);

	var _noop = __webpack_require__(34);

	var _noop2 = _interopRequireDefault(_noop);

	var _once = __webpack_require__(306);

	var _once2 = _interopRequireDefault(_once);

	var _onlyOnce = __webpack_require__(68);

	var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = (0, _once2.default)(callback || _noop2.default);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }

	    function iteratorCallback(err) {
	        if (err) {
	            callback(err);
	        } else if (++completed === length) {
	            callback(null);
	        }
	    }

	    for (; index < length; index++) {
	        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
	    }
	}

	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);

	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	module.exports = exports['default'];

/***/ },
/* 67 */
/***/ function(module, exports) {

	"use strict";
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = once;
	function once(fn) {
	    return function () {
	        if (fn === null) return;
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	module.exports = exports['default'];

/***/ },
/* 68 */
/***/ function(module, exports) {

	"use strict";
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = onlyOnce;
	function onlyOnce(fn) {
	    return function () {
	        if (fn === null) throw new Error("Callback was already called.");
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	module.exports = exports['default'];

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var util = __webpack_require__(168);

	// Immutable block of data
	function Block(data, type) {
	  if (!data) {
	    throw new Error('Block must be constructed with data');
	  }

	  if (!(this instanceof Block)) {
	    return new Block(data);
	  }

	  if (data instanceof Buffer) {
	    this.data = data;
	  } else {
	    this.data = new Buffer(data);
	  }

	  this.key = util.hash(this.data);
	  this.type = type || 'protobuf';
	}

	Object.defineProperty(Block.prototype, 'extension', {
	  get: function get() {
	    switch (this.type) {
	      case 'protobuf':
	        return 'data';
	      case 'ipld':
	        return 'ipld';
	      default:
	        return this.type;
	    }
	  }
	});

	module.exports = Block;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var mh = __webpack_require__(24);

	// Link represents an IPFS Merkle DAG Link between Nodes.
	module.exports = function () {
	  function DAGLink(name, size, hash) {
	    _classCallCheck(this, DAGLink);

	    this.name = name;
	    this.size = size;

	    if (typeof hash === 'string') {
	      this.hash = mh.fromB58String(hash);
	    } else if (Buffer.isBuffer(hash)) {
	      this.hash = hash;
	    }
	  }

	  _createClass(DAGLink, [{
	    key: 'toJSON',
	    value: function toJSON() {
	      return {
	        Name: this.name,
	        Size: this.size,
	        Hash: mh.toB58String(this.hash)
	      };
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var hash = mh.toB58String(this.hash);
	      return 'DAGLink <' + hash + ' - name: "' + this.name + '", size: ' + this.size + '>';
	    }
	  }]);

	  return DAGLink;
	}();

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* WEBPACK VAR INJECTION */(function(__dirname) {'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var protobuf = __webpack_require__(330);
	var stable = __webpack_require__(375);
	var fs = __webpack_require__(11);
	var path = __webpack_require__(12);
	var mh = __webpack_require__(24);

	var util = __webpack_require__(72);
	var DAGLink = __webpack_require__(70);

	var proto = protobuf(fs.readFileSync(path.join(__dirname, 'merkledag.proto')));

	function linkSort(a, b) {
	  return new Buffer(a.name || '', 'ascii').compare(new Buffer(b.name || '', 'ascii'));
	}

	// Helper method to get a protobuf object equivalent
	function toProtoBuf(node) {
	  var pbn = {};

	  if (node.data && node.data.length > 0) {
	    pbn.Data = node.data;
	  } else {
	    pbn.Data = null; // new Buffer(0)
	  }

	  if (node.links.length > 0) {
	    pbn.Links = node.links.map(function (link) {
	      return {
	        Hash: link.hash,
	        Name: link.name,
	        Tsize: link.size
	      };
	    });
	  } else {
	    pbn.Links = null;
	  }

	  return pbn;
	}

	module.exports = function () {
	  function DAGNode(data, links) {
	    var _this = this;

	    _classCallCheck(this, DAGNode);

	    this._cached = null;
	    this._encoded = null;

	    this.data = data;
	    this.links = [];

	    // ensure links are instances of DAGLink
	    if (links) {
	      links.forEach(function (l) {
	        if (l.constructor && l.constructor.name === 'DAGLink') {
	          _this.links.push(l);
	        } else {
	          _this.links.push(new DAGLink(l.Name, l.Size, l.Hash));
	        }
	      });

	      stable.inplace(this.links, linkSort);
	    }
	  }

	  // copy - returns a clone of the DAGNode


	  _createClass(DAGNode, [{
	    key: 'copy',
	    value: function copy() {
	      var clone = new DAGNode();
	      if (this.data && this.data.length > 0) {
	        var buf = new Buffer(this.data.length);
	        this.data.copy(buf);
	        clone.data = buf;
	      }

	      if (this.links.length > 0) {
	        clone.links = this.links.slice();
	      }

	      return clone;
	    }

	    // addNodeLink - adds a DAGLink to this node that points to node by a name

	  }, {
	    key: 'addNodeLink',
	    value: function addNodeLink(name, node) {
	      if (typeof name !== 'string') {
	        throw new Error('first argument must be link name');
	      }
	      var link = this.makeLink(node);

	      link.name = name;
	      this.addRawLink(link);
	    }

	    // addRawLink adds a Link to this node from a DAGLink

	  }, {
	    key: 'addRawLink',
	    value: function addRawLink(link) {
	      this._encoded = null;
	      this.links.push(new DAGLink(link.name, link.size, link.hash));
	      stable.inplace(this.links, linkSort);
	    }

	    // UpdateNodeLink return a copy of the node with the link name set to point to
	    // that. If a link of the same name existed, it is replaced.
	    // TODO this would make more sense as an utility

	  }, {
	    key: 'updateNodeLink',
	    value: function updateNodeLink(name, node) {
	      var newnode = this.copy();
	      newnode.removeNodeLink(name);
	      newnode.addNodeLink(name, node);
	      return newnode;
	    }

	    // removeNodeLink removes a Link from this node based on name

	  }, {
	    key: 'removeNodeLink',
	    value: function removeNodeLink(name) {
	      this._encoded = null; // uncache
	      this.links = this.links.filter(function (link) {
	        if (link.name === name) {
	          return false;
	        } else {
	          return true;
	        }
	      });
	    }

	    // removeNodeLink removes a Link from this node based on a multihash

	  }, {
	    key: 'removeNodeLinkByHash',
	    value: function removeNodeLinkByHash(multihash) {
	      this._encoded = null; // uncache
	      this.links = this.links.filter(function (link) {
	        if (link.hash.equals(multihash)) {
	          return false;
	        } else {
	          return true;
	        }
	      });
	    }

	    // makeLink returns a DAGLink node from a DAGNode
	    // TODO: this would make more sense as an utility

	  }, {
	    key: 'makeLink',
	    value: function makeLink(node) {
	      return new DAGLink(null, node.size(), node.multihash());
	    }

	    // multihash - returns the multihash value of this DAGNode

	  }, {
	    key: 'multihash',
	    value: function multihash() {
	      this.encoded();
	      return this._cached;
	    }

	    // Size returns the total size of the data addressed by node,
	    // including the total sizes of references.

	  }, {
	    key: 'size',
	    value: function size() {
	      var buf = this.encoded();
	      if (!buf) {
	        return 0;
	      }

	      return this.links.reduce(function (sum, l) {
	        return sum + l.size;
	      }, buf.length);
	    }

	    // Encoded returns the encoded raw data version of a Node instance.
	    // It may use a cached encoded version, unless the force flag is given.

	  }, {
	    key: 'encoded',
	    value: function encoded(force) {
	      if (force || !this._encoded) {
	        this._encoded = this.marshal();

	        if (this._encoded) {
	          this._cached = util.hash(this._encoded);
	        }
	      }
	      return this._encoded;
	    }

	    // marshal - encodes the DAGNode into a probuf

	  }, {
	    key: 'marshal',
	    value: function marshal() {
	      return proto.PBNode.encode(toProtoBuf(this));
	    }

	    // unMarshal - decodes a protobuf into a DAGNode
	    // TODO: this would make more sense as an utility

	  }, {
	    key: 'unMarshal',
	    value: function unMarshal(data) {
	      var pbn = proto.PBNode.decode(data);
	      this.links = pbn.Links.map(function (link) {
	        return new DAGLink(link.Name, link.Tsize, link.Hash);
	      });

	      stable.inplace(this.links, linkSort);
	      this.data = pbn.Data || new Buffer(0);
	      return this;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return {
	        Data: this.data,
	        Links: this.links.map(function (l) {
	          return l.toJSON();
	        }),
	        Hash: mh.toB58String(this.multihash()),
	        Size: this.size()
	      };
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var hash = mh.toB58String(this.multihash());
	      return 'DAGNode <' + hash + ' - data: "' + this.data.toString() + '", links: ' + this.links.length + ', size: ' + this.size() + '>';
	    }
	  }]);

	  return DAGNode;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var multihashing = __webpack_require__(90);

	exports = module.exports;

	// Hash is the global IPFS hash function. uses multihash SHA2_256, 256 bits
	exports.hash = function (data) {
	  return multihashing(data, 'sha2-256');
	};

/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EventIndex = function () {
	  function EventIndex() {
	    _classCallCheck(this, EventIndex);

	    this._index = {};
	  }

	  _createClass(EventIndex, [{
	    key: 'get',
	    value: function get() {
	      var _this = this;

	      return Object.keys(this._index).map(function (f) {
	        return _this._index[f];
	      });
	    }
	  }, {
	    key: 'updateIndex',
	    value: function updateIndex(oplog, added) {
	      var _this2 = this;

	      added.reduce(function (handled, item) {
	        if (handled.indexOf(item.hash) === -1) {
	          handled.push(item.hash);
	          if (item.payload.op === 'ADD') _this2._index[item.hash] = item;
	        }
	        return handled;
	      }, []);
	    }
	  }]);

	  return EventIndex;
	}();

	module.exports = EventIndex;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Lazy = __webpack_require__(42);
	var Store = __webpack_require__(40);
	var EventIndex = __webpack_require__(73);

	var EventStore = function (_Store) {
	  _inherits(EventStore, _Store);

	  function EventStore(ipfs, id, dbname, options) {
	    _classCallCheck(this, EventStore);

	    if (!options) options = {};
	    if (options.Index === undefined) Object.assign(options, { Index: EventIndex });
	    return _possibleConstructorReturn(this, (EventStore.__proto__ || Object.getPrototypeOf(EventStore)).call(this, ipfs, id, dbname, options));
	  }

	  _createClass(EventStore, [{
	    key: 'add',
	    value: function add(data) {
	      return this._addOperation({
	        op: 'ADD',
	        key: null,
	        value: data,
	        meta: {
	          ts: new Date().getTime()
	        }
	      });
	    }
	  }, {
	    key: 'get',
	    value: function get(hash) {
	      return this.iterator({ gte: hash, limit: 1 }).collect()[0];
	    }
	  }, {
	    key: 'iterator',
	    value: function iterator(options) {
	      var _iterator;

	      var messages = this._query(this.dbname, options);
	      var currentIndex = 0;
	      var iterator = (_iterator = {}, _defineProperty(_iterator, Symbol.iterator, function () {
	        return this;
	      }), _defineProperty(_iterator, 'next', function next() {
	        var item = { value: null, done: true };
	        if (currentIndex < messages.length) {
	          item = { value: messages[currentIndex], done: false };
	          currentIndex++;
	        }
	        return item;
	      }), _defineProperty(_iterator, 'collect', function collect() {
	        return messages;
	      }), _iterator);

	      return iterator;
	    }
	  }, {
	    key: '_query',
	    value: function _query(dbname, opts) {
	      if (!opts) opts = {};

	      var amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided
	      var events = this._index.get();
	      var result = [];

	      if (opts.gt || opts.gte) {
	        // Greater than case
	        result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, opts.gte ? true : false);
	      } else {
	        // Lower than and lastN case, search latest first by reversing the sequence
	        result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();
	      }

	      if (opts.reverse) result.reverse();

	      return result.toArray();
	    }
	  }, {
	    key: '_read',
	    value: function _read(ops, hash, amount, inclusive) {
	      return Lazy(ops).skipWhile(function (f) {
	        return hash && f.hash !== hash;
	      }).drop(inclusive ? 0 : 1).take(amount);
	    }
	  }]);

	  return EventStore;
	}(Store);

	module.exports = EventStore;

/***/ },
/* 75 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var hexTable = function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }

	    return array;
	}();

	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (c === 0x2D || // -
	        c === 0x2E || // .
	        c === 0x5F || // _
	        c === 0x7E || // ~
	        c >= 0x30 && c <= 0x39 || // 0-9
	        c >= 0x41 && c <= 0x5A || // a-z
	        c >= 0x61 && c <= 0x7A // A-Z
	        ) {
	                out += string.charAt(i);
	                continue;
	            }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
	        out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && _typeof(obj[i]) === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Events = __webpack_require__(10);
	var Url = __webpack_require__(110);
	var Http = __webpack_require__(56);
	var Https = __webpack_require__(386);
	var Stream = __webpack_require__(3);
	var Hoek = __webpack_require__(22);
	var Boom = __webpack_require__(63);
	var Payload = __webpack_require__(77);
	var Recorder = __webpack_require__(191);
	var Tap = __webpack_require__(192);

	// Declare internals

	var internals = {
	    jsonRegex: /^application\/[a-z.+-]*json$/,
	    shallowOptions: ['agent', 'payload', 'downstreamRes', 'beforeRedirect', 'redirected'],
	    emitSymbol: Symbol.for('wreck')
	};

	process[internals.emitSymbol] = process[internals.emitSymbol] || new Events.EventEmitter();

	// new instance is exported as module.exports

	internals.Client = function (defaults) {

	    this.agents = {
	        https: new Https.Agent({ maxSockets: Infinity }),
	        http: new Http.Agent({ maxSockets: Infinity }),
	        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
	    };

	    this._defaults = defaults || {};

	    Events.EventEmitter.call(this);

	    // replay request/response events to process[Symbol.for('wreck')]
	    var self = this;
	    var selfEmit = this.emit;
	    this.emit = function () {

	        var processEmitter = process[internals.emitSymbol];
	        selfEmit.apply(self, arguments);
	        processEmitter.emit.apply(processEmitter, arguments);
	    };
	};

	Hoek.inherits(internals.Client, Events.EventEmitter);

	internals.Client.prototype.defaults = function (options) {

	    options = Hoek.applyToDefaultsWithShallow(options, this._defaults, internals.shallowOptions);
	    return new internals.Client(options);
	};

	internals.resolveUrl = function (baseUrl, path) {

	    if (!path) {
	        return baseUrl;
	    }

	    var parsedPath = Url.parse(path);
	    if (parsedPath.host && parsedPath.protocol) {
	        return Url.format(parsedPath);
	    }

	    var parsedBase = Url.parse(baseUrl);
	    parsedBase.pathname = parsedBase.pathname + parsedPath.pathname;
	    parsedBase.pathname = parsedBase.pathname.replace(/[/]{2,}/g, '/');
	    parsedBase.search = parsedPath.search; // Always use the querystring from the path argument

	    return Url.format(parsedBase);
	};

	internals.Client.prototype.request = function (method, url, options, callback, _trace) {
	    var _this = this;

	    options = Hoek.applyToDefaultsWithShallow(this._defaults, options || {}, internals.shallowOptions);

	    Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || _typeof(options.payload) === 'object', 'options.payload must be a string, a Buffer, a Stream, or an Object');

	    Hoek.assert(options.agent === undefined || options.agent === null || typeof options.rejectUnauthorized !== 'boolean', 'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');

	    Hoek.assert(options.beforeRedirect === undefined || options.beforeRedirect === null || typeof options.beforeRedirect === 'function', 'options.beforeRedirect must be a function');

	    Hoek.assert(options.redirected === undefined || options.redirected === null || typeof options.redirected === 'function', 'options.redirected must be a function');

	    options.beforeRedirect = options.beforeRedirect || function (redirectMethod, statusCode, location, resHeaders, redirectOptions, next) {
	        return next();
	    };

	    if (options.baseUrl) {
	        url = internals.resolveUrl(options.baseUrl, url);
	        delete options.baseUrl;
	    }

	    var uri = Url.parse(url);

	    if (options.socketPath) {
	        uri.socketPath = options.socketPath;
	        delete options.socketPath;
	    }

	    uri.method = method.toUpperCase();
	    uri.headers = options.headers || {};
	    var hasContentLength = Object.keys(uri.headers).some(function (key) {

	        return key.toLowerCase() === 'content-length';
	    });

	    if (options.payload && _typeof(options.payload) === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {
	        options.payload = JSON.stringify(options.payload);
	        uri.headers['content-type'] = uri.headers['content-type'] || 'application/json';
	    }

	    var payloadSupported = uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined;
	    if (payloadSupported && (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) && !hasContentLength) {

	        uri.headers = Hoek.clone(uri.headers);
	        uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
	    }

	    var redirects = options.hasOwnProperty('redirects') ? options.redirects : false; // Needed to allow 0 as valid value when passed recursively

	    _trace = _trace || [];
	    _trace.push({ method: uri.method, url: url });

	    var client = uri.protocol === 'https:' ? Https : Http;

	    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {
	        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
	    } else if (options.agent || options.agent === false) {
	        uri.agent = options.agent;
	    } else {
	        uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;
	    }

	    if (options.secureProtocol !== undefined) {
	        uri.secureProtocol = options.secureProtocol;
	    }

	    this.emit('request', uri, options);

	    var start = Date.now();
	    var req = client.request(uri);

	    var shadow = null; // A copy of the streamed request payload when redirects are enabled
	    var timeoutId = void 0;

	    var onError = function onError(err) {

	        err.trace = _trace;
	        return finishOnce(Boom.badGateway('Client request error', err));
	    };
	    req.once('error', onError);

	    var onResponse = function onResponse(res) {

	        // Pass-through response

	        var statusCode = res.statusCode;
	        var redirectMethod = internals.redirectMethod(statusCode, uri.method, options);

	        if (redirects === false || !redirectMethod) {

	            return finishOnce(null, res);
	        }

	        // Redirection

	        res.destroy();

	        if (redirects === 0) {
	            return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));
	        }

	        var location = res.headers.location;
	        if (!location) {
	            return finishOnce(Boom.badGateway('Received redirection without location', _trace));
	        }

	        if (!/^https?:/i.test(location)) {
	            location = Url.resolve(uri.href, location);
	        }

	        var redirectOptions = Hoek.cloneWithShallow(options, internals.shallowOptions);
	        redirectOptions.payload = shadow || options.payload; // shadow must be ready at this point if set
	        redirectOptions.redirects = --redirects;

	        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, function () {

	            var redirectReq = _this.request(redirectMethod, location, redirectOptions, finishOnce, _trace);

	            if (options.redirected) {
	                options.redirected(statusCode, location, redirectReq);
	            }
	        });
	    };

	    // Register handlers

	    var finish = function finish(err, res) {

	        if (err) {
	            req.abort();
	        }

	        req.removeListener('response', onResponse);
	        req.removeListener('error', onError);
	        req.on('error', Hoek.ignore);
	        clearTimeout(timeoutId);
	        _this.emit('response', err, req, res, start, uri);

	        if (callback) {
	            return callback(err, res);
	        }
	    };

	    var finishOnce = Hoek.once(finish);

	    req.once('response', onResponse);

	    if (options.timeout) {
	        timeoutId = setTimeout(function () {

	            return finishOnce(Boom.gatewayTimeout('Client request timeout'));
	        }, options.timeout);
	        delete options.timeout;
	    }

	    // Custom abort method to detect early aborts

	    var _abort = req.abort;
	    var aborted = false;
	    req.abort = function () {

	        if (!aborted && !req.res && !req.socket) {
	            process.nextTick(function () {

	                // Fake an ECONNRESET error

	                var error = new Error('socket hang up');
	                error.code = 'ECONNRESET';
	                finishOnce(error);
	            });
	        }

	        aborted = true;
	        return _abort.call(req);
	    };

	    // Write payload

	    if (payloadSupported) {
	        if (options.payload instanceof Stream) {
	            var stream = options.payload;

	            if (redirects) {
	                (function () {
	                    var collector = new Tap();
	                    collector.once('finish', function () {

	                        shadow = collector.collect();
	                    });

	                    stream = options.payload.pipe(collector);
	                })();
	            }

	            stream.pipe(req);
	            return req;
	        }

	        req.write(options.payload);
	    }

	    // Finalize request

	    req.end();

	    return req;
	};

	internals.redirectMethod = function (code, method, options) {

	    switch (code) {
	        case 301:
	        case 302:
	            return 'GET';

	        case 303:
	            if (options.redirect303) {
	                return 'GET';
	            }
	            break;

	        case 307:
	        case 308:
	            return method;
	    }

	    return null;
	};

	// read()

	internals.Client.prototype.read = function (res, options, callback) {

	    options = Hoek.applyToDefaultsWithShallow(options || {}, this._defaults, internals.shallowOptions);

	    // Set stream timeout

	    var clientTimeout = options.timeout;
	    var clientTimeoutId = null;

	    // Finish once

	    var finish = function finish(err, buffer) {

	        clearTimeout(clientTimeoutId);
	        reader.removeListener('error', onReaderError);
	        reader.removeListener('finish', onReaderFinish);
	        res.removeListener('error', onResError);
	        res.removeListener('close', onResClose);
	        res.on('error', Hoek.ignore);

	        if (err || !options.json) {

	            return callback(err, buffer);
	        }

	        // Parse JSON

	        var result = void 0;
	        if (buffer.length === 0) {
	            return callback(null, null);
	        }

	        if (options.json === 'force') {
	            result = internals.tryParseBuffer(buffer);
	            return callback(result.err, result.json);
	        }

	        // mode is "smart" or true

	        var contentType = res.headers && res.headers['content-type'] || '';
	        var mime = contentType.split(';')[0].trim().toLowerCase();

	        if (!internals.jsonRegex.test(mime)) {
	            return callback(null, buffer);
	        }

	        result = internals.tryParseBuffer(buffer);
	        return callback(result.err, result.json);
	    };

	    var finishOnce = Hoek.once(finish);

	    if (clientTimeout && clientTimeout > 0) {

	        clientTimeoutId = setTimeout(function () {

	            finishOnce(Boom.clientTimeout());
	        }, clientTimeout);
	    }

	    // Hander errors

	    var onResError = function onResError(err) {

	        return finishOnce(Boom.internal('Payload stream error', err));
	    };

	    var onResClose = function onResClose() {

	        return finishOnce(Boom.internal('Payload stream closed prematurely'));
	    };

	    res.once('error', onResError);
	    res.once('close', onResClose);

	    // Read payload

	    var reader = new Recorder({ maxBytes: options.maxBytes });

	    var onReaderError = function onReaderError(err) {

	        if (res.destroy) {
	            // GZip stream has no destroy() method
	            res.destroy();
	        }

	        return finishOnce(err);
	    };

	    reader.once('error', onReaderError);

	    var onReaderFinish = function onReaderFinish() {

	        return finishOnce(null, reader.collect());
	    };

	    reader.once('finish', onReaderFinish);

	    res.pipe(reader);
	};

	// toReadableStream()

	internals.Client.prototype.toReadableStream = function (payload, encoding) {

	    return new Payload(payload, encoding);
	};

	// parseCacheControl()

	internals.Client.prototype.parseCacheControl = function (field) {

	    /*
	        Cache-Control   = 1#cache-directive
	        cache-directive = token [ "=" ( token / quoted-string ) ]
	        token           = [^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+
	        quoted-string   = "(?:[^"\\]|\\.)*"
	    */

	    //                             1: directive                                        =   2: token                                              3: quoted-string
	    var regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;

	    var header = {};
	    var error = field.replace(regex, function ($0, $1, $2, $3) {

	        var value = $2 || $3;
	        header[$1] = value ? value.toLowerCase() : true;
	        return '';
	    });

	    if (header['max-age']) {
	        try {
	            var maxAge = parseInt(header['max-age'], 10);
	            if (isNaN(maxAge)) {
	                return null;
	            }

	            header['max-age'] = maxAge;
	        } catch (err) {}
	    }

	    return error ? null : header;
	};

	// Shortcuts

	internals.Client.prototype.get = function (uri, options, callback) {

	    return this._shortcutWrap('GET', uri, options, callback);
	};

	internals.Client.prototype.post = function (uri, options, callback) {

	    return this._shortcutWrap('POST', uri, options, callback);
	};

	internals.Client.prototype.patch = function (uri, options, callback) {

	    return this._shortcutWrap('PATCH', uri, options, callback);
	};

	internals.Client.prototype.put = function (uri, options, callback) {

	    return this._shortcutWrap('PUT', uri, options, callback);
	};

	internals.Client.prototype.delete = function (uri, options, callback) {

	    return this._shortcutWrap('DELETE', uri, options, callback);
	};

	// Wrapper so that shortcut can be optimized with required params

	internals.Client.prototype._shortcutWrap = function (method, uri /* [options], callback */) {

	    var options = typeof arguments[2] === 'function' ? {} : arguments[2];
	    var callback = typeof arguments[2] === 'function' ? arguments[2] : arguments[3];

	    return this._shortcut(method, uri, options, callback);
	};

	internals.Client.prototype._shortcut = function (method, uri, options, callback) {
	    var _this2 = this;

	    return this.request(method, uri, options, function (err, res) {

	        if (err) {
	            return callback(err);
	        }

	        _this2.read(res, options, function (err, payload) {

	            return callback(err, res, payload);
	        });
	    });
	};

	internals.tryParseBuffer = function (buffer) {

	    var result = {
	        json: null,
	        err: null
	    };
	    try {
	        var json = JSON.parse(buffer.toString());
	        result.json = json;
	    } catch (err) {
	        result.err = err;
	    }
	    return result;
	};

	module.exports = new internals.Client();

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var Hoek = __webpack_require__(22);
	var Stream = __webpack_require__(3);

	// Declare internals

	var internals = {};

	module.exports = internals.Payload = function (payload, encoding) {

	    Stream.Readable.call(this);

	    var data = [].concat(payload || '');
	    var size = 0;
	    for (var i = 0; i < data.length; ++i) {
	        var chunk = data[i];
	        size = size + chunk.length;
	        data[i] = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk);
	    }

	    this._data = Buffer.concat(data, size);
	    this._position = 0;
	    this._encoding = encoding || 'utf8';
	};

	Hoek.inherits(internals.Payload, Stream.Readable);

	internals.Payload.prototype._read = function (size) {

	    var chunk = this._data.slice(this._position, this._position + size);
	    this.push(chunk, this._encoding);
	    this._position = this._position + chunk.length;

	    if (this._position >= this._data.length) {
	        this.push(null);
	    }
	};

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var util = __webpack_require__(2);
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = __webpack_require__(13);
	var OperationalError = errors.OperationalError;
	var es5 = __webpack_require__(17);

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}

	module.exports = nodebackForPromise;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9)

	exports.createCipher = exports.Cipher = crypto.createCipher
	exports.createCipheriv = exports.Cipheriv = crypto.createCipheriv
	exports.createDecipher = exports.Decipher = crypto.createDecipher
	exports.createDecipheriv = exports.Decipheriv = crypto.createDecipheriv
	exports.listCiphers = exports.getCiphers = crypto.getCiphers


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var bn = __webpack_require__(5);
	var randomBytes = __webpack_require__(52);
	module.exports = crt;
	function blind(priv) {
	  var r = getr(priv);
	  var blinder = r.toRed(bn.mont(priv.modulus))
	  .redPow(new bn(priv.publicExponent)).fromRed();
	  return {
	    blinder: blinder,
	    unblinder:r.invm(priv.modulus)
	  };
	}
	function crt(msg, priv) {
	  var blinds = blind(priv);
	  var len = priv.modulus.byteLength();
	  var mod = bn.mont(priv.modulus);
	  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
	  var c1 = blinded.toRed(bn.mont(priv.prime1));
	  var c2 = blinded.toRed(bn.mont(priv.prime2));
	  var qinv = priv.coefficient;
	  var p = priv.prime1;
	  var q = priv.prime2;
	  var m1 = c1.redPow(priv.exponent1);
	  var m2 = c2.redPow(priv.exponent2);
	  m1 = m1.fromRed();
	  m2 = m2.fromRed();
	  var h = m1.isub(m2).imul(qinv).umod(p);
	  h.imul(q);
	  m2.iadd(h);
	  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
	}
	crt.getr = getr;
	function getr(priv) {
	  var len = priv.modulus.byteLength();
	  var r = new bn(randomBytes(len));
	  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
	    r = new bn(randomBytes(len));
	  }
	  return r;
	}


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = realpath
	realpath.realpath = realpath
	realpath.sync = realpathSync
	realpath.realpathSync = realpathSync
	realpath.monkeypatch = monkeypatch
	realpath.unmonkeypatch = unmonkeypatch

	var fs = __webpack_require__(11)
	var origRealpath = fs.realpath
	var origRealpathSync = fs.realpathSync

	var version = process.version
	var ok = /^v[0-5]\./.test(version)
	var old = __webpack_require__(260)

	function newError (er) {
	  return er && er.syscall === 'realpath' && (
	    er.code === 'ELOOP' ||
	    er.code === 'ENOMEM' ||
	    er.code === 'ENAMETOOLONG'
	  )
	}

	function realpath (p, cache, cb) {
	  if (ok) {
	    return origRealpath(p, cache, cb)
	  }

	  if (typeof cache === 'function') {
	    cb = cache
	    cache = null
	  }
	  origRealpath(p, cache, function (er, result) {
	    if (newError(er)) {
	      old.realpath(p, cache, cb)
	    } else {
	      cb(er, result)
	    }
	  })
	}

	function realpathSync (p, cache) {
	  if (ok) {
	    return origRealpathSync(p, cache)
	  }

	  try {
	    return origRealpathSync(p, cache)
	  } catch (er) {
	    if (newError(er)) {
	      return old.realpathSync(p, cache)
	    } else {
	      throw er
	    }
	  }
	}

	function monkeypatch () {
	  fs.realpath = realpath
	  fs.realpathSync = realpathSync
	}

	function unmonkeypatch () {
	  fs.realpath = origRealpath
	  fs.realpathSync = origRealpathSync
	}


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	exports.alphasort = alphasort
	exports.alphasorti = alphasorti
	exports.setopts = setopts
	exports.ownProp = ownProp
	exports.makeAbs = makeAbs
	exports.finish = finish
	exports.mark = mark
	exports.isIgnored = isIgnored
	exports.childrenIgnored = childrenIgnored

	function ownProp (obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field)
	}

	var path = __webpack_require__(12)
	var minimatch = __webpack_require__(44)
	var isAbsolute = __webpack_require__(46)
	var Minimatch = minimatch.Minimatch

	function alphasorti (a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase())
	}

	function alphasort (a, b) {
	  return a.localeCompare(b)
	}

	function setupIgnores (self, options) {
	  self.ignore = options.ignore || []

	  if (!Array.isArray(self.ignore))
	    self.ignore = [self.ignore]

	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap)
	  }
	}

	// ignore patterns are always in dot:true mode.
	function ignoreMap (pattern) {
	  var gmatcher = null
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
	    gmatcher = new Minimatch(gpattern, { dot: true })
	  }

	  return {
	    matcher: new Minimatch(pattern, { dot: true }),
	    gmatcher: gmatcher
	  }
	}

	function setopts (self, pattern, options) {
	  if (!options)
	    options = {}

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  self.silent = !!options.silent
	  self.pattern = pattern
	  self.strict = options.strict !== false
	  self.realpath = !!options.realpath
	  self.realpathCache = options.realpathCache || Object.create(null)
	  self.follow = !!options.follow
	  self.dot = !!options.dot
	  self.mark = !!options.mark
	  self.nodir = !!options.nodir
	  if (self.nodir)
	    self.mark = true
	  self.sync = !!options.sync
	  self.nounique = !!options.nounique
	  self.nonull = !!options.nonull
	  self.nosort = !!options.nosort
	  self.nocase = !!options.nocase
	  self.stat = !!options.stat
	  self.noprocess = !!options.noprocess

	  self.maxLength = options.maxLength || Infinity
	  self.cache = options.cache || Object.create(null)
	  self.statCache = options.statCache || Object.create(null)
	  self.symlinks = options.symlinks || Object.create(null)

	  setupIgnores(self, options)

	  self.changedCwd = false
	  var cwd = process.cwd()
	  if (!ownProp(options, "cwd"))
	    self.cwd = cwd
	  else {
	    self.cwd = path.resolve(options.cwd)
	    self.changedCwd = self.cwd !== cwd
	  }

	  self.root = options.root || path.resolve(self.cwd, "/")
	  self.root = path.resolve(self.root)
	  if (process.platform === "win32")
	    self.root = self.root.replace(/\\/g, "/")

	  self.cwdAbs = makeAbs(self, self.cwd)
	  self.nomount = !!options.nomount

	  // disable comments and negation in Minimatch.
	  // Note that they are not supported in Glob itself anyway.
	  options.nonegate = true
	  options.nocomment = true

	  self.minimatch = new Minimatch(pattern, options)
	  self.options = self.minimatch.options
	}

	function finish (self) {
	  var nou = self.nounique
	  var all = nou ? [] : Object.create(null)

	  for (var i = 0, l = self.matches.length; i < l; i ++) {
	    var matches = self.matches[i]
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i]
	        if (nou)
	          all.push(literal)
	        else
	          all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou)
	        all.push.apply(all, m)
	      else
	        m.forEach(function (m) {
	          all[m] = true
	        })
	    }
	  }

	  if (!nou)
	    all = Object.keys(all)

	  if (!self.nosort)
	    all = all.sort(self.nocase ? alphasorti : alphasort)

	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i])
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        var notDir = !(/\/$/.test(e))
	        var c = self.cache[e] || self.cache[makeAbs(self, e)]
	        if (notDir && c)
	          notDir = c !== 'DIR' && !Array.isArray(c)
	        return notDir
	      })
	    }
	  }

	  if (self.ignore.length)
	    all = all.filter(function(m) {
	      return !isIgnored(self, m)
	    })

	  self.found = all
	}

	function mark (self, p) {
	  var abs = makeAbs(self, p)
	  var c = self.cache[abs]
	  var m = p
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c)
	    var slash = p.slice(-1) === '/'

	    if (isDir && !slash)
	      m += '/'
	    else if (!isDir && slash)
	      m = m.slice(0, -1)

	    if (m !== p) {
	      var mabs = makeAbs(self, m)
	      self.statCache[mabs] = self.statCache[abs]
	      self.cache[mabs] = self.cache[abs]
	    }
	  }

	  return m
	}

	// lotta situps...
	function makeAbs (self, f) {
	  var abs = f
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f)
	  } else if (isAbsolute(f) || f === '') {
	    abs = f
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f)
	  } else {
	    abs = path.resolve(f)
	  }

	  if (process.platform === 'win32')
	    abs = abs.replace(/\\/g, '/')

	  return abs
	}


	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	function childrenIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.

	module.exports = glob

	var fs = __webpack_require__(11)
	var rp = __webpack_require__(81)
	var minimatch = __webpack_require__(44)
	var Minimatch = minimatch.Minimatch
	var inherits = __webpack_require__(1)
	var EE = __webpack_require__(10).EventEmitter
	var path = __webpack_require__(12)
	var assert = __webpack_require__(55)
	var isAbsolute = __webpack_require__(46)
	var globSync = __webpack_require__(263)
	var common = __webpack_require__(82)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var inflight = __webpack_require__(273)
	var util = __webpack_require__(4)
	var childrenIgnored = common.childrenIgnored
	var isIgnored = common.isIgnored

	var once = __webpack_require__(93)

	function glob (pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {}
	  if (!options) options = {}

	  if (options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return globSync(pattern, options)
	  }

	  return new Glob(pattern, options, cb)
	}

	glob.sync = globSync
	var GlobSync = glob.GlobSync = globSync.GlobSync

	// old api surface
	glob.glob = glob

	function extend (origin, add) {
	  if (add === null || typeof add !== 'object') {
	    return origin
	  }

	  var keys = Object.keys(add)
	  var i = keys.length
	  while (i--) {
	    origin[keys[i]] = add[keys[i]]
	  }
	  return origin
	}

	glob.hasMagic = function (pattern, options_) {
	  var options = extend({}, options_)
	  options.noprocess = true

	  var g = new Glob(pattern, options)
	  var set = g.minimatch.set

	  if (!pattern)
	    return false

	  if (set.length > 1)
	    return true

	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string')
	      return true
	  }

	  return false
	}

	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = null
	  }

	  if (options && options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return new GlobSync(pattern, options)
	  }

	  if (!(this instanceof Glob))
	    return new Glob(pattern, options, cb)

	  setopts(this, pattern, options)
	  this._didRealPath = false

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  if (typeof cb === 'function') {
	    cb = once(cb)
	    this.on('error', cb)
	    this.on('end', function (matches) {
	      cb(null, matches)
	    })
	  }

	  var self = this
	  var n = this.minimatch.set.length
	  this._processing = 0
	  this.matches = new Array(n)

	  this._emitQueue = []
	  this._processQueue = []
	  this.paused = false

	  if (this.noprocess)
	    return this

	  if (n === 0)
	    return done()

	  var sync = true
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false, done)
	  }
	  sync = false

	  function done () {
	    --self._processing
	    if (self._processing <= 0) {
	      if (sync) {
	        process.nextTick(function () {
	          self._finish()
	        })
	      } else {
	        self._finish()
	      }
	    }
	  }
	}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)
	  if (this.aborted)
	    return

	  if (this.realpath && !this._didRealpath)
	    return this._realpath()

	  common.finish(this)
	  this.emit('end', this.found)
	}

	Glob.prototype._realpath = function () {
	  if (this._didRealpath)
	    return

	  this._didRealpath = true

	  var n = this.matches.length
	  if (n === 0)
	    return this._finish()

	  var self = this
	  for (var i = 0; i < this.matches.length; i++)
	    this._realpathSet(i, next)

	  function next () {
	    if (--n === 0)
	      self._finish()
	  }
	}

	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index]
	  if (!matchset)
	    return cb()

	  var found = Object.keys(matchset)
	  var self = this
	  var n = found.length

	  if (n === 0)
	    return cb()

	  var set = this.matches[index] = Object.create(null)
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p)
	    rp.realpath(p, self.realpathCache, function (er, real) {
	      if (!er)
	        set[real] = true
	      else if (er.syscall === 'stat')
	        set[p] = true
	      else
	        self.emit('error', er) // srsly wtf right here

	      if (--n === 0) {
	        self.matches[index] = set
	        cb()
	      }
	    })
	  })
	}

	Glob.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit('abort')
	}

	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true
	    this.emit('pause')
	  }
	}

	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume')
	    this.paused = false
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0)
	      this._emitQueue.length = 0
	      for (var i = 0; i < eq.length; i ++) {
	        var e = eq[i]
	        this._emitMatch(e[0], e[1])
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0)
	      this._processQueue.length = 0
	      for (var i = 0; i < pq.length; i ++) {
	        var p = pq[i]
	        this._processing--
	        this._process(p[0], p[1], p[2], p[3])
	      }
	    }
	  }
	}

	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob)
	  assert(typeof cb === 'function')

	  if (this.aborted)
	    return

	  this._processing++
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb])
	    return
	  }

	  //console.error('PROCESS %d', this._processing, pattern)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip _processing
	  if (childrenIgnored(this, read))
	    return cb()

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
	}

	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}

	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return cb()

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return cb()

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this._emitMatch(index, e)
	    }
	    // This was the last one, and no stats were needed
	    return cb()
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix) {
	      if (prefix !== '/')
	        e = prefix + '/' + e
	      else
	        e = prefix + e
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb)
	  }
	  cb()
	}

	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted)
	    return

	  if (this.matches[index][e])
	    return

	  if (isIgnored(this, e))
	    return

	  if (this.paused) {
	    this._emitQueue.push([index, e])
	    return
	  }

	  var abs = this._makeAbs(e)

	  if (this.nodir) {
	    var c = this.cache[abs]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  if (this.mark)
	    e = this._mark(e)

	  this.matches[index][e] = true

	  var st = this.statCache[abs]
	  if (st)
	    this.emit('stat', e, st)

	  this.emit('match', e)
	}

	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted)
	    return

	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false, cb)

	  var lstatkey = 'lstat\0' + abs
	  var self = this
	  var lstatcb = inflight(lstatkey, lstatcb_)

	  if (lstatcb)
	    fs.lstat(abs, lstatcb)

	  function lstatcb_ (er, lstat) {
	    if (er)
	      return cb()

	    var isSym = lstat.isSymbolicLink()
	    self.symlinks[abs] = isSym

	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE'
	      cb()
	    } else
	      self._readdir(abs, false, cb)
	  }
	}

	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted)
	    return

	  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
	  if (!cb)
	    return

	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs, cb)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return cb()

	    if (Array.isArray(c))
	      return cb(null, c)
	  }

	  var self = this
	  fs.readdir(abs, readdirCb(this, abs, cb))
	}

	function readdirCb (self, abs, cb) {
	  return function (er, entries) {
	    if (er)
	      self._readdirError(abs, er, cb)
	    else
	      self._readdirEntries(abs, entries, cb)
	  }
	}

	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted)
	    return

	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries
	  return cb(null, entries)
	}

	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted)
	    return

	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      var abs = this._makeAbs(f)
	      this.cache[abs] = 'FILE'
	      if (abs === this.cwdAbs) {
	        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
	        error.path = this.cwd
	        error.code = er.code
	        this.emit('error', error)
	        this.abort()
	      }
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) {
	        this.emit('error', er)
	        // If the error is handled, then we abort
	        // if not, we threw out of here
	        this.abort()
	      }
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }

	  return cb()
	}

	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}


	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return cb()

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb)

	  var isSym = this.symlinks[abs]
	  var len = entries.length

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return cb()

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true, cb)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true, cb)
	  }

	  cb()
	}

	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb)
	  })
	}
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

	  //console.error('ps2', prefix, exists)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return cb()

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this._emitMatch(index, prefix)
	  cb()
	}

	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return cb()

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return cb(null, c)

	    if (needDir && c === 'FILE')
	      return cb()

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (stat !== undefined) {
	    if (stat === false)
	      return cb(null, stat)
	    else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE'
	      if (needDir && type === 'FILE')
	        return cb()
	      else
	        return cb(null, type, stat)
	    }
	  }

	  var self = this
	  var statcb = inflight('stat\0' + abs, lstatcb_)
	  if (statcb)
	    fs.lstat(abs, statcb)

	  function lstatcb_ (er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er)
	          self._stat2(f, abs, null, lstat, cb)
	        else
	          self._stat2(f, abs, er, stat, cb)
	      })
	    } else {
	      self._stat2(f, abs, er, lstat, cb)
	    }
	  }
	}

	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false
	    return cb()
	  }

	  var needDir = f.slice(-1) === '/'
	  this.statCache[abs] = stat

	  if (abs.slice(-1) === '/' && !stat.isDirectory())
	    return cb(null, false, stat)

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return cb()

	  return cb(null, c, stat)
	}


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var fs = __webpack_require__(11)

	module.exports = clone(fs)

	function clone (obj) {
	  if (obj === null || typeof obj !== 'object')
	    return obj

	  if (obj instanceof Object)
	    var copy = { __proto__: obj.__proto__ }
	  else
	    var copy = Object.create(null)

	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
	  })

	  return copy
	}


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var base58 = __webpack_require__(18);
	var multihash = __webpack_require__(24);

	var urlPattern = /^https?:\/\/[^\/]+\/(ip(f|n)s)\/((\w+).*)/;
	var pathPattern = /^\/(ip(f|n)s)\/((\w+).*)/;

	function isMultihash(hash) {
	  var formatted = convertToString(hash);
	  try {
	    var buffer = new Buffer(base58.decode(formatted));
	    multihash.decode(buffer);
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function isIpfs(input, pattern) {
	  var formatted = convertToString(input);
	  if (!formatted) {
	    return false;
	  }

	  var match = formatted.match(pattern);
	  if (!match) {
	    return false;
	  }

	  if (match[1] !== 'ipfs') {
	    return false;
	  }

	  var hash = match[4];
	  return isMultihash(hash);
	}

	function isIpns(input, pattern) {
	  var formatted = convertToString(input);
	  if (!formatted) {
	    return false;
	  }
	  var match = formatted.match(pattern);
	  if (!match) {
	    return false;
	  }

	  if (match[1] !== 'ipns') {
	    return false;
	  }

	  return true;
	}

	function convertToString(input) {
	  if (Buffer.isBuffer(input)) {
	    return base58.encode(input);
	  }

	  if (typeof input === 'string') {
	    return input;
	  }

	  return false;
	}

	module.exports = {
	  multihash: isMultihash,
	  ipfsUrl: function ipfsUrl(url) {
	    return isIpfs(url, urlPattern);
	  },
	  ipnsUrl: function ipnsUrl(url) {
	    return isIpns(url, urlPattern);
	  },
	  url: function url(_url) {
	    return isIpfs(_url, urlPattern) || isIpns(_url, urlPattern);
	  },
	  urlPattern: urlPattern,
	  ipfsPath: function ipfsPath(path) {
	    return isIpfs(path, pathPattern);
	  },
	  ipnsPath: function ipnsPath(path) {
	    return isIpns(path, pathPattern);
	  },
	  path: function path(_path) {
	    return isIpfs(_path, pathPattern) || isIpns(_path, pathPattern);
	  },
	  pathPattern: pathPattern,
	  urlOrPath: function urlOrPath(x) {
	    return isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern);
	  }
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 87 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(308);

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	module.exports = toInteger;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var map = __webpack_require__(43);
	var extend = __webpack_require__(35);
	var codec = __webpack_require__(311);
	var protocols = __webpack_require__(45);
	var NotImplemented = new Error('Sorry, Not Implemented Yet.');
	var varint = __webpack_require__(28);

	exports = module.exports = Multiaddr;

	function Multiaddr(addr) {
	  if (!(this instanceof Multiaddr)) {
	    return new Multiaddr(addr);
	  }

	  // defaults
	  if (!addr) {
	    addr = '';
	  }

	  if (addr instanceof Buffer) {
	    this.buffer = codec.fromBuffer(addr);
	  } else if (typeof addr === 'string' || addr instanceof String) {
	    this.buffer = codec.fromString(addr);
	  } else if (addr.buffer && addr.protos && addr.protoCodes) {
	    // Multiaddr
	    this.buffer = codec.fromBuffer(addr.buffer); // validate + copy buffer
	  } else {
	    throw new Error('addr must be a string, Buffer, or another Multiaddr');
	  }
	}

	// get the multiaddr protocols
	Multiaddr.prototype.toString = function toString() {
	  return codec.bufferToString(this.buffer);
	};

	// get the multiaddr as a convinent options object to be dropped in net.createConnection
	Multiaddr.prototype.toOptions = function toOptions() {
	  var opts = {};
	  var parsed = this.toString().split('/');
	  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';
	  opts.host = parsed[2];
	  opts.port = parsed[4];
	  return opts;
	};

	// get the multiaddr protocols
	Multiaddr.prototype.inspect = function inspect() {
	  return '<Multiaddr ' + this.buffer.toString('hex') + ' - ' + codec.bufferToString(this.buffer) + '>';
	};

	// get the multiaddr protocols
	Multiaddr.prototype.protos = function protos() {
	  return map(this.protoCodes(), function (code) {
	    return extend(protocols(code));
	    // copy to prevent users from modifying the internal objs.
	  });
	};

	// get the multiaddr protocol codes
	Multiaddr.prototype.protoCodes = function protoCodes() {
	  var codes = [];
	  var buf = this.buffer;
	  var i = 0;
	  while (i < buf.length) {
	    var code = varint.decode(buf, i);
	    var n = varint.decode.bytes;

	    var p = protocols(code);
	    var size = codec.sizeForAddr(p, buf.slice(i + n));

	    i += size + n;
	    codes.push(code);
	  }

	  return codes;
	};

	// get the multiaddr protocol string names
	Multiaddr.prototype.protoNames = function protoNames() {
	  return map(this.protos(), function (proto) {
	    return proto.name;
	  });
	};

	// Returns a tuple of parts:
	Multiaddr.prototype.tuples = function tuples() {
	  return codec.bufferToTuples(this.buffer);
	};

	// Returns a tuple of string parts:
	Multiaddr.prototype.stringTuples = function stringTuples() {
	  var t = codec.bufferToTuples(this.buffer);
	  return codec.tuplesToStringTuples(t);
	};

	Multiaddr.prototype.encapsulate = function encapsulate(addr) {
	  addr = Multiaddr(addr);
	  return Multiaddr(this.toString() + addr.toString());
	};

	Multiaddr.prototype.decapsulate = function decapsulate(addr) {
	  addr = addr.toString();
	  var s = this.toString();
	  var i = s.lastIndexOf(addr);
	  if (i < 0) {
	    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);
	  }
	  return Multiaddr(s.slice(0, i));
	};

	Multiaddr.prototype.equals = function equals(addr) {
	  return this.buffer.equals(addr.buffer);
	};

	// get a node friendly address object
	Multiaddr.prototype.nodeAddress = function nodeAddress() {
	  if (!this.isThinWaistAddress()) {
	    throw new Error('Multiaddr must be "thin waist" address for nodeAddress.');
	  }

	  var codes = this.protoCodes();
	  var parts = this.toString().split('/').slice(1);
	  return {
	    family: codes[0] === 41 ? 'IPv6' : 'IPv4',
	    address: parts[1], // ip addr
	    port: parts[3] // tcp or udp port
	  };
	};

	// from a node friendly address object
	Multiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {
	  if (!addr) throw new Error('requires node address object');
	  if (!transport) throw new Error('requires transport protocol');
	  var ip = addr.family === 'IPv6' ? 'ip6' : 'ip4';
	  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));
	};

	// returns whether this address is a standard combination:
	// /{IPv4, IPv6}/{TCP, UDP}
	Multiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {
	  var protos = (addr || this).protos();

	  if (protos.length !== 2) {
	    return false;
	  }

	  if (protos[0].code !== 4 && protos[0].code !== 41) {
	    return false;
	  }
	  if (protos[1].code !== 6 && protos[1].code !== 17) {
	    return false;
	  }
	  return true;
	};

	// parses the "stupid string" format:
	// <proto><IPv>://<IP Addr>[:<proto port>]
	// udp4://1.2.3.4:5678
	Multiaddr.prototype.fromStupidString = function fromStupidString(str) {
	  throw NotImplemented;
	};

	// patch this in
	Multiaddr.protocols = protocols;

	Multiaddr.isMultiaddr = function isMultiaddr(addr) {
	  if (addr.constructor && addr.constructor.name) {
	    return addr.constructor.name === 'Multiaddr';
	  }

	  return Boolean(addr.fromStupidString && addr.protos);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var multihash = __webpack_require__(24);
	var crypto = __webpack_require__(384);

	var mh = module.exports = Multihashing;

	mh.Buffer = Buffer; // for browser things

	function Multihashing(buf, func, length) {
	  return multihash.encode(mh.digest(buf, func, length), func, length);
	}

	// expose multihash itself, to avoid silly double requires.
	mh.multihash = multihash;

	mh.digest = function (buf, func, length) {
	  var digest = mh.createHash(func).update(buf).digest();

	  if (length) {
	    digest = digest.slice(0, length);
	  }

	  return digest;
	};

	mh.createHash = function (func, length) {
	  func = multihash.coerceCode(func);
	  if (!mh.functions[func]) {
	    throw new Error('multihash function ' + func + ' not yet supported');
	  }

	  return mh.functions[func]();
	};

	mh.functions = {
	  0x11: gsha1,
	  0x12: gsha2_256,
	  0x13: gsha2_512
	  // 0x14: gsha3 // not implemented yet
	  // 0x40: blake2b, // not implemented yet
	  // 0x41: blake2s, // not implemented yet
	};

	function gsha1() {
	  return crypto.createHash('sha1');
	}

	function gsha2_256() {
	  return crypto.createHash('sha256');
	}

	function gsha2_512() {
	  return crypto.createHash('sha512');
	}

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var through = __webpack_require__(320)
	var split = __webpack_require__(368)
	var EOL = __webpack_require__(57).EOL

	module.exports = parse
	module.exports.serialize = module.exports.stringify = serialize
	module.exports.parse = parse

	function parse (opts) {
	  opts = opts || {}
	  opts.strict = opts.strict !== false

	  function parseRow (row) {
	    try {
	      if (row) return JSON.parse(row)
	    } catch (e) {
	      if (opts.strict) {
	        this.emit('error', new Error('Could not parse row ' + row.slice(0, 50) + '...'))
	      }
	    }
	  }

	  return split(parseRow)
	}

	function serialize (opts) {
	  return through.obj(opts, function(obj, enc, cb) {
	    cb(null, JSON.stringify(obj) + EOL)
	  })
	}


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var Readable = __webpack_require__(316);
	var Writable = __webpack_require__(318);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(54)
	module.exports = wrappy(once)
	module.exports.strict = wrappy(onceStrict)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  var name = fn.name || 'Function wrapped with `once`'
	  f.onceError = name + " shouldn't be called more than once"
	  f.called = false
	  return f
	}


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var asn1 = __webpack_require__(322)
	var aesid = __webpack_require__(283)
	var fixProc = __webpack_require__(323)
	var ciphers = __webpack_require__(79)
	var compat = __webpack_require__(95)
	module.exports = parseKeys

	function parseKeys (buffer) {
	  var password
	  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
	    password = buffer.passphrase
	    buffer = buffer.key
	  }
	  if (typeof buffer === 'string') {
	    buffer = new Buffer(buffer)
	  }

	  var stripped = fixProc(buffer, password)

	  var type = stripped.tag
	  var data = stripped.data
	  var subtype, ndata
	  switch (type) {
	    case 'PUBLIC KEY':
	      ndata = asn1.PublicKey.decode(data, 'der')
	      subtype = ndata.algorithm.algorithm.join('.')
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
	        case '1.2.840.10045.2.1':
	          ndata.subjectPrivateKey = ndata.subjectPublicKey
	          return {
	            type: 'ec',
	            data: ndata
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
	          return {
	            type: 'dsa',
	            data: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'ENCRYPTED PRIVATE KEY':
	      data = asn1.EncryptedPrivateKey.decode(data, 'der')
	      data = decrypt(data, password)
	      // falls through
	    case 'PRIVATE KEY':
	      ndata = asn1.PrivateKey.decode(data, 'der')
	      subtype = ndata.algorithm.algorithm.join('.')
	      switch (subtype) {
	        case '1.2.840.113549.1.1.1':
	          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
	        case '1.2.840.10045.2.1':
	          return {
	            curve: ndata.algorithm.curve,
	            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
	          }
	        case '1.2.840.10040.4.1':
	          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
	          return {
	            type: 'dsa',
	            params: ndata.algorithm.params
	          }
	        default: throw new Error('unknown key id ' + subtype)
	      }
	      throw new Error('unknown key type ' + type)
	    case 'RSA PUBLIC KEY':
	      return asn1.RSAPublicKey.decode(data, 'der')
	    case 'RSA PRIVATE KEY':
	      return asn1.RSAPrivateKey.decode(data, 'der')
	    case 'DSA PRIVATE KEY':
	      return {
	        type: 'dsa',
	        params: asn1.DSAPrivateKey.decode(data, 'der')
	      }
	    case 'EC PRIVATE KEY':
	      data = asn1.ECPrivateKey.decode(data, 'der')
	      return {
	        curve: data.parameters.value,
	        privateKey: data.privateKey
	      }
	    default: throw new Error('unknown key type ' + type)
	  }
	}
	parseKeys.signature = asn1.signature
	function decrypt (data, password) {
	  var salt = data.algorithm.decrypt.kde.kdeparams.salt
	  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
	  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
	  var iv = data.algorithm.decrypt.cipher.iv
	  var cipherText = data.subjectPrivateKey
	  var keylen = parseInt(algo.split('-')[1], 10) / 8
	  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
	  var cipher = ciphers.createDecipheriv(algo, key, iv)
	  var out = []
	  out.push(cipher.update(cipherText))
	  out.push(cipher.final())
	  return Buffer.concat(out)
	}


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9)

	exports.pbkdf2Sync = crypto.pbkdf2Sync
	exports.pbkdf2 = crypto.pbkdf2


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var createHash = __webpack_require__(32);
	module.exports = function (seed, len) {
	  var t = new Buffer('');
	  var  i = 0, c;
	  while (t.length < len) {
	    c = i2ops(i++);
	    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
	  }
	  return t.slice(0, len);
	};

	function i2ops(c) {
	  var out = new Buffer(4);
	  out.writeUInt32BE(c,0);
	  return out;
	}

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var bn = __webpack_require__(5);
	function withPublic(paddedMsg, key) {
	  return new Buffer(paddedMsg
	    .toRed(bn.mont(key.modulus))
	    .redPow(new bn(key.publicExponent))
	    .fromRed()
	    .toArray());
	}

	module.exports = withPublic;

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = function xor(a, b) {
	  var len = a.length;
	  var i = -1;
	  while (++i < len) {
	    a[i] ^= b[i];
	  }
	  return a
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'
	var abortCb = __webpack_require__(101)

	module.exports = function once (value, onAbort) {
	  return function (abort, cb) {
	    if(abort)
	      return abortCb(cb, abort, onAbort)
	    if(value != null) {
	      var _value = value; value = null
	      cb(null, _value)
	    } else
	      cb(true)
	  }
	}




/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	function id (e) { return e }
	var prop = __webpack_require__(26)
	var filter = __webpack_require__(51)

	//drop items you have already seen.
	module.exports = function unique (field, invert) {
	  field = prop(field) || id
	  var seen = {}
	  return filter(function (data) {
	    var key = field(data)
	    if(seen[key]) return !!invert //false, by default
	    else seen[key] = true
	    return !invert //true by default
	  })
	}



/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = function abortCb(cb, abort, onAbort) {
	  cb(abort)
	  onAbort && onAbort(abort === true ? null: abort)
	  return
	}



/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var prop = __webpack_require__(26)

	function id (e) { return e }

	module.exports = function tester (test) {
	  return (
	    'object' === typeof test && 'function' === typeof test.test //regexp
	    ? function (data) { return test.test(data) }
	    : prop (test) || id
	  )
	}


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(47);
	/*</replacement>*/

	/*<replacement>*/
	var isArray = __webpack_require__(278);
	/*</replacement>*/

	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(10);

	/*<replacement>*/
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(3);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(10).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(6).Buffer;

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = __webpack_require__(4);
	var debug = undefined;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	var Duplex;
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(15);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(19).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	var Duplex;
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(15);

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(19).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended) return 0;

	  if (state.objectMode) return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
	  }

	  if (n <= 0) return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else {
	      return state.length;
	    }
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended) state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && !this._readableState.endEmitted) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0) return null;

	  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode) ret = '';else ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(15);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(47);
	/*</replacement>*/

	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/

	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(380)
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(3);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(10).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(6).Buffer;

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	var Duplex;
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(15);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // create the two objects needed to store the corked requests
	  // they are not a linked list, as no new elements are inserted in there
	  this.corkedRequestsFree = new CorkedRequest(this);
	  this.corkedRequestsFree.next = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();

	var Duplex;
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(15);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;

	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    state.corkedRequestsFree = holder.next;
	    holder.next = null;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = bindActor
	function bindActor () {
	  var args = 
	        Array.prototype.slice.call
	        (arguments) // jswtf.
	    , obj = null
	    , fn
	  if (typeof args[0] === "object") {
	    obj = args.shift()
	    fn = args.shift()
	    if (typeof fn === "string")
	      fn = obj[ fn ]
	  } else fn = args.shift()
	  return function (cb) {
	    fn.apply(obj, args.concat(cb)) }
	}


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var Readable = __webpack_require__(370);
	var Writable = __webpack_require__(372);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 108 */
/***/ function(module, exports) {

	var ZEROS = '0000000000000000000'
	var ZERO_OFFSET = '0'.charCodeAt(0)
	var USTAR = 'ustar\x0000'
	var MASK = parseInt('7777', 8)

	var clamp = function (index, len, defaultValue) {
	  if (typeof index !== 'number') return defaultValue
	  index = ~~index  // Coerce to integer.
	  if (index >= len) return len
	  if (index >= 0) return index
	  index += len
	  if (index >= 0) return index
	  return 0
	}

	var toType = function (flag) {
	  switch (flag) {
	    case 0:
	      return 'file'
	    case 1:
	      return 'link'
	    case 2:
	      return 'symlink'
	    case 3:
	      return 'character-device'
	    case 4:
	      return 'block-device'
	    case 5:
	      return 'directory'
	    case 6:
	      return 'fifo'
	    case 7:
	      return 'contiguous-file'
	    case 72:
	      return 'pax-header'
	    case 55:
	      return 'pax-global-header'
	    case 27:
	      return 'gnu-long-link-path'
	    case 28:
	    case 30:
	      return 'gnu-long-path'
	  }

	  return null
	}

	var toTypeflag = function (flag) {
	  switch (flag) {
	    case 'file':
	      return 0
	    case 'link':
	      return 1
	    case 'symlink':
	      return 2
	    case 'character-device':
	      return 3
	    case 'block-device':
	      return 4
	    case 'directory':
	      return 5
	    case 'fifo':
	      return 6
	    case 'contiguous-file':
	      return 7
	    case 'pax-header':
	      return 72
	  }

	  return 0
	}

	var alloc = function (size) {
	  var buf = new Buffer(size)
	  buf.fill(0)
	  return buf
	}

	var indexOf = function (block, num, offset, end) {
	  for (; offset < end; offset++) {
	    if (block[offset] === num) return offset
	  }
	  return end
	}

	var cksum = function (block) {
	  var sum = 8 * 32
	  for (var i = 0; i < 148; i++) sum += block[i]
	  for (var j = 156; j < 512; j++) sum += block[j]
	  return sum
	}

	var encodeOct = function (val, n) {
	  val = val.toString(8)
	  return ZEROS.slice(0, n - val.length) + val + ' '
	}

	/* Copied from the node-tar repo and modified to meet
	 * tar-stream coding standard.
	 *
	 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
	 */
	function parse256 (buf) {
	  // first byte MUST be either 80 or FF
	  // 80 for positive, FF for 2's comp
	  var positive
	  if (buf[0] === 0x80) positive = true
	  else if (buf[0] === 0xFF) positive = false
	  else return null

	  // build up a base-256 tuple from the least sig to the highest
	  var zero = false
	  var tuple = []
	  for (var i = buf.length - 1; i > 0; i--) {
	    var byte = buf[i]
	    if (positive) tuple.push(byte)
	    else if (zero && byte === 0) tuple.push(0)
	    else if (zero) {
	      zero = false
	      tuple.push(0x100 - byte)
	    } else tuple.push(0xFF - byte)
	  }

	  var sum = 0
	  var l = tuple.length
	  for (i = 0; i < l; i++) {
	    sum += tuple[i] * Math.pow(256, i)
	  }

	  return positive ? sum : -1 * sum
	}

	var decodeOct = function (val, offset) {
	  // If prefixed with 0x80 then parse as a base-256 integer
	  if (val[offset] & 0x80) {
	    return parse256(val.slice(offset, offset + 8))
	  } else {
	    // Older versions of tar can prefix with spaces
	    while (offset < val.length && val[offset] === 32) offset++
	    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
	    while (offset < end && val[offset] === 0) offset++
	    if (end === offset) return 0
	    return parseInt(val.slice(offset, end).toString(), 8)
	  }
	}

	var decodeStr = function (val, offset, length) {
	  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString()
	}

	var addLength = function (str) {
	  var len = Buffer.byteLength(str)
	  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1
	  if (len + digits > Math.pow(10, digits)) digits++

	  return (len + digits) + str
	}

	exports.decodeLongPath = function (buf) {
	  return decodeStr(buf, 0, buf.length)
	}

	exports.encodePax = function (opts) { // TODO: encode more stuff in pax
	  var result = ''
	  if (opts.name) result += addLength(' path=' + opts.name + '\n')
	  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
	  var pax = opts.pax
	  if (pax) {
	    for (var key in pax) {
	      result += addLength(' ' + key + '=' + pax[key] + '\n')
	    }
	  }
	  return new Buffer(result)
	}

	exports.decodePax = function (buf) {
	  var result = {}

	  while (buf.length) {
	    var i = 0
	    while (i < buf.length && buf[i] !== 32) i++
	    var len = parseInt(buf.slice(0, i).toString(), 10)
	    if (!len) return result

	    var b = buf.slice(i + 1, len - 1).toString()
	    var keyIndex = b.indexOf('=')
	    if (keyIndex === -1) return result
	    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

	    buf = buf.slice(len)
	  }

	  return result
	}

	exports.encode = function (opts) {
	  var buf = alloc(512)
	  var name = opts.name
	  var prefix = ''

	  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
	  if (Buffer.byteLength(name) !== name.length) return null // utf-8

	  while (Buffer.byteLength(name) > 100) {
	    var i = name.indexOf('/')
	    if (i === -1) return null
	    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
	    name = name.slice(i + 1)
	  }

	  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
	  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

	  buf.write(name)
	  buf.write(encodeOct(opts.mode & MASK, 6), 100)
	  buf.write(encodeOct(opts.uid, 6), 108)
	  buf.write(encodeOct(opts.gid, 6), 116)
	  buf.write(encodeOct(opts.size, 11), 124)
	  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

	  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

	  if (opts.linkname) buf.write(opts.linkname, 157)

	  buf.write(USTAR, 257)
	  if (opts.uname) buf.write(opts.uname, 265)
	  if (opts.gname) buf.write(opts.gname, 297)
	  buf.write(encodeOct(opts.devmajor || 0, 6), 329)
	  buf.write(encodeOct(opts.devminor || 0, 6), 337)

	  if (prefix) buf.write(prefix, 345)

	  buf.write(encodeOct(cksum(buf), 6), 148)

	  return buf
	}

	exports.decode = function (buf) {
	  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET

	  var name = decodeStr(buf, 0, 100)
	  var mode = decodeOct(buf, 100)
	  var uid = decodeOct(buf, 108)
	  var gid = decodeOct(buf, 116)
	  var size = decodeOct(buf, 124)
	  var mtime = decodeOct(buf, 136)
	  var type = toType(typeflag)
	  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100)
	  var uname = decodeStr(buf, 265, 32)
	  var gname = decodeStr(buf, 297, 32)
	  var devmajor = decodeOct(buf, 329)
	  var devminor = decodeOct(buf, 337)

	  if (buf[345]) name = decodeStr(buf, 345, 155) + '/' + name

	  // to support old tar versions that use trailing / to indicate dirs
	  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

	  var c = cksum(buf)

	  // checksum is still initial value if header was null.
	  if (c === 8 * 32) return null

	  // valid checksum
	  if (c !== decodeOct(buf, 148)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

	  return {
	    name: name,
	    mode: mode,
	    uid: uid,
	    gid: gid,
	    size: size,
	    mtime: new Date(1000 * mtime),
	    type: type,
	    linkname: linkname,
	    uname: uname,
	    gname: gname,
	    devmajor: devmajor,
	    devminor: devminor
	  }
	}


/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = require("constants");

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Post = __webpack_require__(16);
	var TextPost = __webpack_require__(177);
	var FilePost = __webpack_require__(173);
	var DirectoryPost = __webpack_require__(172);
	var OrbitDBItem = __webpack_require__(175);
	var MetaInfo = __webpack_require__(174);
	var Poll = __webpack_require__(176);
	var Crypto = __webpack_require__(36);

	var PostTypes = {
	  Message: TextPost,
	  Snippet: "snippet",
	  File: FilePost,
	  Directory: DirectoryPost,
	  Link: "link",
	  OrbitDBItem: OrbitDBItem,
	  Poll: Poll
	};

	// Factory

	var Posts = function () {
	  function Posts() {
	    _classCallCheck(this, Posts);
	  }

	  _createClass(Posts, null, [{
	    key: 'create',
	    value: function create(ipfs, type, data, keys) {
	      return new Promise(function (resolve, reject) {
	        var post = void 0;

	        if (type === PostTypes.Message) {
	          post = new PostTypes.Message(data.content, data.replyto);
	        } else if (type === PostTypes.File) {
	          post = new PostTypes.File(data.name, data.hash, data.size, data.meta);
	        } else if (type == PostTypes.Directory) {
	          post = new PostTypes.Directory(data.name, data.hash, data.size);
	        } else if (type == PostTypes.OrbitDBItem) {
	          post = new PostTypes.OrbitDBItem(data.operation, data.key, data.value);
	        } else if (type == PostTypes.Poll) {
	          post = new PostTypes.Poll(data.question, data.options);
	        }

	        var size = data.size ? data.size : Buffer.byteLength(data, 'utf8');
	        post.meta = Object.assign(post.meta || {}, new MetaInfo(post.type, size, new Date().getTime(), data.from));
	        if (post.type) delete post.type;

	        var sign = function sign(key) {
	          var result = {};
	          if (key) {
	            return Crypto.sign(key.privateKey, new Buffer(JSON.stringify(post))).then(function (signature) {
	              return result.signature = signature;
	            }).then(function () {
	              return Crypto.exportKeyToIpfs(ipfs, key.publicKey);
	            }).then(function (hash) {
	              return result.signKeyHash = hash;
	            }).then(function () {
	              return result;
	            });
	          }
	          return result;
	        };

	        sign(keys).then(function (result) {
	          if (result.signKeyHash && result.signature) {
	            post.sig = result.signature;
	            post.signKey = result.signKeyHash;
	          }
	        }).then(function () {
	          return ipfs.object.put(new Buffer(JSON.stringify(post)));
	        }).then(function (res) {
	          return resolve({ Post: post, Hash: res.toJSON().Hash });
	        }).catch(reject);
	      });
	    }
	  }, {
	    key: 'Types',
	    get: function get() {
	      return PostTypes;
	    }
	  }]);

	  return Posts;
	}();

	module.exports = Posts;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EventEmitter = __webpack_require__(10).EventEmitter;
	var Logger = __webpack_require__(20);
	var logger = Logger.create("orbit-db", { color: Logger.Colors.Magenta });
	var EventStore = __webpack_require__(74);
	var FeedStore = __webpack_require__(181);
	var KeyValueStore = __webpack_require__(183);
	var CounterStore = __webpack_require__(179);
	var Pubsub = __webpack_require__(184);
	var Cache = __webpack_require__(187);

	var OrbitDB = function () {
	  function OrbitDB(ipfs, id, options) {
	    _classCallCheck(this, OrbitDB);

	    this._ipfs = ipfs;
	    this._pubsub = options && options.broker ? new options.broker(ipfs) : new Pubsub(ipfs);
	    this.user = { id: id };
	    this.network = { name: 'Orbit PUBSUB Network' };
	    this.events = new EventEmitter();
	    this.stores = {};
	  }

	  /* Databases */


	  _createClass(OrbitDB, [{
	    key: 'feed',
	    value: function feed(dbname, options) {
	      return this._createStore(FeedStore, dbname, options);
	    }
	  }, {
	    key: 'eventlog',
	    value: function eventlog(dbname, options) {
	      return this._createStore(EventStore, dbname, options);
	    }
	  }, {
	    key: 'kvstore',
	    value: function kvstore(dbname, options) {
	      return this._createStore(KeyValueStore, dbname, options);
	    }
	  }, {
	    key: 'counter',
	    value: function counter(dbname, options) {
	      return this._createStore(CounterStore, dbname, options);
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      var _this = this;

	      if (this._pubsub) this._pubsub.disconnect();
	      this.events.removeAllListeners('data');
	      Object.keys(this.stores).map(function (e) {
	        return _this.stores[e];
	      }).forEach(function (store) {
	        store.events.removeAllListeners('data');
	        store.events.removeAllListeners('write');
	        store.events.removeAllListeners('close');
	      });
	      this.stores = {};
	      this.user = null;
	      this.network = null;
	    }
	  }, {
	    key: '_createStore',
	    value: function _createStore(Store, dbname) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? { subscribe: true } : arguments[2];

	      // if(!options) options = {};
	      // const replicate = options.subscribe !== undefined ? options.subscribe : true;
	      var store = new Store(this._ipfs, this.user.id, dbname, options);
	      this.stores[dbname] = store;
	      return this._subscribe(store, dbname, options.subscribe, options);
	    }
	  }, {
	    key: '_subscribe',
	    value: function _subscribe(store, dbname) {
	      var subscribe = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	      var options = arguments[3];

	      // if(subscribe === undefined) subscribe = true
	      store.events.on('data', this._onData.bind(this));
	      store.events.on('write', this._onWrite.bind(this));
	      store.events.on('close', this._onClose.bind(this));

	      if (subscribe && this._pubsub) this._pubsub.subscribe(dbname, this._onMessage.bind(this), this._onConnected.bind(this), store.options.maxHistory > 0);else store.loadHistory().catch(function (e) {
	        return logger.error(e.stack);
	      });

	      Cache.loadCache(options.cacheFile).then(function () {
	        var hash = Cache.get(dbname);
	        store.loadHistory(hash).catch(function (e) {
	          return logger.error(e.stack);
	        });
	      });

	      return store;
	    }

	    /* Connected to the message broker */

	  }, {
	    key: '_onConnected',
	    value: function _onConnected(dbname, hash) {
	      // console.log(".CONNECTED", dbname, hash);
	      var store = this.stores[dbname];
	      store.loadHistory(hash).catch(function (e) {
	        return logger.error(e.stack);
	      });
	    }

	    /* Replication request from the message broker */

	  }, {
	    key: '_onMessage',
	    value: function _onMessage(dbname, hash) {
	      // console.log(".MESSAGE", dbname, hash, this.stores)
	      var store = this.stores[dbname];
	      store.sync(hash).then(function (res) {
	        return Cache.set(dbname, hash);
	      }).catch(function (e) {
	        return logger.error(e.stack);
	      });
	    }

	    /* Data events */

	  }, {
	    key: '_onWrite',
	    value: function _onWrite(dbname, hash) {
	      // 'New entry written to database...', after adding a new db entry locally
	      // console.log(".WRITE", dbname, hash, this.user.username)
	      if (!hash) throw new Error("Hash can't be null!");
	      if (this._pubsub) this._pubsub.publish(dbname, hash);
	      Cache.set(dbname, hash);
	    }
	  }, {
	    key: '_onData',
	    value: function _onData(dbname, item) {
	      // 'New database entry...', after a new entry was added to the database
	      // console.log(".SYNCED", dbname, items.length);
	      this.events.emit('data', dbname, item);
	    }
	  }, {
	    key: '_onClose',
	    value: function _onClose(dbname) {
	      if (this._pubsub) this._pubsub.unsubscribe(dbname);
	      delete this.stores[dbname];
	    }
	  }, {
	    key: '_connect',
	    value: function _connect(hash, username, password, allowOffline) {
	      var _this2 = this;

	      if (allowOffline === undefined) allowOffline = false;

	      var readNetworkInfo = function readNetworkInfo(hash) {
	        return new Promise(function (resolve, reject) {
	          resolve(JSON.stringify({
	            name: 'Orbit DEV Network',
	            publishers: [hash]
	          }));
	        });
	      };

	      var host = void 0,
	          port = void 0,
	          name = void 0;
	      return readNetworkInfo(hash).then(function (object) {
	        _this2.network = JSON.parse(object);
	        name = _this2.network.name;
	        host = _this2.network.publishers[0].split(":")[0];
	        port = _this2.network.publishers[0].split(":")[1];
	      }).then(function () {
	        logger.debug('Connecting to network ' + hash + ' (' + host + ':' + port + ')');
	        return _this2._pubsub.connect(host, port, username, password);
	      }).then(function () {
	        logger.debug('Connected to network ' + hash + ' (' + host + ':' + port + ')');
	        _this2.user = { username: username, id: username }; // TODO: user id from ipfs hash
	        return;
	      }).catch(function (e) {
	        logger.warn('Couldn\'t connect to ' + hash + ' network: ' + e.message);
	        if (!allowOffline) {
	          logger.debug('\'allowOffline\' set to false, terminating');
	          if (_this2._pubsub) _this2._pubsub.disconnect();
	          throw e;
	        }
	        _this2.user = { username: username, id: username }; // TODO: user id from ipfs hash
	        return;
	      });
	    }
	  }]);

	  return OrbitDB;
	}();

	var OrbitClientFactory = function () {
	  function OrbitClientFactory() {
	    _classCallCheck(this, OrbitClientFactory);
	  }

	  _createClass(OrbitClientFactory, null, [{
	    key: 'connect',
	    value: function connect(host, username, password, ipfs) {
	      var options = arguments.length <= 4 || arguments[4] === undefined ? { allowOffline: false } : arguments[4];

	      // if(!options) options = { allowOffline: false };
	      if (!ipfs) {
	        logger.error("IPFS instance not provided");
	        throw new Error("IPFS instance not provided");
	      }

	      var client = new OrbitDB(ipfs, options);
	      client.user = { username: username, id: username }; // TODO: user id from ipfs hash
	      return Promise.resolve(client);
	      // return client._connect(host, username, password, options.allowOffline)
	      //   .then(() => client)
	    }
	  }]);

	  return OrbitClientFactory;
	}();

	module.exports = OrbitDB;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var OrbitIdentifyProvider = __webpack_require__(194);
	// const uPortIdentifyProvider = require('./identityprovider-uport')

	var enabledProviders = [OrbitIdentifyProvider];

	var identityProviders = {};
	enabledProviders.forEach(function (p) {
	  identityProviders[p.id] = p;
	});

	var IdentityProviders = function () {
	  function IdentityProviders() {
	    _classCallCheck(this, IdentityProviders);
	  }

	  _createClass(IdentityProviders, null, [{
	    key: 'authorizeUser',
	    value: function authorizeUser(ipfs) {
	      var credentials = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (!credentials.provider) throw new Error("'provider' not specified");
	      var provider = identityProviders[credentials.provider];
	      if (!provider) throw new Error('Provider \'' + credentials.provider + '\' not found');
	      return provider.authorize(ipfs, credentials);
	    }
	  }, {
	    key: 'loadProfile',
	    value: function loadProfile(ipfs) {
	      var profile = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (!profile.identityProvider) throw new Error('\'identityProvider\' not specified');
	      if (!profile.identityProvider.provider) throw new Error('\'provider\' not specified');
	      var provider = identityProviders[profile.identityProvider.provider];
	      if (!provider) throw new Error('Provider \'' + profile.identityProvider.provider + '\' not found');
	      return provider.load(ipfs, profile);
	    }
	  }]);

	  return IdentityProviders;
	}();

	module.exports = IdentityProviders;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var events = __webpack_require__(10)
	var inherits = __webpack_require__(1)

	module.exports = LRU

	function LRU (opts) {
	  if (!(this instanceof LRU)) return new LRU(opts)
	  if (typeof opts === 'number') opts = {max: opts}
	  if (!opts) opts = {}
	  events.EventEmitter.call(this)
	  this.cache = {}
	  this.head = this.tail = null
	  this.length = 0
	  this.max = opts.max || 1000
	  this.maxAge = opts.maxAge || 0
	}

	inherits(LRU, events.EventEmitter)

	Object.defineProperty(LRU.prototype, 'keys', {
	  get: function () { return Object.keys(this.cache) }
	})

	LRU.prototype.clear = function () {
	  this.cache = {}
	  this.head = this.tail = null
	  this.length = 0
	}

	LRU.prototype.remove = function (key) {
	  if (typeof key !== 'string') key = '' + key
	  if (!this.cache.hasOwnProperty(key)) return

	  var element = this.cache[key]
	  delete this.cache[key]
	  this._unlink(key, element.prev, element.next)
	  return element.value
	}

	LRU.prototype._unlink = function (key, prev, next) {
	  this.length--

	  if (this.length === 0) {
	    this.head = this.tail = null
	  } else {
	    if (this.head === key) {
	      this.head = prev
	      this.cache[this.head].next = null
	    } else if (this.tail === key) {
	      this.tail = next
	      this.cache[this.tail].prev = null
	    } else {
	      this.cache[prev].next = next
	      this.cache[next].prev = prev
	    }
	  }
	}

	LRU.prototype.peek = function (key) {
	  if (!this.cache.hasOwnProperty(key)) return

	  var element = this.cache[key]

	  if (!this._checkAge(key, element)) return
	  return element.value
	}

	LRU.prototype.set = function (key, value) {
	  if (typeof key !== 'string') key = '' + key

	  var element

	  if (this.cache.hasOwnProperty(key)) {
	    element = this.cache[key]
	    element.value = value
	    if (this.maxAge) element.modified = Date.now()

	    // If it's already the head, there's nothing more to do:
	    if (key === this.head) return value
	    this._unlink(key, element.prev, element.next)
	  } else {
	    element = {value: value, modified: 0, next: null, prev: null}
	    if (this.maxAge) element.modified = Date.now()
	    this.cache[key] = element

	    // Eviction is only possible if the key didn't already exist:
	    if (this.length === this.max) this.evict()
	  }

	  this.length++
	  element.next = null
	  element.prev = this.head

	  if (this.head) this.cache[this.head].next = key
	  this.head = key

	  if (!this.tail) this.tail = key
	  return value
	}

	LRU.prototype._checkAge = function (key, element) {
	  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {
	    this.remove(key)
	    this.emit('evict', {key: key, value: element.value})
	    return false
	  }
	  return true
	}

	LRU.prototype.get = function (key) {
	  if (typeof key !== 'string') key = '' + key
	  if (!this.cache.hasOwnProperty(key)) return

	  var element = this.cache[key]

	  if (!this._checkAge(key, element)) return

	  if (this.head !== key) {
	    if (key === this.tail) {
	      this.tail = element.next
	      this.cache[this.tail].prev = null
	    } else {
	      // Set prev.next -> element.next:
	      this.cache[element.prev].next = element.next
	    }

	    // Set element.next.prev -> element.prev:
	    this.cache[element.next].prev = element.prev

	    // Element is the new head
	    this.cache[this.head].next = key
	    element.prev = this.head
	    element.next = null
	    this.head = key
	  }

	  return element.value
	}

	LRU.prototype.evict = function () {
	  if (!this.tail) return
	  var key = this.tail
	  var value = this.remove(this.tail)
	  this.emit('evict', {key: key, value: value})
	}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var asn1 = __webpack_require__(29);
	var inherits = __webpack_require__(1);

	var api = exports;

	api.define = function define(name, body) {
	  return new Entity(name, body);
	};

	function Entity(name, body) {
	  this.name = name;
	  this.body = body;

	  this.decoders = {};
	  this.encoders = {};
	};

	Entity.prototype._createNamed = function createNamed(base) {
	  var named;
	  try {
	    named = __webpack_require__(388).runInThisContext(
	      '(function ' + this.name + '(entity) {\n' +
	      '  this._initNamed(entity);\n' +
	      '})'
	    );
	  } catch (e) {
	    named = function (entity) {
	      this._initNamed(entity);
	    };
	  }
	  inherits(named, base);
	  named.prototype._initNamed = function initnamed(entity) {
	    base.call(this, entity);
	  };

	  return new named(this);
	};

	Entity.prototype._getDecoder = function _getDecoder(enc) {
	  enc = enc || 'der';
	  // Lazily create decoder
	  if (!this.decoders.hasOwnProperty(enc))
	    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
	  return this.decoders[enc];
	};

	Entity.prototype.decode = function decode(data, enc, options) {
	  return this._getDecoder(enc).decode(data, options);
	};

	Entity.prototype._getEncoder = function _getEncoder(enc) {
	  enc = enc || 'der';
	  // Lazily create encoder
	  if (!this.encoders.hasOwnProperty(enc))
	    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
	  return this.encoders[enc];
	};

	Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
	  return this._getEncoder(enc).encode(data, reporter);
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var Reporter = __webpack_require__(21).Reporter;
	var EncoderBuffer = __webpack_require__(21).EncoderBuffer;
	var DecoderBuffer = __webpack_require__(21).DecoderBuffer;
	var assert = __webpack_require__(310);

	// Supported tags
	var tags = [
	  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
	  'gentime', 'utctime', 'null_', 'enum', 'int',
	  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
	  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
	];

	// Public methods list
	var methods = [
	  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
	  'any', 'contains'
	].concat(tags);

	// Overrided methods list
	var overrided = [
	  '_peekTag', '_decodeTag', '_use',
	  '_decodeStr', '_decodeObjid', '_decodeTime',
	  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

	  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
	  '_encodeNull', '_encodeInt', '_encodeBool'
	];

	function Node(enc, parent) {
	  var state = {};
	  this._baseState = state;

	  state.enc = enc;

	  state.parent = parent || null;
	  state.children = null;

	  // State
	  state.tag = null;
	  state.args = null;
	  state.reverseArgs = null;
	  state.choice = null;
	  state.optional = false;
	  state.any = false;
	  state.obj = false;
	  state.use = null;
	  state.useDecoder = null;
	  state.key = null;
	  state['default'] = null;
	  state.explicit = null;
	  state.implicit = null;
	  state.contains = null;

	  // Should create new instance on each method
	  if (!state.parent) {
	    state.children = [];
	    this._wrap();
	  }
	}
	module.exports = Node;

	var stateProps = [
	  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
	  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
	  'implicit', 'contains'
	];

	Node.prototype.clone = function clone() {
	  var state = this._baseState;
	  var cstate = {};
	  stateProps.forEach(function(prop) {
	    cstate[prop] = state[prop];
	  });
	  var res = new this.constructor(cstate.parent);
	  res._baseState = cstate;
	  return res;
	};

	Node.prototype._wrap = function wrap() {
	  var state = this._baseState;
	  methods.forEach(function(method) {
	    this[method] = function _wrappedMethod() {
	      var clone = new this.constructor(this);
	      state.children.push(clone);
	      return clone[method].apply(clone, arguments);
	    };
	  }, this);
	};

	Node.prototype._init = function init(body) {
	  var state = this._baseState;

	  assert(state.parent === null);
	  body.call(this);

	  // Filter children
	  state.children = state.children.filter(function(child) {
	    return child._baseState.parent === this;
	  }, this);
	  assert.equal(state.children.length, 1, 'Root node can have only one child');
	};

	Node.prototype._useArgs = function useArgs(args) {
	  var state = this._baseState;

	  // Filter children and args
	  var children = args.filter(function(arg) {
	    return arg instanceof this.constructor;
	  }, this);
	  args = args.filter(function(arg) {
	    return !(arg instanceof this.constructor);
	  }, this);

	  if (children.length !== 0) {
	    assert(state.children === null);
	    state.children = children;

	    // Replace parent to maintain backward link
	    children.forEach(function(child) {
	      child._baseState.parent = this;
	    }, this);
	  }
	  if (args.length !== 0) {
	    assert(state.args === null);
	    state.args = args;
	    state.reverseArgs = args.map(function(arg) {
	      if (typeof arg !== 'object' || arg.constructor !== Object)
	        return arg;

	      var res = {};
	      Object.keys(arg).forEach(function(key) {
	        if (key == (key | 0))
	          key |= 0;
	        var value = arg[key];
	        res[value] = key;
	      });
	      return res;
	    });
	  }
	};

	//
	// Overrided methods
	//

	overrided.forEach(function(method) {
	  Node.prototype[method] = function _overrided() {
	    var state = this._baseState;
	    throw new Error(method + ' not implemented for encoding: ' + state.enc);
	  };
	});

	//
	// Public methods
	//

	tags.forEach(function(tag) {
	  Node.prototype[tag] = function _tagMethod() {
	    var state = this._baseState;
	    var args = Array.prototype.slice.call(arguments);

	    assert(state.tag === null);
	    state.tag = tag;

	    this._useArgs(args);

	    return this;
	  };
	});

	Node.prototype.use = function use(item) {
	  var state = this._baseState;

	  assert(state.use === null);
	  state.use = item;

	  return this;
	};

	Node.prototype.optional = function optional() {
	  var state = this._baseState;

	  state.optional = true;

	  return this;
	};

	Node.prototype.def = function def(val) {
	  var state = this._baseState;

	  assert(state['default'] === null);
	  state['default'] = val;
	  state.optional = true;

	  return this;
	};

	Node.prototype.explicit = function explicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.explicit = num;

	  return this;
	};

	Node.prototype.implicit = function implicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.implicit = num;

	  return this;
	};

	Node.prototype.obj = function obj() {
	  var state = this._baseState;
	  var args = Array.prototype.slice.call(arguments);

	  state.obj = true;

	  if (args.length !== 0)
	    this._useArgs(args);

	  return this;
	};

	Node.prototype.key = function key(newKey) {
	  var state = this._baseState;

	  assert(state.key === null);
	  state.key = newKey;

	  return this;
	};

	Node.prototype.any = function any() {
	  var state = this._baseState;

	  state.any = true;

	  return this;
	};

	Node.prototype.choice = function choice(obj) {
	  var state = this._baseState;

	  assert(state.choice === null);
	  state.choice = obj;
	  this._useArgs(Object.keys(obj).map(function(key) {
	    return obj[key];
	  }));

	  return this;
	};

	Node.prototype.contains = function contains(item) {
	  var state = this._baseState;

	  assert(state.use === null);
	  state.contains = item;

	  return this;
	};

	//
	// Decoding
	//

	Node.prototype._decode = function decode(input, options) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return input.wrapResult(state.children[0]._decode(input, options));

	  var result = state['default'];
	  var present = true;

	  var prevKey = null;
	  if (state.key !== null)
	    prevKey = input.enterKey(state.key);

	  // Check if tag is there
	  if (state.optional) {
	    var tag = null;
	    if (state.explicit !== null)
	      tag = state.explicit;
	    else if (state.implicit !== null)
	      tag = state.implicit;
	    else if (state.tag !== null)
	      tag = state.tag;

	    if (tag === null && !state.any) {
	      // Trial and Error
	      var save = input.save();
	      try {
	        if (state.choice === null)
	          this._decodeGeneric(state.tag, input, options);
	        else
	          this._decodeChoice(input, options);
	        present = true;
	      } catch (e) {
	        present = false;
	      }
	      input.restore(save);
	    } else {
	      present = this._peekTag(input, tag, state.any);

	      if (input.isError(present))
	        return present;
	    }
	  }

	  // Push object on stack
	  var prevObj;
	  if (state.obj && present)
	    prevObj = input.enterObject();

	  if (present) {
	    // Unwrap explicit values
	    if (state.explicit !== null) {
	      var explicit = this._decodeTag(input, state.explicit);
	      if (input.isError(explicit))
	        return explicit;
	      input = explicit;
	    }

	    var start = input.offset;

	    // Unwrap implicit and normal values
	    if (state.use === null && state.choice === null) {
	      if (state.any)
	        var save = input.save();
	      var body = this._decodeTag(
	        input,
	        state.implicit !== null ? state.implicit : state.tag,
	        state.any
	      );
	      if (input.isError(body))
	        return body;

	      if (state.any)
	        result = input.raw(save);
	      else
	        input = body;
	    }

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), start, input.length, 'tagged');

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), input.offset, input.length, 'content');

	    // Select proper method for tag
	    if (state.any)
	      result = result;
	    else if (state.choice === null)
	      result = this._decodeGeneric(state.tag, input, options);
	    else
	      result = this._decodeChoice(input, options);

	    if (input.isError(result))
	      return result;

	    // Decode children
	    if (!state.any && state.choice === null && state.children !== null) {
	      state.children.forEach(function decodeChildren(child) {
	        // NOTE: We are ignoring errors here, to let parser continue with other
	        // parts of encoded data
	        child._decode(input, options);
	      });
	    }

	    // Decode contained/encoded by schema, only in bit or octet strings
	    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
	      var data = new DecoderBuffer(result);
	      result = this._getUse(state.contains, input._reporterState.obj)
	          ._decode(data, options);
	    }
	  }

	  // Pop object
	  if (state.obj && present)
	    result = input.leaveObject(prevObj);

	  // Set key
	  if (state.key !== null && (result !== null || present === true))
	    input.leaveKey(prevKey, state.key, result);
	  else if (prevKey !== null)
	    input.exitKey(prevKey);

	  return result;
	};

	Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
	  var state = this._baseState;

	  if (tag === 'seq' || tag === 'set')
	    return null;
	  if (tag === 'seqof' || tag === 'setof')
	    return this._decodeList(input, tag, state.args[0], options);
	  else if (/str$/.test(tag))
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'objid' && state.args)
	    return this._decodeObjid(input, state.args[0], state.args[1], options);
	  else if (tag === 'objid')
	    return this._decodeObjid(input, null, null, options);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._decodeTime(input, tag, options);
	  else if (tag === 'null_')
	    return this._decodeNull(input, options);
	  else if (tag === 'bool')
	    return this._decodeBool(input, options);
	  else if (tag === 'int' || tag === 'enum')
	    return this._decodeInt(input, state.args && state.args[0], options);

	  if (state.use !== null) {
	    return this._getUse(state.use, input._reporterState.obj)
	        ._decode(input, options);
	  } else {
	    return input.error('unknown tag: ' + tag);
	  }
	};

	Node.prototype._getUse = function _getUse(entity, obj) {

	  var state = this._baseState;
	  // Create altered use decoder if implicit is set
	  state.useDecoder = this._use(entity, obj);
	  assert(state.useDecoder._baseState.parent === null);
	  state.useDecoder = state.useDecoder._baseState.children[0];
	  if (state.implicit !== state.useDecoder._baseState.implicit) {
	    state.useDecoder = state.useDecoder.clone();
	    state.useDecoder._baseState.implicit = state.implicit;
	  }
	  return state.useDecoder;
	};

	Node.prototype._decodeChoice = function decodeChoice(input, options) {
	  var state = this._baseState;
	  var result = null;
	  var match = false;

	  Object.keys(state.choice).some(function(key) {
	    var save = input.save();
	    var node = state.choice[key];
	    try {
	      var value = node._decode(input, options);
	      if (input.isError(value))
	        return false;

	      result = { type: key, value: value };
	      match = true;
	    } catch (e) {
	      input.restore(save);
	      return false;
	    }
	    return true;
	  }, this);

	  if (!match)
	    return input.error('Choice not matched');

	  return result;
	};

	//
	// Encoding
	//

	Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
	  return new EncoderBuffer(data, this.reporter);
	};

	Node.prototype._encode = function encode(data, reporter, parent) {
	  var state = this._baseState;
	  if (state['default'] !== null && state['default'] === data)
	    return;

	  var result = this._encodeValue(data, reporter, parent);
	  if (result === undefined)
	    return;

	  if (this._skipDefault(result, reporter, parent))
	    return;

	  return result;
	};

	Node.prototype._encodeValue = function encode(data, reporter, parent) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return state.children[0]._encode(data, reporter || new Reporter());

	  var result = null;

	  // Set reporter to share it with a child class
	  this.reporter = reporter;

	  // Check if data is there
	  if (state.optional && data === undefined) {
	    if (state['default'] !== null)
	      data = state['default']
	    else
	      return;
	  }

	  // Encode children first
	  var content = null;
	  var primitive = false;
	  if (state.any) {
	    // Anything that was given is translated to buffer
	    result = this._createEncoderBuffer(data);
	  } else if (state.choice) {
	    result = this._encodeChoice(data, reporter);
	  } else if (state.contains) {
	    content = this._getUse(state.contains, parent)._encode(data, reporter);
	    primitive = true;
	  } else if (state.children) {
	    content = state.children.map(function(child) {
	      if (child._baseState.tag === 'null_')
	        return child._encode(null, reporter, data);

	      if (child._baseState.key === null)
	        return reporter.error('Child should have a key');
	      var prevKey = reporter.enterKey(child._baseState.key);

	      if (typeof data !== 'object')
	        return reporter.error('Child expected, but input is not object');

	      var res = child._encode(data[child._baseState.key], reporter, data);
	      reporter.leaveKey(prevKey);

	      return res;
	    }, this).filter(function(child) {
	      return child;
	    });
	    content = this._createEncoderBuffer(content);
	  } else {
	    if (state.tag === 'seqof' || state.tag === 'setof') {
	      // TODO(indutny): this should be thrown on DSL level
	      if (!(state.args && state.args.length === 1))
	        return reporter.error('Too many args for : ' + state.tag);

	      if (!Array.isArray(data))
	        return reporter.error('seqof/setof, but data is not Array');

	      var child = this.clone();
	      child._baseState.implicit = null;
	      content = this._createEncoderBuffer(data.map(function(item) {
	        var state = this._baseState;

	        return this._getUse(state.args[0], data)._encode(item, reporter);
	      }, child));
	    } else if (state.use !== null) {
	      result = this._getUse(state.use, parent)._encode(data, reporter);
	    } else {
	      content = this._encodePrimitive(state.tag, data);
	      primitive = true;
	    }
	  }

	  // Encode data itself
	  var result;
	  if (!state.any && state.choice === null) {
	    var tag = state.implicit !== null ? state.implicit : state.tag;
	    var cls = state.implicit === null ? 'universal' : 'context';

	    if (tag === null) {
	      if (state.use === null)
	        reporter.error('Tag could be ommited only for .use()');
	    } else {
	      if (state.use === null)
	        result = this._encodeComposite(tag, primitive, cls, content);
	    }
	  }

	  // Wrap in explicit
	  if (state.explicit !== null)
	    result = this._encodeComposite(state.explicit, false, 'context', result);

	  return result;
	};

	Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
	  var state = this._baseState;

	  var node = state.choice[data.type];
	  if (!node) {
	    assert(
	        false,
	        data.type + ' not found in ' +
	            JSON.stringify(Object.keys(state.choice)));
	  }
	  return node._encode(data.value, reporter);
	};

	Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
	  var state = this._baseState;

	  if (/str$/.test(tag))
	    return this._encodeStr(data, tag);
	  else if (tag === 'objid' && state.args)
	    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._encodeObjid(data, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._encodeTime(data, tag);
	  else if (tag === 'null_')
	    return this._encodeNull();
	  else if (tag === 'int' || tag === 'enum')
	    return this._encodeInt(data, state.args && state.reverseArgs[0]);
	  else if (tag === 'bool')
	    return this._encodeBool(data);
	  else
	    throw new Error('Unsupported tag: ' + tag);
	};

	Node.prototype._isNumstr = function isNumstr(str) {
	  return /^[0-9 ]*$/.test(str);
	};

	Node.prototype._isPrintstr = function isPrintstr(str) {
	  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);

	function Reporter(options) {
	  this._reporterState = {
	    obj: null,
	    path: [],
	    options: options || {},
	    errors: []
	  };
	}
	exports.Reporter = Reporter;

	Reporter.prototype.isError = function isError(obj) {
	  return obj instanceof ReporterError;
	};

	Reporter.prototype.save = function save() {
	  var state = this._reporterState;

	  return { obj: state.obj, pathLen: state.path.length };
	};

	Reporter.prototype.restore = function restore(data) {
	  var state = this._reporterState;

	  state.obj = data.obj;
	  state.path = state.path.slice(0, data.pathLen);
	};

	Reporter.prototype.enterKey = function enterKey(key) {
	  return this._reporterState.path.push(key);
	};

	Reporter.prototype.exitKey = function exitKey(index) {
	  var state = this._reporterState;

	  state.path = state.path.slice(0, index - 1);
	};

	Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
	  var state = this._reporterState;

	  this.exitKey(index);
	  if (state.obj !== null)
	    state.obj[key] = value;
	};

	Reporter.prototype.path = function path() {
	  return this._reporterState.path.join('/');
	};

	Reporter.prototype.enterObject = function enterObject() {
	  var state = this._reporterState;

	  var prev = state.obj;
	  state.obj = {};
	  return prev;
	};

	Reporter.prototype.leaveObject = function leaveObject(prev) {
	  var state = this._reporterState;

	  var now = state.obj;
	  state.obj = prev;
	  return now;
	};

	Reporter.prototype.error = function error(msg) {
	  var err;
	  var state = this._reporterState;

	  var inherited = msg instanceof ReporterError;
	  if (inherited) {
	    err = msg;
	  } else {
	    err = new ReporterError(state.path.map(function(elem) {
	      return '[' + JSON.stringify(elem) + ']';
	    }).join(''), msg.message || msg, msg.stack);
	  }

	  if (!state.options.partial)
	    throw err;

	  if (!inherited)
	    state.errors.push(err);

	  return err;
	};

	Reporter.prototype.wrapResult = function wrapResult(result) {
	  var state = this._reporterState;
	  if (!state.options.partial)
	    return result;

	  return {
	    result: this.isError(result) ? null : result,
	    errors: state.errors
	  };
	};

	function ReporterError(path, msg) {
	  this.path = path;
	  this.rethrow(msg);
	};
	inherits(ReporterError, Error);

	ReporterError.prototype.rethrow = function rethrow(msg) {
	  this.message = msg + ' at: ' + (this.path || '(shallow)');
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, ReporterError);

	  if (!this.stack) {
	    try {
	      // IE only adds stack when thrown
	      throw new Error(this.message);
	    } catch (e) {
	      this.stack = e.stack;
	    }
	  }
	  return this;
	};


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(60);

	exports.tagClass = {
	  0: 'universal',
	  1: 'application',
	  2: 'context',
	  3: 'private'
	};
	exports.tagClassByName = constants._reverse(exports.tagClass);

	exports.tag = {
	  0x00: 'end',
	  0x01: 'bool',
	  0x02: 'int',
	  0x03: 'bitstr',
	  0x04: 'octstr',
	  0x05: 'null_',
	  0x06: 'objid',
	  0x07: 'objDesc',
	  0x08: 'external',
	  0x09: 'real',
	  0x0a: 'enum',
	  0x0b: 'embed',
	  0x0c: 'utf8str',
	  0x0d: 'relativeOid',
	  0x10: 'seq',
	  0x11: 'set',
	  0x12: 'numstr',
	  0x13: 'printstr',
	  0x14: 't61str',
	  0x15: 'videostr',
	  0x16: 'ia5str',
	  0x17: 'utctime',
	  0x18: 'gentime',
	  0x19: 'graphstr',
	  0x1a: 'iso646str',
	  0x1b: 'genstr',
	  0x1c: 'unistr',
	  0x1d: 'charstr',
	  0x1e: 'bmpstr'
	};
	exports.tagByName = constants._reverse(exports.tag);


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var decoders = exports;

	decoders.der = __webpack_require__(61);
	decoders.pem = __webpack_require__(120);


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);
	var Buffer = __webpack_require__(6).Buffer;

	var DERDecoder = __webpack_require__(61);

	function PEMDecoder(entity) {
	  DERDecoder.call(this, entity);
	  this.enc = 'pem';
	};
	inherits(PEMDecoder, DERDecoder);
	module.exports = PEMDecoder;

	PEMDecoder.prototype.decode = function decode(data, options) {
	  var lines = data.toString().split(/[\r\n]+/g);

	  var label = options.label.toUpperCase();

	  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
	  var start = -1;
	  var end = -1;
	  for (var i = 0; i < lines.length; i++) {
	    var match = lines[i].match(re);
	    if (match === null)
	      continue;

	    if (match[2] !== label)
	      continue;

	    if (start === -1) {
	      if (match[1] !== 'BEGIN')
	        break;
	      start = i;
	    } else {
	      if (match[1] !== 'END')
	        break;
	      end = i;
	      break;
	    }
	  }
	  if (start === -1 || end === -1)
	    throw new Error('PEM section not found for: ' + label);

	  var base64 = lines.slice(start + 1, end).join('');
	  // Remove excessive symbols
	  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

	  var input = new Buffer(base64, 'base64');
	  return DERDecoder.prototype.decode.call(this, input, options);
	};


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var encoders = exports;

	encoders.der = __webpack_require__(62);
	encoders.pem = __webpack_require__(122);


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(1);

	var DEREncoder = __webpack_require__(62);

	function PEMEncoder(entity) {
	  DEREncoder.call(this, entity);
	  this.enc = 'pem';
	};
	inherits(PEMEncoder, DEREncoder);
	module.exports = PEMEncoder;

	PEMEncoder.prototype.encode = function encode(data, options) {
	  var buf = DEREncoder.prototype.encode.call(this, data);

	  var p = buf.toString('base64');
	  var out = [ '-----BEGIN ' + options.label + '-----' ];
	  for (var i = 0; i < p.length; i += 64)
	    out.push(p.slice(i, i + 64));
	  out.push('-----END ' + options.label + '-----');
	  return out.join('\n');
	};


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isEqual = __webpack_require__(124).isEqual;

	var GCounter = function () {
	  function GCounter(id, payload) {
	    _classCallCheck(this, GCounter);

	    this.id = id;
	    this._counters = payload ? payload : {};
	    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0;
	  }

	  _createClass(GCounter, [{
	    key: 'increment',
	    value: function increment(amount) {
	      if (!amount) amount = 1;
	      this._counters[this.id] = this._counters[this.id] + amount;
	    }
	  }, {
	    key: 'compare',
	    value: function compare(other) {
	      if (other.id !== this.id) return false;

	      return isEqual(other._counters, this._counters);
	    }
	  }, {
	    key: 'merge',
	    value: function merge(other) {
	      var _this = this;

	      Object.keys(other._counters).forEach(function (f) {
	        _this._counters[f] = Math.max(_this._counters[f] ? _this._counters[f] : 0, other._counters[f]);
	      });
	    }
	  }, {
	    key: 'value',
	    get: function get() {
	      var _this2 = this;

	      return Object.keys(this._counters).map(function (f) {
	        return _this2._counters[f];
	      }).reduce(function (previousValue, currentValue) {
	        return previousValue + currentValue;
	      }, 0);
	    }
	  }, {
	    key: 'payload',
	    get: function get() {
	      return { id: this.id, counters: this._counters };
	    }
	  }], [{
	    key: 'from',
	    value: function from(payload) {
	      return new GCounter(payload.id, payload.counters);
	    }
	  }]);

	  return GCounter;
	}();

	module.exports = GCounter;

/***/ },
/* 124 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	exports.isEqual = function (a, b) {
	  var propsA = Object.getOwnPropertyNames(a);
	  var propsB = Object.getOwnPropertyNames(b);

	  if (propsA.length !== propsB.length) return false;

	  for (var i = 0; i < propsA.length; i++) {
	    var prop = propsA[i];
	    if (a[prop] !== b[prop]) return false;
	  }

	  return true;
	};

/***/ },
/* 125 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	// Declare internals

	var internals = {};

	exports.escapeJavaScript = function (input) {

	    if (!input) {
	        return '';
	    }

	    var escaped = '';

	    for (var i = 0; i < input.length; ++i) {

	        var charCode = input.charCodeAt(i);

	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        } else {
	            escaped += internals.escapeJavaScriptChar(charCode);
	        }
	    }

	    return escaped;
	};

	exports.escapeHtml = function (input) {

	    if (!input) {
	        return '';
	    }

	    var escaped = '';

	    for (var i = 0; i < input.length; ++i) {

	        var charCode = input.charCodeAt(i);

	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        } else {
	            escaped += internals.escapeHtmlChar(charCode);
	        }
	    }

	    return escaped;
	};

	internals.escapeJavaScriptChar = function (charCode) {

	    if (charCode >= 256) {
	        return '\\u' + internals.padLeft('' + charCode, 4);
	    }

	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '\\x' + internals.padLeft(hexValue, 2);
	};

	internals.escapeHtmlChar = function (charCode) {

	    var namedEscape = internals.namedHtml[charCode];
	    if (typeof namedEscape !== 'undefined') {
	        return namedEscape;
	    }

	    if (charCode >= 256) {
	        return '&#' + charCode + ';';
	    }

	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '&#x' + internals.padLeft(hexValue, 2) + ';';
	};

	internals.padLeft = function (str, len) {

	    while (str.length < len) {
	        str = '0' + str;
	    }

	    return str;
	};

	internals.isSafe = function (charCode) {

	    return typeof internals.safeCharCodes[charCode] !== 'undefined';
	};

	internals.namedHtml = {
	    '38': '&amp;',
	    '60': '&lt;',
	    '62': '&gt;',
	    '34': '&quot;',
	    '160': '&nbsp;',
	    '162': '&cent;',
	    '163': '&pound;',
	    '164': '&curren;',
	    '169': '&copy;',
	    '174': '&reg;'
	};

	internals.safeCharCodes = function () {

	    var safe = {};

	    for (var i = 32; i < 123; ++i) {

	        if (i >= 97 || // a-z
	        i >= 65 && i <= 90 || // A-Z
	        i >= 48 && i <= 57 || // 0-9
	        i === 32 || // space
	        i === 46 || // .
	        i === 44 || // ,
	        i === 45 || // -
	        i === 58 || // :
	        i === 95) {
	            // _

	            safe[i] = null;
	        }
	    }

	    return safe;
	}();

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    wantlist: promisify(function (callback) {
	      send({
	        path: 'bitswap/wantlist'
	      }, callback);
	    }),
	    stat: promisify(function (callback) {
	      send({
	        path: 'bitswap/stat'
	      }, callback);
	    }),
	    unwant: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'bitswap/unwant',
	        args: args,
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var promisify = __webpack_require__(0);
	var bl = __webpack_require__(31);
	var Block = __webpack_require__(69);

	module.exports = function (send) {
	  return {
	    get: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      return send({
	        path: 'block/get',
	        args: args,
	        qs: opts
	      }, function (err, res) {
	        if (err) {
	          return callback(err);
	        }
	        if (Buffer.isBuffer(res)) {
	          callback(null, new Block(res));
	        } else {
	          res.pipe(bl(function (err, data) {
	            if (err) {
	              return callback(err);
	            }
	            callback(null, new Block(data));
	          }));
	        }
	      });
	    }),
	    stat: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      return send({
	        path: 'block/stat',
	        args: args,
	        qs: opts
	      }, function (err, stats) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, {
	          key: stats.Key,
	          size: stats.Size
	        });
	      });
	    }),
	    put: promisify(function (block, callback) {
	      if (Array.isArray(block)) {
	        var err = new Error('block.put() only accepts 1 file');
	        return callback(err);
	      }

	      if ((typeof block === 'undefined' ? 'undefined' : _typeof(block)) === 'object' && block.data) {
	        block = block.data;
	      }

	      return send({
	        path: 'block/put',
	        files: block
	      }, function (err, blockInfo) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, new Block(block));
	      });
	    })
	  };
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    add: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      if (args && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {
	        opts = args;
	        args = undefined;
	      }

	      send({
	        path: 'bootstrap/add',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    rm: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      if (args && (typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {
	        opts = args;
	        args = undefined;
	      }

	      send({
	        path: 'bootstrap/rm',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    list: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'bootstrap/list',
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);
	var cleanMultihash = __webpack_require__(38);

	module.exports = function (send) {
	  return promisify(function (hash, callback) {
	    try {
	      hash = cleanMultihash(hash);
	    } catch (err) {
	      return callback(err);
	    }

	    send({
	      path: 'cat',
	      args: hash
	    }, callback);
	  });
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (callback) {
	    send({
	      path: 'commands'
	    }, callback);
	  });
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var streamifier = __webpack_require__(376);
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    get: promisify(function (key, callback) {
	      if (typeof key === 'function') {
	        callback = key;
	        key = undefined;
	      }

	      if (!key) {
	        send({
	          path: 'config/show',
	          buffer: true
	        }, callback);
	        return;
	      }

	      send({
	        path: 'config',
	        args: key,
	        buffer: true
	      }, function (err, response) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, response.Value);
	      });
	    }),
	    set: promisify(function (key, value, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      if (typeof key !== 'string') {
	        return callback(new Error('Invalid key type'));
	      }

	      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && typeof value !== 'boolean' && typeof value !== 'string') {
	        return callback(new Error('Invalid value type'));
	      }

	      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	        value = JSON.stringify(value);
	        opts = { json: true };
	      }

	      if (typeof value === 'boolean') {
	        value = value.toString();
	        opts = { bool: true };
	      }

	      send({
	        path: 'config',
	        args: [key, value],
	        qs: opts,
	        files: undefined,
	        buffer: true
	      }, callback);
	    }),
	    replace: promisify(function (config, callback) {
	      if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
	        config = streamifier.createReadStream(new Buffer(JSON.stringify(config)));
	      }

	      send({
	        path: 'config/replace',
	        files: config,
	        buffer: true
	      }, callback);
	    })
	  };
	};

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    findprovs: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'dht/findprovs',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    get: promisify(function (key, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      var handleResult = function handleResult(done, err, res) {
	        if (err) {
	          return done(err);
	        }
	        if (!res) {
	          return done(new Error('empty response'));
	        }
	        if (res.length === 0) {
	          return done(new Error('no value returned for key'));
	        }

	        // Inconsistent return values in the browser vs node
	        if (Array.isArray(res)) {
	          res = res[0];
	        }

	        if (res.Type === 5) {
	          done(null, res.Extra);
	        } else {
	          var error = new Error('key was not found (type 6)');
	          done(error);
	        }
	      };

	      send({
	        path: 'dht/get',
	        args: key,
	        qs: opts
	      }, handleResult.bind(null, callback));
	    }),
	    put: promisify(function (key, value, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'dht/put',
	        args: [key, value],
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    net: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'diag/net',
	        qs: opts
	      }, callback);
	    }),
	    sys: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'diag/sys',
	        qs: opts
	      }, callback);
	    }),
	    cmds: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'diag/cmds',
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    cp: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'files/cp',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    ls: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      return send({
	        path: 'files/ls',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    mkdir: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'files/mkdir',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    stat: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'files/stat',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    rm: promisify(function (path, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'files/rm',
	        args: path,
	        qs: opts
	      }, callback);
	    }),
	    read: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'files/read',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    write: promisify(function (pathDst, files, opts, callback) {
	      if (typeof opts === 'function' && !callback) {
	        callback = opts;
	        opts = {};
	      }

	      // opts is the real callback --
	      // 'callback' is being injected by promisify
	      if (typeof opts === 'function' && typeof callback === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      send({
	        path: 'files/write',
	        args: pathDst,
	        qs: opts,
	        files: files
	      }, callback);
	    }),
	    mv: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function' && callback === undefined) {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'files/mv',
	        args: args,
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = undefined;
	    }
	    send({
	      path: 'id',
	      args: opts
	    }, function (err, result) {
	      if (err) {
	        return callback(err);
	      }
	      var identity = {
	        id: result.ID,
	        publicKey: result.PublicKey,
	        addresses: result.Addresses,
	        agentVersion: result.AgentVersion,
	        protocolVersion: result.ProtocolVersion
	      };
	      callback(null, identity);
	    });
	  });
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var ndjson = __webpack_require__(91);
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    tail: promisify(function (callback) {
	      send({
	        path: 'log/tail'
	      }, function (err, response) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, response.pipe(ndjson.parse()));
	      });
	    })
	  };
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (args, opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = {};
	    }
	    send({
	      path: 'ls',
	      args: args,
	      qs: opts
	    }, callback);
	  });
	};

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (ipfs, ipns, callback) {
	    if (typeof ipfs === 'function') {
	      callback = ipfs;
	      ipfs = null;
	    } else if (typeof ipns === 'function') {
	      callback = ipns;
	      ipns = null;
	    }
	    var opts = {};
	    if (ipfs) {
	      opts.f = ipfs;
	    }
	    if (ipns) {
	      opts.n = ipns;
	    }

	    send({
	      path: 'mount',
	      qs: opts
	    }, callback);
	  });
	};

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    publish: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'name/publish',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    resolve: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'name/resolve',
	        args: args,
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var DAGNode = __webpack_require__(39).DAGNode;
	var DAGLink = __webpack_require__(39).DAGLink;
	var promisify = __webpack_require__(0);
	var bs58 = __webpack_require__(18);
	var bl = __webpack_require__(31);
	var cleanMultihash = __webpack_require__(38);

	module.exports = function (send) {
	  var api = {
	    get: promisify(function (multihash, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      try {
	        multihash = cleanMultihash(multihash, options);
	      } catch (err) {
	        return callback(err);
	      }

	      send({
	        path: 'object/get',
	        args: multihash
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }

	        var node = new DAGNode(result.Data, result.Links.map(function (l) {
	          return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
	        }));

	        callback(null, node);
	      });
	    }),
	    put: promisify(function (obj, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      var tmpObj = {
	        Data: null,
	        Links: []
	      };

	      if (Buffer.isBuffer(obj)) {
	        if (!options.enc) {
	          tmpObj = { Data: obj.toString(), Links: [] };
	        }
	      } else if (obj.multihash) {
	        tmpObj = {
	          Data: obj.data.toString(),
	          Links: obj.links.map(function (l) {
	            return l.toJSON();
	          })
	        };
	      } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	        tmpObj.Data = obj.Data.toString();
	      } else {
	        return callback(new Error('obj not recognized'));
	      }

	      var buf = void 0;
	      if (Buffer.isBuffer(obj) && options.enc) {
	        buf = obj;
	      } else {
	        buf = new Buffer(JSON.stringify(tmpObj));
	      }
	      var enc = options.enc || 'json';

	      send({
	        path: 'object/put',
	        qs: { inputenc: enc },
	        files: buf
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }

	        if (Buffer.isBuffer(obj)) {
	          if (!options.enc) {
	            obj = { Data: obj, Links: [] };
	          } else if (options.enc === 'json') {
	            obj = JSON.parse(obj.toString());
	          }
	        }
	        var node = void 0;
	        if (obj.multihash) {
	          node = obj;
	        } else if (options.enc === 'protobuf') {
	          node = new DAGNode();
	          node.unMarshal(obj);
	        } else {
	          node = new DAGNode(obj.Data, obj.Links);
	        }

	        if (node.toJSON().Hash !== result.Hash) {
	          return callback(new Error('Stored object was different from constructed object'));
	        }

	        callback(null, node);
	      });
	    }),
	    data: promisify(function (multihash, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      try {
	        multihash = cleanMultihash(multihash, options);
	      } catch (err) {
	        return callback(err);
	      }

	      send({
	        path: 'object/data',
	        args: multihash
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }

	        if (typeof result.pipe === 'function') {
	          result.pipe(bl(callback));
	        } else {
	          callback(null, result);
	        }
	      });
	    }),
	    links: promisify(function (multihash, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      try {
	        multihash = cleanMultihash(multihash, options);
	      } catch (err) {
	        return callback(err);
	      }

	      send({
	        path: 'object/links',
	        args: multihash
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }

	        var links = [];

	        if (result.Links) {
	          links = result.Links.map(function (l) {
	            return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
	          });
	        }
	        callback(null, links);
	      });
	    }),
	    stat: promisify(function (multihash, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      if (!opts) {
	        opts = {};
	      }

	      try {
	        multihash = cleanMultihash(multihash, opts);
	      } catch (err) {
	        return callback(err);
	      }

	      send({
	        path: 'object/stat',
	        args: multihash
	      }, callback);
	    }),
	    new: promisify(function (callback) {
	      send({
	        path: 'object/new'
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }
	        var node = new DAGNode();

	        if (node.toJSON().Hash !== result.Hash) {
	          return callback(new Error('Stored object was different from constructed object'));
	        }

	        callback(null, node);
	      });
	    }),
	    patch: {
	      addLink: promisify(function (multihash, dLink, opts, callback) {
	        if (typeof opts === 'function') {
	          callback = opts;
	          opts = {};
	        }
	        if (!opts) {
	          opts = {};
	        }

	        try {
	          multihash = cleanMultihash(multihash, opts);
	        } catch (err) {
	          return callback(err);
	        }

	        send({
	          path: 'object/patch/add-link',
	          args: [multihash, dLink.name, bs58.encode(dLink.hash).toString()]
	        }, function (err, result) {
	          if (err) {
	            return callback(err);
	          }
	          api.get(result.Hash, { enc: 'base58' }, callback);
	        });
	      }),
	      rmLink: promisify(function (multihash, dLink, opts, callback) {
	        if (typeof opts === 'function') {
	          callback = opts;
	          opts = {};
	        }
	        if (!opts) {
	          opts = {};
	        }

	        try {
	          multihash = cleanMultihash(multihash, opts);
	        } catch (err) {
	          return callback(err);
	        }

	        send({
	          path: 'object/patch/rm-link',
	          args: [multihash, dLink.name]
	        }, function (err, result) {
	          if (err) {
	            return callback(err);
	          }
	          api.get(result.Hash, { enc: 'base58' }, callback);
	        });
	      }),
	      setData: promisify(function (multihash, data, opts, callback) {
	        if (typeof opts === 'function') {
	          callback = opts;
	          opts = {};
	        }
	        if (!opts) {
	          opts = {};
	        }

	        try {
	          multihash = cleanMultihash(multihash, opts);
	        } catch (err) {
	          return callback(err);
	        }

	        send({
	          path: 'object/patch/set-data',
	          args: [multihash],
	          files: data
	        }, function (err, result) {
	          if (err) {
	            return callback(err);
	          }
	          api.get(result.Hash, { enc: 'base58' }, callback);
	        });
	      }),
	      appendData: promisify(function (multihash, data, opts, callback) {
	        if (typeof opts === 'function') {
	          callback = opts;
	          opts = {};
	        }
	        if (!opts) {
	          opts = {};
	        }

	        try {
	          multihash = cleanMultihash(multihash, opts);
	        } catch (err) {
	          return callback(err);
	        }

	        send({
	          path: 'object/patch/append-data',
	          args: [multihash],
	          files: data
	        }, function (err, result) {
	          if (err) {
	            return callback(err);
	          }
	          api.get(result.Hash, { enc: 'base58' }, callback);
	        });
	      })
	    }
	  };

	  return api;
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    add: promisify(function (hash, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = null;
	      }
	      send({
	        path: 'pin/add',
	        args: hash,
	        qs: opts
	      }, function (err, res) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, res.Pins);
	      });
	    }),
	    rm: promisify(function (hash, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = null;
	      }
	      send({
	        path: 'pin/rm',
	        args: hash,
	        qs: opts
	      }, function (err, res) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, res.Pins);
	      });
	    }),
	    ls: promisify(function (hash, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }

	      if ((typeof hash === 'undefined' ? 'undefined' : _typeof(hash)) === 'object') {
	        opts = hash;
	        hash = undefined;
	      }

	      if (typeof hash === 'function') {
	        callback = hash;
	        hash = undefined;
	        opts = {};
	      }

	      send({
	        path: 'pin/ls',
	        args: hash,
	        qs: opts
	      }, function (err, res) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, res.Keys);
	      });
	    })
	  };
	};

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (id, callback) {
	    send({
	      path: 'ping',
	      args: id,
	      qs: { n: 1 }
	    }, function (err, res) {
	      if (err) {
	        return callback(err, null);
	      }
	      callback(null, res[1]);
	    });
	  });
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);
	var bs58 = __webpack_require__(18);
	var Base64 = __webpack_require__(280).Base64;
	var Stream = __webpack_require__(3);
	var Readable = Stream.Readable;
	var http = __webpack_require__(56);

	var activeSubscriptions = [];

	var subscriptionExists = function subscriptionExists(subscriptions, topic) {
	  return subscriptions.indexOf(topic) !== -1;
	};
	var removeSubscription = function removeSubscription(subscriptions, topic) {
	  var indexToRemove = subscriptions.indexOf(topic);
	  return subscriptions.filter(function (el, index) {
	    return index !== indexToRemove;
	  });
	};
	var addSubscription = function addSubscription(subscriptions, topic) {
	  return subscriptions.concat([topic]);
	};
	var parseMessage = function parseMessage(message) {
	  return Object.assign({}, message, {
	    from: bs58.encode(message.from),
	    data: Base64.decode(message.data),
	    seqno: Base64.decode(message.seqno)
	  });
	};

	module.exports = function (send, config) {
	  return {
	    sub: promisify(function (topic, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      var rs = new Readable({ objectMode: true });
	      rs._read = function () {};

	      if (!subscriptionExists(activeSubscriptions, topic)) {
	        activeSubscriptions = addSubscription(activeSubscriptions, topic);
	      } else {
	        return callback(new Error('Already subscribed to ' + topic), null);
	      }

	      // we're using http.get here to have more control over the request
	      // and avoid refactoring of the request-api where wreck is gonna be
	      // replaced by fetch (https://github.com/ipfs/js-ipfs-api/pull/355)
	      var request = http.get({
	        host: config.host,
	        port: config.port,
	        path: '/api/v0/pubsub/sub/' + topic
	      }, function (response) {
	        response.on('data', function (d) {
	          var data = JSON.parse(d);

	          // skip "double subscription" error
	          if (!data.Message) {
	            rs.emit('data', parseMessage(data));
	          }
	        });
	        response.on('end', function () {
	          rs.emit('end');
	        });
	        rs.cancel = function () {
	          request.abort();
	          activeSubscriptions = removeSubscription(activeSubscriptions, topic);
	        };
	      });
	      rs.cancel = function () {
	        request.abort();
	        activeSubscriptions = removeSubscription(activeSubscriptions, topic);
	      };
	      callback(null, rs);
	    }),
	    pub: promisify(function (topic, data, options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      if (!options) {
	        options = {};
	      }

	      var isBuffer = Buffer.isBuffer(data);
	      var buf = isBuffer ? data : new Buffer(data);

	      send({
	        path: 'pubsub/pub',
	        args: [topic, buf]
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, true);
	      });
	    })
	  };
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  var refs = promisify(function (args, opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = {};
	    }
	    return send({
	      path: 'refs',
	      args: args,
	      qs: opts
	    }, callback);
	  });
	  refs.local = promisify(function (opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = {};
	    }
	    return send({
	      path: 'refs',
	      qs: opts
	    }, callback);
	  });

	  return refs;
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    gc: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'repo/gc',
	        qs: opts
	      }, callback);
	    }),
	    stat: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'repo/stat',
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);
	var multiaddr = __webpack_require__(89);

	module.exports = function (send) {
	  return {
	    peers: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'swarm/peers',
	        qs: opts
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, result.Strings.map(function (addr) {
	          return multiaddr(addr);
	        }));
	      });
	    }),
	    connect: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'swarm/connect',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    disconnect: promisify(function (args, opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'swarm/disconnect',
	        args: args,
	        qs: opts
	      }, callback);
	    }),
	    addrs: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'swarm/addrs',
	        qs: opts
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, Object.keys(result.Addrs).map(function (id) {
	          return result.Addrs[id].map(function (maStr) {
	            return multiaddr(maStr).encapsulate('/ipfs/' + id);
	          });
	        })[0]);
	      });
	    }),
	    localAddrs: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'swarm/addrs/local',
	        qs: opts
	      }, function (err, result) {
	        if (err) {
	          return callback(err);
	        }
	        callback(null, result.Strings.map(function (addr) {
	          return multiaddr(addr);
	        }));
	      });
	    })
	  };
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return {
	    apply: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'update',
	        qs: opts
	      }, callback);
	    }),
	    check: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'update/check',
	        qs: opts
	      }, callback);
	    }),
	    log: promisify(function (opts, callback) {
	      if (typeof opts === 'function') {
	        callback = opts;
	        opts = {};
	      }
	      send({
	        path: 'update/log',
	        qs: opts
	      }, callback);
	    })
	  };
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var isNode = __webpack_require__(41);
	var addToDagNodesTransform = __webpack_require__(37);
	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (path, opts, callback) {
	    if (typeof opts === 'function' && callback === undefined) {
	      callback = opts;
	      opts = {};
	    }

	    // opts is the real callback --
	    // 'callback' is being injected by promisify
	    if (typeof opts === 'function' && typeof callback === 'function') {
	      callback = opts;
	      opts = {};
	    }

	    if (!isNode) {
	      return callback(new Error('fsAdd does not work in the browser'));
	    }

	    if (typeof path !== 'string') {
	      return callback(new Error('"path" must be a string'));
	    }

	    var sendWithTransform = send.withTransform(addToDagNodesTransform);

	    sendWithTransform({
	      path: 'add',
	      qs: opts,
	      files: path
	    }, callback);
	  });
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var Wreck = __webpack_require__(76);
	var addToDagNodesTransform = __webpack_require__(37);

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (url, opts, callback) {
	    if (typeof opts === 'function' && callback === undefined) {
	      callback = opts;
	      opts = {};
	    }

	    // opts is the real callback --
	    // 'callback' is being injected by promisify
	    if (typeof opts === 'function' && typeof callback === 'function') {
	      callback = opts;
	      opts = {};
	    }

	    if (typeof url !== 'string' || !url.startsWith('http')) {
	      return callback(new Error('"url" param must be an http(s) url'));
	    }

	    var sendWithTransform = send.withTransform(addToDagNodesTransform);

	    Wreck.request('GET', url, null, function (err, res) {
	      if (err) {
	        return callback(err);
	      }

	      sendWithTransform({
	        path: 'add',
	        qs: opts,
	        files: res
	      }, callback);
	    });
	  });
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var promisify = __webpack_require__(0);

	module.exports = function (send) {
	  return promisify(function (opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = {};
	    }

	    send({
	      path: 'version',
	      qs: opts
	    }, function (err, result) {
	      if (err) {
	        return callback(err);
	      }
	      var version = {
	        version: result.Version,
	        commit: result.Commit,
	        repo: result.Repo
	      };
	      callback(null, version);
	    });
	  });
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var pkg = __webpack_require__(282);

	exports = module.exports = function () {
	  return {
	    'api-path': '/api/v0/',
	    'user-agent': '/node-' + pkg.name + '/' + pkg.version + '/',
	    host: 'localhost',
	    port: '5001',
	    protocol: 'http'
	  };
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var DAGNode = __webpack_require__(39).DAGNode;
	var bl = __webpack_require__(31);
	var parallel = __webpack_require__(167);

	module.exports = function (send, hash, callback) {
	  // Retrieve the object and its data in parallel, then produce a DAGNode
	  // instance using this information.
	  parallel([function get(done) {
	    send({
	      path: 'object/get',
	      args: hash
	    }, done);
	  }, function data(done) {
	    // WORKAROUND: request the object's data separately, since raw bits in JSON
	    // are interpreted as UTF-8 and corrupt the data.
	    // See https://github.com/ipfs/go-ipfs/issues/1582 for more details.
	    send({
	      path: 'object/data',
	      args: hash
	    }, done);
	  }], function done(err, res) {
	    if (err) {
	      return callback(err);
	    }

	    var object = res[0];
	    var stream = res[1];

	    if (Buffer.isBuffer(stream)) {
	      callback(err, new DAGNode(stream, object.Links));
	    } else {
	      stream.pipe(bl(function (err, data) {
	        if (err) {
	          return callback(err);
	        }

	        callback(err, new DAGNode(data, object.Links));
	      }));
	    }
	  });
	};

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var isNode = __webpack_require__(41);
	var Multipart = __webpack_require__(314);
	var flatmap = __webpack_require__(259);

	function headers(file) {
	  var name = file.path || '';
	  var header = {
	    'Content-Disposition': 'file; filename="' + name + '"'
	  };

	  if (file.dir || !file.content) {
	    header['Content-Type'] = 'application/x-directory';
	  } else if (file.symlink) {
	    header['Content-Type'] = 'application/symlink';
	  } else {
	    header['Content-Type'] = 'application/octet-stream';
	  }

	  return header;
	}

	function strip(name, base) {
	  var smallBase = base.split('/').slice(0, -1).join('/') + '/';
	  return name.replace(smallBase, '');
	}

	function loadPaths(opts, file) {
	  var path = __webpack_require__(12);
	  var fs = __webpack_require__(11);
	  var glob = __webpack_require__(83);

	  var followSymlinks = opts.followSymlinks != null ? opts.followSymlinks : true;

	  file = path.resolve(file);
	  var stats = fs.statSync(file);

	  if (stats.isDirectory() && !opts.recursive) {
	    throw new Error('Can only add directories using --recursive');
	  }

	  if (stats.isDirectory() && opts.recursive) {
	    var _ret = function () {
	      var mg = new glob.sync.GlobSync(file + '/**/*', {
	        follow: followSymlinks
	      });

	      return {
	        v: mg.found.map(function (name) {
	          // symlinks
	          if (mg.symlinks[name] === true) {
	            return {
	              path: strip(name, file),
	              symlink: true,
	              dir: false,
	              content: fs.readlinkSync(name)
	            };
	          }

	          // files
	          if (mg.cache[name] === 'FILE') {
	            return {
	              path: strip(name, file),
	              symlink: false,
	              dir: false,
	              content: fs.createReadStream(name)
	            };
	          }

	          // directories
	          if (mg.cache[name] === 'DIR' || mg.cache[name] instanceof Array) {
	            return {
	              path: strip(name, file),
	              symlink: false,
	              dir: true
	            };
	          }

	          // files inside symlinks and others
	          return;
	        })
	        // filter out null files
	        .filter(Boolean)
	      };
	    }();

	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }

	  return {
	    path: file,
	    content: fs.createReadStream(file)
	  };
	}

	function getFilesStream(files, opts) {
	  if (!files) {
	    return null;
	  }

	  var mp = new Multipart();

	  flatmap(files, function (file) {
	    if (typeof file === 'string') {
	      if (!isNode) {
	        throw new Error('Can not add paths in node');
	      }

	      return loadPaths(opts, file);
	    }

	    if (file.path && !file.content) {
	      file.dir = true;
	      return file;
	    }

	    if (file.path && (file.content || file.dir)) {
	      return file;
	    }

	    return {
	      path: '',
	      symlink: false,
	      dir: false,
	      content: file
	    };
	  }).forEach(function (file) {
	    mp.addPart({
	      headers: headers(file),
	      body: file.content
	    });
	  });

	  return mp;
	}

	exports = module.exports = getFilesStream;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var multiaddr = __webpack_require__(89);
	var loadCommands = __webpack_require__(155);
	var getConfig = __webpack_require__(151);
	var getRequestAPI = __webpack_require__(156);

	function IpfsAPI(hostOrMultiaddr, port, opts) {
	  var config = getConfig();

	  try {
	    var maddr = multiaddr(hostOrMultiaddr).nodeAddress();
	    config.host = maddr.address;
	    config.port = maddr.port;
	  } catch (e) {
	    if (typeof hostOrMultiaddr === 'string') {
	      config.host = hostOrMultiaddr;
	      config.port = port && (typeof port === 'undefined' ? 'undefined' : _typeof(port)) !== 'object' ? port : config.port;
	    }
	  }

	  var lastIndex = arguments.length;
	  while (!opts && lastIndex-- > 0) {
	    opts = arguments[lastIndex];
	    if (opts) break;
	  }

	  Object.assign(config, opts);

	  // autoconfigure in browser
	  if (!config.host && typeof window !== 'undefined') {
	    var split = window.location.host.split(':');
	    config.host = split[0];
	    config.port = split[1];
	  }

	  var requestAPI = getRequestAPI(config);
	  var cmds = loadCommands(requestAPI, config);
	  cmds.send = requestAPI;
	  cmds.Buffer = Buffer;

	  return cmds;
	}

	exports = module.exports = IpfsAPI;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function requireCommands() {
	  var cmds = {
	    // add and createAddStream alias
	    add: __webpack_require__(30),
	    createAddStream: __webpack_require__(64),
	    bitswap: __webpack_require__(126),
	    block: __webpack_require__(127),
	    bootstrap: __webpack_require__(128),
	    cat: __webpack_require__(129),
	    commands: __webpack_require__(130),
	    config: __webpack_require__(131),
	    dht: __webpack_require__(132),
	    diag: __webpack_require__(133),
	    id: __webpack_require__(135),
	    get: __webpack_require__(65),
	    log: __webpack_require__(136),
	    ls: __webpack_require__(137),
	    mount: __webpack_require__(138),
	    name: __webpack_require__(139),
	    object: __webpack_require__(140),
	    pin: __webpack_require__(141),
	    ping: __webpack_require__(142),
	    pubsub: __webpack_require__(143),
	    refs: __webpack_require__(144),
	    repo: __webpack_require__(145),
	    swarm: __webpack_require__(146),
	    update: __webpack_require__(147),
	    version: __webpack_require__(150)
	  };

	  // TODO: crowding the 'files' namespace temporarily for interface-ipfs-core
	  // compatibility, until 'files vs mfs' naming decision is resolved.
	  cmds.files = function (send) {
	    var files = __webpack_require__(134)(send);
	    files.add = __webpack_require__(30)(send);
	    files.createAddStream = __webpack_require__(64)(send);
	    files.get = __webpack_require__(65)(send);

	    // aliases
	    cmds.add = files.add;
	    cmds.createAddStream = files.createAddStream;
	    cmds.get = files.get;

	    return files;
	  };

	  cmds.util = function (send) {
	    var util = {
	      addFromFs: __webpack_require__(148)(send),
	      addFromStream: __webpack_require__(30)(send),
	      addFromURL: __webpack_require__(149)(send)
	    };
	    return util;
	  };

	  return cmds;
	}

	function loadCommands(send, config) {
	  var files = requireCommands();
	  var cmds = {};

	  Object.keys(files).forEach(function (file) {
	    cmds[file] = files[file](send, config);
	  });

	  return cmds;
	}

	module.exports = loadCommands;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};

	var Wreck = __webpack_require__(76);
	var Qs = __webpack_require__(188);
	var ndjson = __webpack_require__(91);
	var getFilesStream = __webpack_require__(153);

	var isNode = __webpack_require__(41);

	// -- Internal

	function parseChunkedJson(res, cb) {
	  var parsed = [];
	  res.pipe(ndjson.parse()).on('data', function (obj) {
	    parsed.push(obj);
	  }).on('end', function () {
	    cb(null, parsed);
	  });
	}

	function onRes(buffer, cb, uri) {
	  return function (err, res) {
	    if (err) {
	      return cb(err);
	    }

	    var stream = Boolean(res.headers['x-stream-output']);
	    var chunkedObjects = Boolean(res.headers['x-chunked-output']);
	    var isJson = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;

	    if (res.statusCode >= 400 || !res.statusCode) {
	      var _ret = function () {
	        var error = new Error('Server responded with ' + res.statusCode);

	        return {
	          v: Wreck.read(res, { json: true }, function (err, payload) {
	            if (err) {
	              return cb(err);
	            }
	            if (payload) {
	              error.code = payload.Code;
	              error.message = payload.Message || payload.toString();
	            }
	            cb(error);
	          })
	        };
	      }();

	      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	    }

	    if (stream && !buffer) {
	      return cb(null, res);
	    }

	    if (chunkedObjects) {
	      if (isJson) {
	        return parseChunkedJson(res, cb);
	      }

	      return Wreck.read(res, null, cb);
	    }

	    Wreck.read(res, { json: isJson }, cb);
	  };
	}

	function requestAPI(config, options, callback) {
	  options.qs = options.qs || {};

	  if (Array.isArray(options.files)) {
	    options.qs.recursive = true;
	  }

	  if (Array.isArray(options.path)) {
	    options.path = options.path.join('/');
	  }
	  if (options.args && !Array.isArray(options.args)) {
	    options.args = [options.args];
	  }
	  if (options.args) {
	    options.qs.arg = options.args;
	  }
	  if (options.files && !Array.isArray(options.files)) {
	    options.files = [options.files];
	  }

	  if (options.qs.r) {
	    options.qs.recursive = options.qs.r;
	    // From IPFS 0.4.0, it throws an error when both r and recursive are passed
	    delete options.qs.r;
	  }

	  options.qs['stream-channels'] = true;

	  var stream = void 0;
	  if (options.files) {
	    stream = getFilesStream(options.files, options.qs);
	  }

	  // this option is only used internally, not passed to daemon
	  delete options.qs.followSymlinks;

	  var port = config.port ? ':' + config.port : '';

	  var opts = {
	    method: 'POST',
	    uri: config.protocol + '://' + config.host + port + config['api-path'] + options.path + '?' + Qs.stringify(options.qs, { arrayFormat: 'repeat' }),
	    headers: {}
	  };

	  if (isNode) {
	    // Browsers do not allow you to modify the user agent
	    opts.headers['User-Agent'] = config['user-agent'];
	  }

	  if (options.files) {
	    if (!stream.boundary) {
	      return callback(new Error('No boundary in multipart stream'));
	    }

	    opts.headers['Content-Type'] = 'multipart/form-data; boundary=' + stream.boundary;
	    opts.payload = stream;
	  }

	  return Wreck.request(opts.method, opts.uri, opts, onRes(options.buffer, callback, opts.uri));
	}

	//
	// -- Module Interface

	exports = module.exports = function getRequestAPI(config) {
	  /*
	   * options: {
	   *   path:   // API path (like /add or /config) - type: string
	   *   args:   // Arguments to the command - type: object
	   *   qs:     // Opts as query string opts to the command --something - type: object
	   *   files:  // files to be sent - type: string, buffer or array of strings or buffers
	   *   buffer: // buffer the request before sending it - type: bool
	   * }
	   */
	  var send = function send(options, callback) {
	    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	      return callback(new Error('no options were passed'));
	    }

	    return requestAPI(config, options, callback);
	  };

	  // Wraps the 'send' function such that an asynchronous
	  // transform may be applied to its result before
	  // passing it on to either its callback or promise.
	  send.withTransform = function (transform) {
	    return function (options, callback) {
	      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
	        return callback(new Error('no options were passed'));
	      }

	      send(options, wrap(callback));

	      function wrap(func) {
	        if (func) {
	          return function (err, res) {
	            transform(err, res, send, func);
	          };
	        }
	      }
	    };
	  };

	  return send;
	};

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var tar = __webpack_require__(378);
	var Readable = __webpack_require__(27);

	// transform tar stream into readable stream of
	// { path: 'string', content: Readable }
	module.exports = function (err, res, send, done) {
	  if (err) {
	    return done(err);
	  }

	  var ex = tar.extract();
	  res.pipe(ex);

	  var objStream = new Readable({ objectMode: true });
	  objStream._read = function noop() {};

	  ex.on('entry', function (header, stream, next) {
	    objStream.push({
	      path: header.name,
	      content: header.type !== 'directory' ? stream : null
	    });
	    next();
	  });
	  ex.on('finish', function () {
	    objStream.push(null);
	  });

	  done(null, objStream);
	};

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = eachOfLimit;

	var _eachOfLimit2 = __webpack_require__(161);

	var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	  (0, _eachOfLimit3.default)(limit)(coll, iteratee, callback);
	}
	module.exports = exports['default'];

/***/ },
/* 159 */
/***/ function(module, exports) {

	"use strict";
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = doLimit;
	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}
	module.exports = exports['default'];

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = doParallel;

	var _eachOf = __webpack_require__(66);

	var _eachOf2 = _interopRequireDefault(_eachOf);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function doParallel(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(_eachOf2.default, obj, iteratee, callback);
	    };
	}
	module.exports = exports['default'];

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _eachOfLimit;

	var _noop = __webpack_require__(34);

	var _noop2 = _interopRequireDefault(_noop);

	var _once = __webpack_require__(67);

	var _once2 = _interopRequireDefault(_once);

	var _iterator = __webpack_require__(163);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _onlyOnce = __webpack_require__(68);

	var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = (0, _once2.default)(callback || _noop2.default);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = (0, _iterator2.default)(obj);
	        var done = false;
	        var running = 0;

	        function iterateeCallback(err) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            } else if (done && running <= 0) {
	                return callback(null);
	            } else {
	                replenish();
	            }
	        }

	        function replenish() {
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
	            }
	        }

	        replenish();
	    };
	}
	module.exports = exports['default'];

/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	exports.default = function (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	};

	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

	module.exports = exports['default'];

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = iterator;

	var _isArrayLike = __webpack_require__(23);

	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

	var _getIterator = __webpack_require__(162);

	var _getIterator2 = _interopRequireDefault(_getIterator);

	var _keys = __webpack_require__(305);

	var _keys2 = _interopRequireDefault(_keys);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? { value: coll[i], key: i } : null;
	    };
	}

	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done) return null;
	        i++;
	        return { value: item.value, key: i };
	    };
	}

	function createObjectIterator(obj) {
	    var okeys = (0, _keys2.default)(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? { value: obj[key], key: key } : null;
	    };
	}

	function iterator(coll) {
	    if ((0, _isArrayLike2.default)(coll)) {
	        return createArrayIterator(coll);
	    }

	    var iterator = (0, _getIterator2.default)(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}
	module.exports = exports['default'];

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _asyncMap;

	var _noop = __webpack_require__(34);

	var _noop2 = _interopRequireDefault(_noop);

	var _once = __webpack_require__(67);

	var _once2 = _interopRequireDefault(_once);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function _asyncMap(eachfn, arr, iteratee, callback) {
	    callback = (0, _once2.default)(callback || _noop2.default);
	    arr = arr || [];
	    var results = [];
	    var counter = 0;

	    eachfn(arr, function (value, _, callback) {
	        var index = counter++;
	        iteratee(value, function (err, v) {
	            results[index] = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}
	module.exports = exports['default'];

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _parallel;

	var _noop = __webpack_require__(34);

	var _noop2 = _interopRequireDefault(_noop);

	var _isArrayLike = __webpack_require__(23);

	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

	var _rest = __webpack_require__(307);

	var _rest2 = _interopRequireDefault(_rest);

	function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : { default: obj };
	}

	function _parallel(eachfn, tasks, callback) {
	    callback = callback || _noop2.default;
	    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

	    eachfn(tasks, function (task, key, callback) {
	        task((0, _rest2.default)(function (err, args) {
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            results[key] = args;
	            callback(err);
	        }));
	    }, function (err) {
	        callback(err, results);
	    });
	}
	module.exports = exports['default'];

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _doParallel = __webpack_require__(160);

	var _doParallel2 = _interopRequireDefault(_doParallel);

	var _map = __webpack_require__(164);

	var _map2 = _interopRequireDefault(_map);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	/**
	 * Produces a new collection of values by mapping each value in `coll` through
	 * the `iteratee` function. The `iteratee` is called with an item from `coll`
	 * and a callback for when it has finished processing. Each of these callback
	 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
	 * `iteratee` passes an error to its callback, the main `callback` (for the
	 * `map` function) is immediately called with the error.
	 *
	 * Note, that since this function applies the `iteratee` to each item in
	 * parallel, there is no guarantee that the `iteratee` functions will complete
	 * in order. However, the results array will be in the same order as the
	 * original `coll`.
	 *
	 * If `map` is passed an Object, the results will be an Array.  The results
	 * will roughly be in the order of the original Objects' keys (but this can
	 * vary across JavaScript engines)
	 *
	 * @name map
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an Array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 * @example
	 *
	 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
	 *     // results is now an array of stats for each file
	 * });
	 */
	exports.default = (0, _doParallel2.default)(_map2.default);
	module.exports = exports['default'];

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parallelLimit;

	var _eachOf = __webpack_require__(66);

	var _eachOf2 = _interopRequireDefault(_eachOf);

	var _parallel = __webpack_require__(165);

	var _parallel2 = _interopRequireDefault(_parallel);

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}

	/**
	 * Run the `tasks` collection of functions in parallel, without waiting until
	 * the previous function has completed. If any of the functions pass an error to
	 * its callback, the main `callback` is immediately called with the value of the
	 * error. Once the `tasks` have completed, the results are passed to the final
	 * `callback` as an array.
	 *
	 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
	 * parallel execution of code.  If your tasks do not use any timers or perform
	 * any I/O, they will actually be executed in series.  Any synchronous setup
	 * sections for each task will happen one after the other.  JavaScript remains
	 * single-threaded.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 * results from {@link async.parallel}.
	 *
	 * @name parallel
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 * @example
	 * async.parallel([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // the results array will equal ['one','two'] even though
	 *     // the second function had a shorter timeout.
	 * });
	 *
	 * // an example using an object instead of an array
	 * async.parallel({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equals to: {one: 1, two: 2}
	 * });
	 */
	function parallelLimit(tasks, callback) {
	  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
	}
	module.exports = exports['default'];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var multihashing = __webpack_require__(90);

	exports = module.exports;

	// Hash is the global IPFS hash function. uses multihash SHA2_256, 256 bits
	exports.hash = function (data) {
	  return multihashing(data, 'sha2-256');
	};

/***/ },
/* 169 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Entry = function () {
	  function Entry(payload, next) {
	    _classCallCheck(this, Entry);

	    this.payload = payload || null;
	    this.hash = null;
	    this.next = next ? next instanceof Array ? next : [next] : [];
	    this.next = this.next.map(function (next) {
	      return next instanceof Entry ? next.hash : next;
	    }); // Convert instances of Entry to hashes
	  }

	  _createClass(Entry, [{
	    key: "hasChild",
	    value: function hasChild(a) {
	      for (var i = 0; i < this.next.length; i++) {
	        if (this.next[i] === a.hash) return true;
	      }
	      return false;
	    }
	  }, {
	    key: "asJson",
	    get: function get() {
	      var res = { payload: this.payload };
	      var next = this.next.map(function (entry) {
	        return entry instanceof Entry ? entry.hash : entry;
	      }); // Convert instances of Entry to hashes
	      Object.assign(res, { next: next });
	      return res;
	    }
	  }], [{
	    key: "create",
	    value: function create(ipfs, data, next) {
	      if (!ipfs) throw new Error("Entry requires ipfs instance");
	      if (data instanceof Entry) return Promise.resolve(data);
	      var entry = new Entry(data, next);
	      return Entry.getIpfsHash(ipfs, entry.asJson).then(function (hash) {
	        entry.hash = hash;
	        return entry;
	      });
	    }
	  }, {
	    key: "getIpfsHash",
	    value: function getIpfsHash(ipfs, entry) {
	      if (!ipfs) throw new Error("Entry requires ipfs instance");
	      var data = new Buffer(JSON.stringify(entry));
	      return ipfs.object.put(data).then(function (res) {
	        return res.toJSON().Hash;
	      });
	    }
	  }, {
	    key: "fromIpfsHash",
	    value: function fromIpfsHash(ipfs, hash) {
	      if (!ipfs) throw new Error("Entry requires ipfs instance");
	      if (!hash) throw new Error("Invalid hash: " + hash);
	      return ipfs.object.get(hash, { enc: 'base58' }).then(function (obj) {
	        var f = JSON.parse(obj.toJSON().Data);
	        return Entry.create(ipfs, f.payload, f.next);
	      });
	    }
	  }, {
	    key: "equals",
	    value: function equals(a, b) {
	      return a.hash === b.hash;
	    }
	  }]);

	  return Entry;
	}();

	module.exports = Entry;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var unionWith = __webpack_require__(288);
	var differenceWith = __webpack_require__(285);
	var flatten = __webpack_require__(287);
	var Lazy = __webpack_require__(42);
	var Promise = __webpack_require__(200);
	var Entry = __webpack_require__(169);

	var MaxBatchSize = 10; // How many items to keep per local batch
	var MaxHistory = 256; // How many items to fetch on join

	var Log = function () {
	  function Log(ipfs, id, name, opts) {
	    _classCallCheck(this, Log);

	    this.id = id;
	    this.name = name;
	    this._ipfs = ipfs;
	    this._items = opts && opts.items ? opts.items : [];

	    this.options = { maxHistory: MaxHistory };
	    Object.assign(this.options, opts);
	    delete this.options.items;

	    this._currentBatch = [];
	    this._heads = [];
	  }

	  _createClass(Log, [{
	    key: 'add',
	    value: function add(data) {
	      var _this = this;

	      if (this._currentBatch.length >= MaxBatchSize) this._commit();

	      return Entry.create(this._ipfs, data, this._heads).then(function (entry) {
	        _this._heads = [entry.hash];
	        _this._currentBatch.push(entry);
	        return entry;
	      });
	    }
	  }, {
	    key: 'join',
	    value: function join(other) {
	      var _this2 = this;

	      if (!other.items) throw new Error("The log to join must be an instance of Log");
	      var newItems = other.items.slice(0, Math.max(this.options.maxHistory, 1));
	      var diff = differenceWith(newItems, this.items, Entry.equals);
	      // TODO: need deterministic sorting for the union
	      var final = unionWith(this._currentBatch, diff, Entry.equals);
	      this._items = this._items.concat(final);
	      this._currentBatch = [];

	      var nexts = Lazy(diff).map(function (f) {
	        return f.next;
	      }).flatten().take(this.options.maxHistory).toArray();

	      // Fetch history
	      return Promise.map(nexts, function (f) {
	        var all = _this2.items.map(function (a) {
	          return a.hash;
	        });
	        return _this2._fetchRecursive(_this2._ipfs, f, all, _this2.options.maxHistory - nexts.length, 0).then(function (history) {
	          history.forEach(function (b) {
	            return _this2._insert(b);
	          });
	          return history;
	        });
	      }, { concurrency: 1 }).then(function (res) {
	        _this2._heads = Log.findHeads(_this2);
	        return flatten(res).concat(diff);
	      });
	    }
	  }, {
	    key: '_insert',
	    value: function _insert(entry) {
	      var _this3 = this;

	      var indices = Lazy(entry.next).map(function (next) {
	        return Lazy(_this3._items).map(function (f) {
	          return f.hash;
	        }).indexOf(next);
	      }); // Find the item's parent's indices
	      var index = indices.toArray().length > 0 ? Math.max(indices.max() + 1, 0) : 0; // find the largest index (latest parent)
	      this._items.splice(index, 0, entry);
	      return entry;
	    }
	  }, {
	    key: '_commit',
	    value: function _commit() {
	      this._items = this._items.concat(this._currentBatch);
	      this._currentBatch = [];
	    }
	  }, {
	    key: '_fetchRecursive',
	    value: function _fetchRecursive(ipfs, hash, all, amount, depth) {
	      var _this4 = this;

	      var isReferenced = function isReferenced(list, item) {
	        return Lazy(list).reverse().find(function (f) {
	          return f === item;
	        }) !== undefined;
	      };
	      var result = [];

	      // If the given hash is in the given log (all) or if we're at maximum depth, return
	      if (isReferenced(all, hash) || depth >= amount) return Promise.resolve(result);

	      // Create the entry and add it to the result
	      return Entry.fromIpfsHash(ipfs, hash).then(function (entry) {
	        result.push(entry);
	        all.push(hash);
	        depth++;

	        return Promise.map(entry.next, function (f) {
	          return _this4._fetchRecursive(ipfs, f, all, amount, depth);
	        }, { concurrency: 1 }).then(function (res) {
	          return flatten(res.concat(result));
	        });
	      });
	    }
	  }, {
	    key: 'items',
	    get: function get() {
	      return this._items.concat(this._currentBatch);
	    }
	  }, {
	    key: 'snapshot',
	    get: function get() {
	      return {
	        id: this.id,
	        items: this._currentBatch.map(function (f) {
	          return f.hash;
	        })
	      };
	    }
	  }], [{
	    key: 'getIpfsHash',
	    value: function getIpfsHash(ipfs, log) {
	      if (!ipfs) throw new Error("Ipfs instance not defined");
	      var data = new Buffer(JSON.stringify(log.snapshot));
	      return ipfs.object.put(data).then(function (res) {
	        return res.toJSON().Hash;
	      });
	    }
	  }, {
	    key: 'fromIpfsHash',
	    value: function fromIpfsHash(ipfs, hash, options) {
	      if (!ipfs) throw new Error("Ipfs instance not defined");
	      if (!hash) throw new Error("Invalid hash: " + hash);
	      if (!options) options = {};
	      var logData = void 0;
	      return ipfs.object.get(hash, { enc: 'base58' }).then(function (res) {
	        return logData = JSON.parse(res.toJSON().Data);
	      }).then(function (res) {
	        if (!logData.items) throw new Error("Not a Log instance");
	        return Promise.all(logData.items.map(function (f) {
	          return Entry.fromIpfsHash(ipfs, f);
	        }));
	      }).then(function (items) {
	        return Object.assign(options, { items: items });
	      }).then(function (items) {
	        return new Log(ipfs, logData.id, '', options);
	      });
	    }
	  }, {
	    key: 'findHeads',
	    value: function findHeads(log) {
	      return Lazy(log.items).reverse().filter(function (f) {
	        return !Log.isReferencedInChain(log, f);
	      }).map(function (f) {
	        return f.hash;
	      }).toArray();
	    }
	  }, {
	    key: 'isReferencedInChain',
	    value: function isReferencedInChain(log, item) {
	      return Lazy(log.items).reverse().find(function (e) {
	        return e.hasChild(item);
	      }) !== undefined;
	    }
	  }, {
	    key: 'batchSize',
	    get: function get() {
	      return MaxBatchSize;
	    }
	  }]);

	  return Log;
	}();

	module.exports = Log;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var Block = __webpack_require__(69);
	var isIPFS = __webpack_require__(85);
	var pull = __webpack_require__(334);
	var mh = __webpack_require__(24);
	var traverse = __webpack_require__(356);

	var DAGNode = __webpack_require__(71);

	module.exports = function () {
	  function DAGService(blockService) {
	    _classCallCheck(this, DAGService);

	    if (!blockService) {
	      throw new Error('DAGService requires a BlockService instance');
	    }

	    this.bs = blockService;
	  }

	  // add a DAGNode to the service, storing it on the block service


	  _createClass(DAGService, [{
	    key: 'put',
	    value: function put(node, callback) {
	      callback = callback || function () {};
	      pull(pull.values([node]), this.putStream(callback));
	    }
	  }, {
	    key: 'putStream',
	    value: function putStream(callback) {
	      return pull(pull.map(function (node) {
	        return new Block(node.encoded());
	      }), this.bs.putStream(), pull.onEnd(callback));
	    }

	    // get retrieves a DAGNode, using the Block Service

	  }, {
	    key: 'get',
	    value: function get(key, callback) {
	      pull(this.getStream(key), pull.collect(function (err, res) {
	        if (err) return callback(err);
	        callback(null, res[0]);
	      }));
	    }
	  }, {
	    key: 'getStream',
	    value: function getStream(key) {
	      var normalizedKey = normalizeKey(key);

	      if (!normalizedKey) {
	        return pull.error(new Error('Invalid Key'));
	      }

	      return pull(this.bs.getStream(normalizedKey), pull.map(function (block) {
	        var node = new DAGNode();
	        node.unMarshal(block.data);
	        return node;
	      }));
	    }
	  }, {
	    key: 'getRecursive',
	    value: function getRecursive(key, cb) {
	      pull(this.getRecursiveStream(key), pull.collect(cb));
	    }

	    // Fetches a node and all of the nodes on its links recursively
	    // TODO: add depth param

	  }, {
	    key: 'getRecursiveStream',
	    value: function getRecursiveStream(multihash) {
	      var _this = this;

	      return pull(this.getStream(multihash), pull.map(function (node) {
	        return traverse.widthFirst(node, function (node) {
	          return pull(pull.values(node.links), pull.map(function (link) {
	            return _this.getStream(link.hash);
	          }), pull.flatten());
	        });
	      }), pull.flatten());
	    }

	    // remove deletes a node with given multihash from the blockService

	  }, {
	    key: 'remove',
	    value: function remove(multihash, cb) {
	      if (!multihash) {
	        return cb(new Error('Invalid multihash'));
	      }

	      this.bs.delete(multihash, cb);
	    }
	  }]);

	  return DAGService;
	}();

	function normalizeKey(key) {
	  var res = void 0;
	  var isMhash = isIPFS.multihash(key);
	  var isPath = isIPFS.path(key);

	  if (!isMhash && !isPath) {
	    return null;
	  }

	  if (isMhash) {
	    res = key;
	  } else if (isPath) {
	    res = key.replace('/ipfs/', '');
	  }

	  if (typeof res === 'string') {
	    return mh.fromB58String(res);
	  }

	  return res;
	}

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Post = __webpack_require__(16);

	// A reference to a file

	var DirectoryPost = function (_Post) {
	  _inherits(DirectoryPost, _Post);

	  function DirectoryPost(name, hash, size) {
	    _classCallCheck(this, DirectoryPost);

	    var _this = _possibleConstructorReturn(this, (DirectoryPost.__proto__ || Object.getPrototypeOf(DirectoryPost)).call(this, "directory"));

	    _this.name = name;
	    _this.hash = hash;
	    _this.size = size;
	    return _this;
	  }

	  return DirectoryPost;
	}(Post);

	module.exports = DirectoryPost;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Post = __webpack_require__(16);

	// A reference to a file

	var FilePost = function (_Post) {
	  _inherits(FilePost, _Post);

	  function FilePost(name, hash, size, meta) {
	    _classCallCheck(this, FilePost);

	    var _this = _possibleConstructorReturn(this, (FilePost.__proto__ || Object.getPrototypeOf(FilePost)).call(this, "file"));

	    _this.name = name;
	    _this.hash = hash;
	    _this.size = size || -1;
	    _this.meta = meta || {};
	    return _this;
	  }

	  return FilePost;
	}(Post);

	module.exports = FilePost;

/***/ },
/* 174 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MetaInfo = function MetaInfo(type, size, ts, from) {
	  _classCallCheck(this, MetaInfo);

	  this.type = type;
	  this.size = size;
	  this.ts = ts;
	  this.from = from || '';
	};

	module.exports = MetaInfo;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Post = __webpack_require__(16);

	var OrbitDBItem = function (_Post) {
	  _inherits(OrbitDBItem, _Post);

	  function OrbitDBItem(operation, key, value) {
	    _classCallCheck(this, OrbitDBItem);

	    var _this = _possibleConstructorReturn(this, (OrbitDBItem.__proto__ || Object.getPrototypeOf(OrbitDBItem)).call(this, "orbit-db-op"));

	    _this.op = operation;
	    _this.key = key;
	    _this.value = value;
	    return _this;
	  }

	  return OrbitDBItem;
	}(Post);

	/*
	class HashCacheItem {
	  constructor(operation, key, sequenceNumber, targetHash, metaInfo, next) {
	    this.op     = operation;
	    this.seq    = sequenceNumber;
	    this.key    = key;
	    this.target = targetHash;
	    this.meta   = metaInfo;
	    this.next   = next;
	  }
	}

	class EncryptedHashCacheItem extends HashCacheItem {
	  constructor(operation, key, sequenceNumber, targetHash, metaInfo, next, publicKey, privateKey, salt) {
	    if(key)
	      key = Encryption.encrypt(key, privateKey, publicKey);

	    super(operation, key, sequenceNumber, targetHash, metaInfo, next);

	    try {
	      this.pubkey = publicKey;
	      this.target = Encryption.encrypt(targetHash, privateKey, publicKey);
	      this.meta   = Encryption.encrypt(JSON.stringify(metaInfo), privateKey, publicKey);
	      this.sig    = Encryption.sign(this.target, privateKey, this.seq, salt || "");
	    } catch(e) {
	      console.log("Failed to create HashCacheItem:", e);
	    }
	  }

	  static fromEncrypted(encryptedItem, publicKey, privateKey, salt) {
	    let data = JSON.parse(encryptedItem.Data);

	    // verify signature
	    const verified = Encryption.verify(data.target, data.pubkey, data.sig, data.seq, salt);
	    if(!verified) throw "Invalid signature"

	    // link to the next item
	    const next = encryptedItem.Links[0] ? encryptedItem.Links[0].Hash : null;

	    // decrypt data structure
	    const targetDec = Encryption.decrypt(data.target, privateKey, 'TODO: pubkey');
	    const metaDec   = Encryption.decrypt(data.meta, privateKey, 'TODO: pubkey');
	    data.target     = targetDec;
	    data.meta       = JSON.parse(metaDec);

	    if(data.key)
	      data.key = Encryption.decrypt(data.key, privateKey, 'TODO: pubkey');

	    const item = new HashCacheItem(data.op, data.key, data.seq, data.target, data.meta, next, publicKey, privateKey, salt);
	    return item;
	  }
	}
	*/


	module.exports = OrbitDBItem;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Post = __webpack_require__(16);

	// A poll / vote

	var Poll = function (_Post) {
	  _inherits(Poll, _Post);

	  function Poll(question, options) {
	    _classCallCheck(this, Poll);

	    var _this = _possibleConstructorReturn(this, (Poll.__proto__ || Object.getPrototypeOf(Poll)).call(this, "poll"));

	    _this.question = question;
	    _this.options = options;
	    return _this;
	  }

	  return Poll;
	}(Post);

	module.exports = Poll;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Post = __webpack_require__(16);
	// const Encryption = require('orbit-common/lib/Encryption');

	// Simplest type of post: a string

	var TextPost = function (_Post) {
	  _inherits(TextPost, _Post);

	  function TextPost(content, replyto) {
	    _classCallCheck(this, TextPost);

	    var _this = _possibleConstructorReturn(this, (TextPost.__proto__ || Object.getPrototypeOf(TextPost)).call(this, "text"));

	    _this.content = content;
	    _this.replyto = replyto;
	    return _this;
	  }

	  // encrypt(privkey, pubkey) {
	  //   this.content = Encryption.encrypt(this.content, privkey, pubkey);
	  // }


	  return TextPost;
	}(Post);

	module.exports = TextPost;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Counter = __webpack_require__(123);

	var CounterIndex = function () {
	  function CounterIndex(id) {
	    _classCallCheck(this, CounterIndex);

	    this._counter = new Counter(id);
	  }

	  _createClass(CounterIndex, [{
	    key: 'get',
	    value: function get() {
	      return this._counter;
	    }
	  }, {
	    key: 'updateIndex',
	    value: function updateIndex(oplog, added) {
	      var _this = this;

	      if (this._counter) {
	        added.filter(function (f) {
	          return f && f.payload.op === 'COUNTER';
	        }).map(function (f) {
	          return Counter.from(f.payload.value);
	        }).forEach(function (f) {
	          return _this._counter.merge(f);
	        });
	      }
	    }
	  }]);

	  return CounterIndex;
	}();

	module.exports = CounterIndex;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Store = __webpack_require__(40);
	var CounterIndex = __webpack_require__(178);

	var CounterStore = function (_Store) {
	  _inherits(CounterStore, _Store);

	  function CounterStore(ipfs, id, dbname, options) {
	    _classCallCheck(this, CounterStore);

	    if (!options) options = {};
	    if (!options.Index) Object.assign(options, { Index: CounterIndex });
	    return _possibleConstructorReturn(this, (CounterStore.__proto__ || Object.getPrototypeOf(CounterStore)).call(this, ipfs, id, dbname, options));
	  }

	  _createClass(CounterStore, [{
	    key: 'value',
	    value: function value() {
	      return this._index.get().value;
	    }
	  }, {
	    key: 'inc',
	    value: function inc(amount) {
	      var counter = this._index.get();
	      if (counter) {
	        counter.increment(amount);
	        return this._addOperation({
	          op: 'COUNTER',
	          key: null,
	          value: counter.payload,
	          meta: {
	            ts: new Date().getTime()
	          }
	        });
	      }
	    }
	  }]);

	  return CounterStore;
	}(Store);

	module.exports = CounterStore;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EventIndex = __webpack_require__(73);

	var FeedIndex = function (_EventIndex) {
	  _inherits(FeedIndex, _EventIndex);

	  function FeedIndex() {
	    _classCallCheck(this, FeedIndex);

	    return _possibleConstructorReturn(this, (FeedIndex.__proto__ || Object.getPrototypeOf(FeedIndex)).apply(this, arguments));
	  }

	  _createClass(FeedIndex, [{
	    key: 'updateIndex',
	    value: function updateIndex(oplog, added) {
	      var _this2 = this;

	      added.reduce(function (handled, item) {
	        if (handled.indexOf(item.hash) === -1) {
	          handled.push(item.hash);
	          if (item.payload.op === 'ADD') {
	            _this2._index[item.hash] = item;
	          } else if (item.payload.op === 'DEL') {
	            delete _this2._index[item.payload.value];
	          }
	        }
	        return handled;
	      }, []);
	    }
	  }]);

	  return FeedIndex;
	}(EventIndex);

	module.exports = FeedIndex;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Lazy = __webpack_require__(42);
	var EventStore = __webpack_require__(74);
	var FeedIndex = __webpack_require__(180);

	var FeedStore = function (_EventStore) {
	  _inherits(FeedStore, _EventStore);

	  function FeedStore(ipfs, id, dbname, options) {
	    _classCallCheck(this, FeedStore);

	    if (!options) options = {};
	    if (!options.Index) Object.assign(options, { Index: FeedIndex });
	    return _possibleConstructorReturn(this, (FeedStore.__proto__ || Object.getPrototypeOf(FeedStore)).call(this, ipfs, id, dbname, options));
	  }

	  _createClass(FeedStore, [{
	    key: 'remove',
	    value: function remove(hash) {
	      var operation = {
	        op: 'DEL',
	        key: null,
	        value: hash,
	        meta: {
	          ts: new Date().getTime()
	        }
	      };
	      return this._addOperation(operation);
	    }
	  }]);

	  return FeedStore;
	}(EventStore);

	module.exports = FeedStore;

/***/ },
/* 182 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var KeyValueIndex = function () {
	  function KeyValueIndex() {
	    _classCallCheck(this, KeyValueIndex);

	    this._index = {};
	  }

	  _createClass(KeyValueIndex, [{
	    key: 'get',
	    value: function get(key) {
	      return this._index[key];
	    }
	  }, {
	    key: 'updateIndex',
	    value: function updateIndex(oplog, added) {
	      var _this = this;

	      added.reverse().reduce(function (handled, item) {
	        if (handled.indexOf(item.payload.key) === -1) {
	          handled.push(item.payload.key);
	          if (item.payload.op === 'PUT') {
	            _this._index[item.payload.key] = item.payload.value;
	          } else if (item.payload.op === 'DEL') {
	            delete _this._index[item.payload.key];
	          }
	        }
	        return handled;
	      }, []);
	    }
	  }]);

	  return KeyValueIndex;
	}();

	module.exports = KeyValueIndex;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Store = __webpack_require__(40);
	var KeyValueIndex = __webpack_require__(182);

	var KeyValueStore = function (_Store) {
	  _inherits(KeyValueStore, _Store);

	  function KeyValueStore(ipfs, id, dbname, options) {
	    _classCallCheck(this, KeyValueStore);

	    if (!options) options = {};
	    if (!options.Index) Object.assign(options, { Index: KeyValueIndex });
	    return _possibleConstructorReturn(this, (KeyValueStore.__proto__ || Object.getPrototypeOf(KeyValueStore)).call(this, ipfs, id, dbname, options));
	  }

	  _createClass(KeyValueStore, [{
	    key: 'get',
	    value: function get(key) {
	      return this._index.get(key);
	    }
	  }, {
	    key: 'set',
	    value: function set(key, data) {
	      this.put(key, data);
	    }
	  }, {
	    key: 'put',
	    value: function put(key, data) {
	      return this._addOperation({
	        op: 'PUT',
	        key: key,
	        value: data,
	        meta: {
	          ts: new Date().getTime()
	        }
	      });
	    }
	  }, {
	    key: 'del',
	    value: function del(key) {
	      return this._addOperation({
	        op: 'DEL',
	        key: key,
	        value: null,
	        meta: {
	          ts: new Date().getTime()
	        }
	      });
	    }
	  }]);

	  return KeyValueStore;
	}(Store);

	module.exports = KeyValueStore;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	module.exports = __webpack_require__(185);

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ipfsApi = __webpack_require__(154);
	var logger = __webpack_require__(20).create("orbit-db.IPFSPubSub");

	var IPFSPubsub = function () {
	  function IPFSPubsub(ipfs) {
	    _classCallCheck(this, IPFSPubsub);

	    this._ipfs = ipfs;
	    this._subscriptions = {};
	  }

	  _createClass(IPFSPubsub, [{
	    key: 'subscribe',
	    value: function subscribe(hash, onMessageCallback) {
	      var _this = this;

	      if (!this._subscriptions[hash]) {
	        this._subscriptions[hash] = { onMessage: onMessageCallback };
	        this._ipfs.pubsub.sub(hash, function (err, stream) {
	          stream.on('data', _this._handleMessage.bind(_this));
	        });
	        // FIXME: when js-ipfs-api returns the stream before the
	        // first message has been received, this can be remove
	        this._ipfs.pubsub.pub(hash, '/connect');
	      }
	    }
	  }, {
	    key: 'unsubscribe',
	    value: function unsubscribe(hash) {
	      if (this._subscriptions[hash]) delete this._subscriptions[hash];
	    }
	  }, {
	    key: 'publish',
	    value: function publish(hash, message) {
	      if (this._subscriptions[hash]) this._ipfs.pubsub.pub(hash, message);
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      var _this2 = this;

	      Object.keys(this._subscriptions).forEach(function (e) {
	        //this._subscriptions[e].stream.end() ???
	        delete _this2._subscriptions[e];
	      });
	    }
	  }, {
	    key: '_handleMessage',
	    value: function _handleMessage(message) {
	      if (message.data === '/connect') return;

	      var hash = message.topicIDs[0];
	      var sub = this._subscriptions[hash];

	      if (sub && sub.onMessage) {
	        sub.onMessage(hash, message.data);
	      }
	    }
	  }]);

	  return IPFSPubsub;
	}();

	module.exports = IPFSPubsub;

/***/ },
/* 186 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Index = function () {
	  function Index(id) {
	    _classCallCheck(this, Index);

	    this.id = id;
	    this._index = [];
	  }

	  _createClass(Index, [{
	    key: 'get',
	    value: function get() {
	      return this._index;
	    }
	  }, {
	    key: 'updateIndex',
	    value: function updateIndex(oplog, entries) {
	      this._index = oplog.ops;
	    }
	  }]);

	  return Index;
	}();

	module.exports = Index;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var fs = __webpack_require__(11);
	var path = __webpack_require__(12);

	var filePath = void 0;
	var cache = {};

	var Cache = function () {
	  function Cache() {
	    _classCallCheck(this, Cache);
	  }

	  _createClass(Cache, null, [{
	    key: 'set',
	    value: function set(key, value) {
	      return new Promise(function (resolve, reject) {
	        cache[key] = value;
	        if (filePath) {
	          // console.log("write cache:", filePath, JSON.stringify(cache, null, 2))
	          fs.writeFile(filePath, JSON.stringify(cache, null, 2) + "\n", resolve);
	        } else {
	          resolve();
	        }
	      });
	    }
	  }, {
	    key: 'get',
	    value: function get(key) {
	      return cache[key];
	    }
	  }, {
	    key: 'loadCache',
	    value: function loadCache(cacheFile) {
	      cache = {};
	      return new Promise(function (resolve, reject) {
	        // console.log("load cache:", cacheFile)
	        if (cacheFile) {
	          filePath = cacheFile;
	          fs.exists(cacheFile, function (res) {
	            if (res) {
	              fs.readFile(cacheFile, function (err, res) {
	                cache = JSON.parse(res);
	                // console.log("cache:", cache)
	                resolve();
	              });
	            } else {
	              // console.log("cache file doesn't exist")
	              resolve();
	            }
	          });
	        } else {
	          resolve();
	        }
	      });
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      cache = {};
	    }
	  }]);

	  return Cache;
	}();

	module.exports = Cache;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var Stringify = __webpack_require__(190);
	var Parse = __webpack_require__(189);

	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var Utils = __webpack_require__(75);

	var has = Object.prototype.hasOwnProperty;

	var defaults = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false,
	    decoder: Utils.decode
	};

	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part);
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos));
	            val = options.decoder(part.slice(pos + 1));
	        }
	        if (has.call(obj, key)) {
	            obj[key] = [].concat(obj[key]).concat(val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var Utils = __webpack_require__(75);

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var defaults = {
	    delimiter: '&',
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true,
	    encoder: Utils.encode
	};

	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
	        if (encoder) {
	            return [encoder(prefix) + '=' + encoder(obj)];
	        }
	        return [prefix + '=' + String(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        } else {
	            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? typeof options.encoder === 'function' ? options.encoder : defaults.encoder : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;

	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	    }

	    return keys.join(delimiter);
	};

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var Boom = __webpack_require__(63);
	var Hoek = __webpack_require__(22);
	var Stream = __webpack_require__(3);

	// Declare internals

	var internals = {};

	module.exports = internals.Recorder = function (options) {

	    Stream.Writable.call(this);

	    this.settings = options; // No need to clone since called internally with new object
	    this.buffers = [];
	    this.length = 0;
	};

	Hoek.inherits(internals.Recorder, Stream.Writable);

	internals.Recorder.prototype._write = function (chunk, encoding, next) {

	    if (this.settings.maxBytes && this.length + chunk.length > this.settings.maxBytes) {

	        return this.emit('error', Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));
	    }

	    this.length = this.length + chunk.length;
	    this.buffers.push(chunk);
	    next();
	};

	internals.Recorder.prototype.collect = function () {

	    var buffer = this.buffers.length === 0 ? new Buffer(0) : this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length);
	    return buffer;
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	// Load modules

	var Hoek = __webpack_require__(22);
	var Stream = __webpack_require__(3);
	var Payload = __webpack_require__(77);

	// Declare internals

	var internals = {};

	module.exports = internals.Tap = function () {

	    Stream.Transform.call(this);
	    this.buffers = [];
	};

	Hoek.inherits(internals.Tap, Stream.Transform);

	internals.Tap.prototype._transform = function (chunk, encoding, next) {

	    this.buffers.push(chunk);
	    next(null, chunk);
	};

	internals.Tap.prototype.collect = function () {

	    return new Payload(this.buffers);
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var path = __webpack_require__(12);
	var EventEmitter = __webpack_require__(10).EventEmitter;
	var OrbitDB = __webpack_require__(112);
	var Crypto = __webpack_require__(36);
	var Post = __webpack_require__(111);
	var Logger = __webpack_require__(20);
	var LRU = __webpack_require__(114);
	var OrbitUser = __webpack_require__(58);
	var IdentityProviders = __webpack_require__(113);

	var logger = Logger.create("Orbit", { color: Logger.Colors.Green });
	__webpack_require__(20).setLogLevel('ERROR');

	var getAppPath = function getAppPath() {
	  return process.type && process.env.ENV !== "dev" ? process.resourcesPath + "/app/" : process.cwd();
	};

	var defaultOptions = {
	  keystorePath: path.join(getAppPath(), "/keys"), // path where to keep generates keys
	  cacheFile: path.join(getAppPath(), "/orbit-data.json"), // path to orbit-db cache file
	  maxHistory: 64 // how many messages to retrieve from history on joining a channel
	};

	var signKey = void 0;

	var Orbit = function () {
	  function Orbit(ipfs) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    _classCallCheck(this, Orbit);

	    this.events = new EventEmitter();
	    this._ipfs = ipfs;
	    this._orbitdb = null;
	    this._user = null;
	    this._channels = {};
	    this._peers = [];
	    this._pollPeersTimer = null;
	    this._options = Object.assign({}, defaultOptions);
	    this._cache = new LRU(1000);
	    Object.assign(this._options, options);
	    Crypto.useKeyStore(this._options.keystorePath);
	  }

	  /* Properties */

	  _createClass(Orbit, [{
	    key: 'connect',


	    /* Public methods */

	    value: function connect() {
	      var _this = this;

	      var credentials = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      logger.debug("Load cache from:", this._options.cacheFile);
	      logger.info('Connecting to Orbit as \'' + JSON.stringify(credentials));

	      if (typeof credentials === 'string') {
	        credentials = { provider: 'orbit', username: credentials };
	      }

	      return IdentityProviders.authorizeUser(this._ipfs, credentials).then(function (user) {
	        return _this._user = user;
	      }).then(function () {
	        return new OrbitDB(_this._ipfs, _this._user.id);
	      })
	      // .then(() => OrbitDB.connect(host, this.user.identityProvider.id, null, this._ipfs))
	      .then(function (orbitdb) {
	        _this._orbitdb = orbitdb;
	        _this._orbitdb.events.on('data', _this._handleMessage.bind(_this)); // Subscribe to updates in the database
	        _this._startPollingForPeers(); // Get peers from libp2p and update the local peers array
	        return;
	      }).then(function () {
	        logger.info('Connected to \'' + _this._orbitdb.network.name + '\' as \'' + _this.user.name);
	        _this.events.emit('connected', _this.network, _this.user);
	        return _this;
	      }).catch(function (e) {
	        return console.error(e);
	      });
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      if (this._orbitdb) {
	        logger.warn('Disconnected from \'' + this.network.name + '\'');
	        this._orbitdb.disconnect();
	        this._orbitdb = null;
	        this._user = null;
	        this._channels = {};
	        if (this._pollPeersTimer) clearInterval(this._pollPeersTimer);
	        this.events.emit('disconnected');
	      }
	    }
	  }, {
	    key: 'join',
	    value: function join(channel) {
	      logger.debug('Join #' + channel);

	      if (!channel || channel === '') return Promise.reject('Channel not specified');

	      if (this._channels[channel]) return Promise.resolve(false);

	      // console.log(this._user)
	      var dbOptions = {
	        cacheFile: '/' + this.user.id + this._options.cacheFile,
	        maxHistory: this._options.maxHistory
	      };

	      this._channels[channel] = {
	        name: channel,
	        password: null,
	        feed: this._orbitdb.eventlog(channel, dbOptions) // feed is the database instance
	      };

	      this.events.emit('joined', channel);
	      return Promise.resolve(true);
	    }
	  }, {
	    key: 'leave',
	    value: function leave(channel) {
	      if (this._channels[channel]) {
	        this._channels[channel].feed.close();
	        delete this._channels[channel];
	        logger.debug("Left channel #" + channel);
	      }
	      this.events.emit('left', channel);
	    }
	  }, {
	    key: 'send',
	    value: function send(channel, message, replyToHash) {
	      var _this2 = this;

	      if (!message || message === '') return Promise.reject('Can\'t send an empty message');

	      logger.debug('Send message to #' + channel + ': ' + message);

	      var data = {
	        content: message,
	        replyto: replyToHash || null,
	        from: this.user.id
	      };

	      return this._getChannelFeed(channel).then(function (feed) {
	        return _this2._postMessage(feed, Post.Types.Message, data, _this2._user._keys);
	      });
	    }
	  }, {
	    key: 'get',
	    value: function get(channel) {
	      var lessThanHash = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var greaterThanHash = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	      var amount = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

	      logger.debug('Get messages from #' + channel + ': ' + lessThanHash + ', ' + greaterThanHash + ', ' + amount);

	      var options = {
	        limit: amount,
	        lt: lessThanHash,
	        gte: greaterThanHash
	      };

	      return this._getChannelFeed(channel).then(function (feed) {
	        return feed.iterator(options).collect();
	      });
	    }
	  }, {
	    key: 'getPost',
	    value: function getPost(hash, withUserProfile) {
	      var _this3 = this;

	      var post = this._cache.get(hash);

	      if (post) {
	        Promise.resolve(post);
	      } else {
	        var _ret = function () {
	          var post = void 0,
	              signKey = void 0;
	          return {
	            v: _this3._ipfs.object.get(hash, { enc: 'base58' }).then(function (res) {
	              return post = JSON.parse(res.toJSON().Data);
	            }).then(function () {
	              return Crypto.importKeyFromIpfs(_this3._ipfs, post.signKey);
	            }).then(function (signKey) {
	              return Crypto.verify(post.sig, signKey, new Buffer(JSON.stringify({
	                content: post.content,
	                meta: post.meta,
	                replyto: post.replyto
	              })));
	            }).then(function () {
	              _this3._cache.set(hash, post);

	              if (withUserProfile) return _this3.getUser(post.meta.from).then(function (user) {
	                post.meta.from = user;
	                return post;
	              });

	              return post;
	            })
	          };
	        }();

	        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	      }
	    }

	    /*
	      addFile(channel, source) where source is:
	      {
	        // for all files, filename must be specified
	        filename: <filepath>,    // add an individual file
	        // and optionally use one of these in addition
	        directory: <path>,       // add a directory
	        buffer: <Buffer>,        // add a file from buffer
	        // optional meta data
	        meta: <meta data object>
	      }
	    */

	  }, {
	    key: 'addFile',
	    value: function addFile(channel, source) {
	      var _this4 = this;

	      if (!source || !source.filename && !source.directory) return Promise.reject('Filename or directory not specified');

	      var addToIpfsJs = function addToIpfsJs(ipfs, data) {
	        return ipfs.files.add(new Buffer(data)).then(function (result) {
	          return {
	            Hash: result[0].toJSON().Hash,
	            isDirectory: false
	          };
	        });
	      };

	      var addToIpfsGo = function addToIpfsGo(ipfs, filename, filePath) {
	        return ipfs.util.addFromFs(filePath, { recursive: true }).then(function (result) {
	          // last added hash is the filename --> we added a directory
	          // first added hash is the filename --> we added a file
	          var isDirectory = result[0].path.split('/').pop() !== filename;
	          return {
	            Hash: isDirectory ? result[result.length - 1].hash : result[0].hash,
	            isDirectory: isDirectory
	          };
	        });
	      };

	      logger.info("Adding file from path '" + source.filename + "'");

	      var isBuffer = source.buffer && source.filename ? true : false;
	      var name = source.directory ? source.directory.split("/").pop() : source.filename.split("/").pop();
	      var size = source.meta && source.meta.size ? source.meta.size : 0;

	      var feed = void 0,
	          addToIpfs = void 0;

	      if (isBuffer) // Adding from browsers
	        addToIpfs = function addToIpfs() {
	          return addToIpfsJs(_this4._ipfs, source.buffer);
	        };else if (source.directory) // Adding from Electron
	        addToIpfs = function addToIpfs() {
	          return addToIpfsGo(_this4._ipfs, name, source.directory);
	        };else addToIpfs = function addToIpfs() {
	        return addToIpfsGo(_this4._ipfs, name, source.filename);
	      };

	      return this._getChannelFeed(channel).then(function (res) {
	        return feed = res;
	      }).then(function () {
	        return addToIpfs();
	      }).then(function (result) {
	        logger.info("Added file '" + source.filename + "' as ", result);
	        // Create a post
	        var type = result.isDirectory ? Post.Types.Directory : Post.Types.File;
	        var data = {
	          name: name,
	          hash: result.Hash,
	          size: size,
	          from: _this4.user.id,
	          meta: source.meta || {}
	        };
	        return _this4._postMessage(feed, type, data, _this4._user._keys);
	      });
	    }
	  }, {
	    key: 'getFile',
	    value: function getFile(hash) {
	      return this._ipfs.cat(hash);
	    }
	  }, {
	    key: 'getDirectory',
	    value: function getDirectory(hash) {
	      return this._ipfs.ls(hash).then(function (res) {
	        return res.Objects[0].Links;
	      });
	    }
	  }, {
	    key: 'getUser',
	    value: function getUser(hash) {
	      var _this5 = this;

	      var user = this._cache.get(hash);
	      if (user) {
	        return Promise.resolve(user);
	      } else {
	        return this._ipfs.object.get(hash, { enc: 'base58' }).then(function (res) {
	          var profileData = Object.assign(JSON.parse(res.toJSON().Data));
	          Object.assign(profileData, { id: hash });
	          return IdentityProviders.loadProfile(_this5._ipfs, profileData).then(function (profile) {
	            Object.assign(profile || profileData, { id: hash });
	            _this5._cache.set(hash, profile);
	            return profile;
	          }).catch(function (e) {
	            logger.error(e);
	            return profileData;
	          });
	        });
	      }
	    }

	    /* Private methods */

	  }, {
	    key: '_postMessage',
	    value: function _postMessage(feed, postType, data, signKey) {
	      var post = void 0;
	      return Post.create(this._ipfs, postType, data, signKey).then(function (res) {
	        return post = res;
	      }).then(function () {
	        return feed.add(post.Hash);
	      }).then(function () {
	        return post;
	      });
	    }
	  }, {
	    key: '_getChannelFeed',
	    value: function _getChannelFeed(channel) {
	      var _this6 = this;

	      if (!channel || channel === '') return Promise.reject('Channel not specified');

	      return new Promise(function (resolve, reject) {
	        var feed = _this6._channels[channel] && _this6._channels[channel].feed ? _this6._channels[channel].feed : null;
	        if (!feed) reject('Haven\'t joined #' + channel);
	        resolve(feed);
	      });
	    }

	    // TODO: tests for everything below

	  }, {
	    key: '_handleMessage',
	    value: function _handleMessage(channel, message) {
	      logger.debug("New message in #", channel, "\n" + JSON.stringify(message, null, 2));
	      if (this._channels[channel]) this.events.emit('message', channel, message);
	    }
	  }, {
	    key: '_startPollingForPeers',
	    value: function _startPollingForPeers() {
	      var _this7 = this;

	      if (!this._pollPeersTimer) {
	        this._pollPeersTimer = setInterval(function () {
	          _this7._updateSwarmPeers().then(function (peers) {
	            _this7._peers = peers || [];
	            // TODO: get unique (new) peers and emit 'peer' for each instead of all at once
	            _this7.events.emit('peers', _this7._peers);
	          });
	        }, 3000);
	      }
	    }
	  }, {
	    key: '_updateSwarmPeers',
	    value: function _updateSwarmPeers() {
	      var _this8 = this;

	      if (this._ipfs.libp2p && this._ipfs.libp2p.swarm.peers) {
	        // js-_ipfs
	        return new Promise(function (resolve, reject) {
	          _this8._ipfs.libp2p.swarm.peers(function (err, peers) {
	            if (err) reject(err);
	            resolve(peers);
	          });
	        }).then(function (peers) {
	          return Object.keys(peers).map(function (e) {
	            return peers[e].multiaddrs[0].toString();
	          });
	        });
	      } else {
	        // js-_ipfs-api
	        return new Promise(function (resolve, reject) {
	          return _this8._ipfs.swarm.peers(function (err, res) {
	            if (err) reject(err);
	            resolve(res);
	          });
	        }).then(function (peers) {
	          return peers.map(function (e) {
	            return e.toString();
	          });
	        });
	      }
	    }
	  }, {
	    key: 'user',
	    get: function get() {
	      return this._user ? this._user.profile : null;
	    }
	  }, {
	    key: 'network',
	    get: function get() {
	      return this._orbitdb ? this._orbitdb.network : null;
	    }
	  }, {
	    key: 'channels',
	    get: function get() {
	      return this._channels;
	    }
	  }, {
	    key: 'peers',
	    get: function get() {
	      return this._peers;
	    }
	  }]);

	  return Orbit;
	}();

	module.exports = Orbit;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Crypto = __webpack_require__(36);
	var OrbitUser = __webpack_require__(58);

	var OrbitIdentityProvider = function () {
	  function OrbitIdentityProvider() {
	    _classCallCheck(this, OrbitIdentityProvider);
	  }

	  _createClass(OrbitIdentityProvider, null, [{
	    key: 'authorize',
	    value: function authorize(ipfs) {
	      var credentials = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (credentials.provider !== OrbitIdentityProvider.id) throw new Error('OrbitIdentityProvider can\'t handle provider type \'' + credentials.provider + '\'');

	      if (!credentials.username) throw new Error("'username' not specified");

	      var keys = void 0,
	          profileData = void 0;
	      return Crypto.getKey(credentials.username).then(function (keyPair) {
	        keys = keyPair;
	        return Crypto.exportKeyToIpfs(ipfs, keys.publicKey);
	      }).then(function (pubKeyHash) {
	        profileData = {
	          name: credentials.username,
	          location: 'Earth',
	          image: null,
	          signKey: pubKeyHash,
	          updated: null,
	          identityProvider: {
	            provider: OrbitIdentityProvider.id,
	            id: null
	          }
	        };

	        return ipfs.object.put(new Buffer(JSON.stringify(profileData))).then(function (res) {
	          return res.toJSON().Hash;
	        });
	      }).then(function (hash) {
	        profileData.id = hash;
	        return new OrbitUser(keys, profileData);
	      });
	    }
	  }, {
	    key: 'load',
	    value: function load(ipfs) {
	      var profile = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      if (profile.identityProvider.provider !== OrbitIdentityProvider.id) throw new Error('OrbitIdentityProvider can\'t handle provider type \'' + profile.identityProvider.provider + '\'');

	      return Promise.resolve(profile);
	    }
	  }, {
	    key: 'id',
	    get: function get() {
	      return 'orbit';
	    }
	  }]);

	  return OrbitIdentityProvider;
	}();

	module.exports = OrbitIdentityProvider;

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}


/***/ },
/* 196 */
/***/ function(module, exports) {

	// base-x encoding
	// Forked from https://github.com/cryptocoinjs/bs58
	// Originally written by Mike Hearn for BitcoinJ
	// Copyright (c) 2011 Google Inc
	// Ported to JavaScript by Stefan Thomas
	// Merged Buffer refactorings from base58-native by Stephen Pair
	// Copyright (c) 2013 BitPay Inc

	module.exports = function base (ALPHABET) {
	  var ALPHABET_MAP = {}
	  var BASE = ALPHABET.length
	  var LEADER = ALPHABET.charAt(0)

	  // pre-compute lookup table
	  for (var i = 0; i < ALPHABET.length; i++) {
	    ALPHABET_MAP[ALPHABET.charAt(i)] = i
	  }

	  function encode (source) {
	    if (source.length === 0) return ''

	    var digits = [0]
	    for (var i = 0; i < source.length; ++i) {
	      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
	        carry += digits[j] << 8
	        digits[j] = carry % BASE
	        carry = (carry / BASE) | 0
	      }

	      while (carry > 0) {
	        digits.push(carry % BASE)
	        carry = (carry / BASE) | 0
	      }
	    }

	    // deal with leading zeros
	    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
	      digits.push(0)
	    }

	    // convert digits to a string
	    for (var ii = 0, jj = digits.length - 1; ii <= jj; ++ii, --jj) {
	      var tmp = ALPHABET[digits[ii]]
	      digits[ii] = ALPHABET[digits[jj]]
	      digits[jj] = tmp
	    }

	    return digits.join('')
	  }

	  function decode (string) {
	    if (string.length === 0) return []

	    var bytes = [0]
	    for (var i = 0; i < string.length; i++) {
	      var value = ALPHABET_MAP[string[i]]
	      if (value === undefined) throw new Error('Non-base' + BASE + ' character')

	      for (var j = 0, carry = value; j < bytes.length; ++j) {
	        carry += bytes[j] * BASE
	        bytes[j] = carry & 0xff
	        carry >>= 8
	      }

	      while (carry > 0) {
	        bytes.push(carry & 0xff)
	        carry >>= 8
	      }
	    }

	    // deal with leading zeros
	    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
	      bytes.push(0)
	    }

	    return bytes.reverse()
	  }

	  return {
	    encode: encode,
	    decode: decode
	  }
	}


/***/ },
/* 197 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = __webpack_require__(222);
	var Queue = __webpack_require__(219);
	var util = __webpack_require__(2);

	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}

	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};

	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};

	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};


	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};

	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = Async;
	module.exports.firstLineError = firstLineError;


/***/ },
/* 199 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};

	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = __webpack_require__(215)();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = __webpack_require__(2);
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (true) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};
	    if (true) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = __webpack_require__(2);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");

	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }

	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};

	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};

	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};

	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};

	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};

	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};

	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};

	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};

	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};

	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};

	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};

	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};

	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};

	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};

	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = __webpack_require__(2);
	var getKeys = __webpack_require__(17).keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];

	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}

	return catchFilter;
	};


/***/ },
/* 204 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];

	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};

	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};

	function createContext() {
	    if (longStackTraces) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = __webpack_require__(13).Warning;
	var util = __webpack_require__(2);
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (false ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));

	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));

	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};

	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();

	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();

	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}

	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};

	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }

	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }

	    return domEventFired || globalEventFired;
	};

	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;

	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	};

	function defaultFireEvent() { return false; }

	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};

	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}

	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;

	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}

	function cancellationOnCancel() {
	    return this._onCancelField;
	}

	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}

	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}

	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}

	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;

	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}

	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}

	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}

	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;

	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }

	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {

	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }

	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}

	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}

	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }

	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	}

	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}

	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}

	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}

	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}

	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};

	if (longStackTraces) Promise.longStackTraces();

	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};


/***/ },
/* 206 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}

	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};

	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};

	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;

	function promiseAllThis() {
	    return PromiseAll(this);
	}

	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};

	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};

	Promise.mapSeries = PromiseMapSeries;
	};



/***/ },
/* 208 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, tryConvertToPromise) {
	var util = __webpack_require__(2);
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;

	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}

	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};

	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}

	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};

	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}

	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }

	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}

	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};

	return PassThroughHandlerContext;
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = __webpack_require__(13);
	var TypeError = errors.TypeError;
	var util = __webpack_require__(2);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);

	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};

	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};

	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";

	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = __webpack_require__(2);
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (true) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };

	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;


	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";

	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);

	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };

	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];

	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }

	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (true) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;

	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }

	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(2);
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);

	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;

	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }

	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}

	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};

	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};


	};


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = __webpack_require__(2);
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise) {
	var util = __webpack_require__(2);
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = __webpack_require__(2);

	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);

	var es5 = __webpack_require__(17);
	var Async = __webpack_require__(198);
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = __webpack_require__(13);
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = __webpack_require__(226)(Promise, INTERNAL);
	var PromiseArray =
	    __webpack_require__(216)(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = __webpack_require__(204)(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = __webpack_require__(205)(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    __webpack_require__(209)(Promise, tryConvertToPromise);
	var catchFilter = __webpack_require__(203)(NEXT_FILTER);
	var nodebackForPromise = __webpack_require__(78);
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	    if (self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	}

	function Promise(executor) {
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    if (executor !== INTERNAL) {
	        check(this, executor);
	        this._resolveFromExecutor(executor);
	    }
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("expecting an object but got " +
	                    "A catch statement predicate " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.getNewLibraryCopy = module.exports;

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;

	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }

	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }

	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }

	    return promise;
	};

	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};

	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};

	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};

	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};

	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};

	Promise.prototype._boundValue = function() {};

	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();

	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    if (shouldBind) this._propagateFrom(maybePromise, 2);

	    var promise = maybePromise._target();

	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }

	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};

	Promise.prototype._resolveFromExecutor = function (executor) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;

	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();

	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};

	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};

	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};

	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};

	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;

	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};

	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;

	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }

	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};

	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};

	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);

	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};

	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};

	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}

	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};

	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);

	__webpack_require__(213)(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	__webpack_require__(199)(Promise, INTERNAL, tryConvertToPromise, debug);
	__webpack_require__(202)(Promise, PromiseArray, apiRejection, debug);
	__webpack_require__(206)(Promise);
	__webpack_require__(225)(Promise);
	__webpack_require__(211)(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.4.6";
	__webpack_require__(212)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(201)(Promise);
	__webpack_require__(228)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	__webpack_require__(227)(Promise, INTERNAL, debug);
	__webpack_require__(210)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	__webpack_require__(214)(Promise);
	__webpack_require__(217)(Promise, INTERNAL);
	__webpack_require__(218)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	__webpack_require__(220)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	__webpack_require__(221)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	__webpack_require__(223)(Promise, PromiseArray, debug);
	__webpack_require__(224)(Promise, PromiseArray, apiRejection);
	__webpack_require__(208)(Promise, INTERNAL);
	__webpack_require__(207)(Promise, INTERNAL);
	__webpack_require__(197)(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          

	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = __webpack_require__(2);
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);

	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;

	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};

	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);

	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }

	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};

	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};

	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};

	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};

	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = __webpack_require__(2);
	var nodebackForPromise = __webpack_require__(78);
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = __webpack_require__(13).TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (true) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}

	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};



/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(2);
	var isObject = util.isObject;
	var es5 = __webpack_require__(17);
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;

	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;

	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }

	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();

	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};

	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = __webpack_require__(2);

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = __webpack_require__(2);
	var tryCatch = util.tryCatch;

	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};

	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};

	ReductionPromiseArray.prototype._init = function() {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};

	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};

	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};

	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }

	    this._currentCancellable = value;

	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }

	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};

	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}

	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	var util = __webpack_require__(2);
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);

	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	                toggleScheduled = true;
	                div2.classList.toggle("foo");
	            };

	            return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = __webpack_require__(2);

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = __webpack_require__(2);
	var RangeError = __webpack_require__(13).RangeError;
	var AggregateError = __webpack_require__(13).AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}

	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};

	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};

	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};

	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};

	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};

	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};

	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};

	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};

	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};

	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};

	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};

	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};

	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};

	Promise.prototype.value = function() {
	    return value.call(this._target());
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};

	Promise.prototype._value = function() {
	    return this._settledValue();
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};

	Promise.PromiseInspection = PromiseInspection;
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = __webpack_require__(2);
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function doGetThen(obj) {
	    return obj.then;
	}

	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;

	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }

	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = __webpack_require__(2);
	var TimeoutError = Promise.TimeoutError;

	function HandleWrapper(handle)  {
	    this.handle = handle;
	}

	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};

	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);

	    if (parent != null) {
	        parent.cancel();
	    }
	};

	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}

	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;

	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));

	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }

	    return ret;
	};

	};


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = __webpack_require__(2);
	    var TypeError = __webpack_require__(13).TypeError;
	    var inherits = __webpack_require__(2).inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }

	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }

	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();

	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });

	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(234);
	var balanced = __webpack_require__(195);

	module.exports = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }

	  return expansions;
	}



/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var r;

	module.exports = function rand(len) {
	  if (!r)
	    r = new Rand(null);

	  return r.generate(len);
	};

	function Rand(rand) {
	  this.rand = rand;
	}
	module.exports.Rand = Rand;

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	if (typeof window === 'object') {
	  if (window.crypto && window.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      window.msCrypto.getRandomValues(arr);
	      return arr;
	    };
	  } else {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js or Web worker
	  try {
	    var crypto = __webpack_require__(9);

	    Rand.prototype._rand = function _rand(n) {
	      return crypto.randomBytes(n);
	    };
	  } catch (e) {
	    // Emulate crypto API using randy
	    Rand.prototype._rand = function _rand(n) {
	      var res = new Uint8Array(n);
	      for (var i = 0; i < res.length; i++)
	        res[i] = this.rand.getByte();
	      return res;
	    };
	  }
	}


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9)

	exports.createCipher = exports.Cipher = crypto.createCipher
	exports.createCipheriv = exports.Cipheriv = crypto.createCipheriv
	exports.createDecipher = exports.Decipher = crypto.createDecipher
	exports.createDecipheriv = exports.Decipheriv = crypto.createDecipheriv
	exports.listCiphers = exports.getCiphers = crypto.getCiphers


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	'use strict'
	exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha224',
	  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
	}
	exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha256',
	  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
	}
	exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha384',
	  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
	}
	exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'sha512',
	  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
	}
	exports['RSA-SHA1'] = {
	  sign: 'rsa',
	  hash: 'sha1',
	  id: new Buffer('3021300906052b0e03021a05000414', 'hex')
	}
	exports['ecdsa-with-SHA1'] = {
	  sign: 'ecdsa',
	  hash: 'sha1',
	  id: new Buffer('', 'hex')
	}

	exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
	  sign: 'dsa',
	  hash: 'sha1',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
	  sign: 'dsa',
	  hash: 'sha224',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
	  sign: 'dsa',
	  hash: 'sha256',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
	  sign: 'dsa',
	  hash: 'sha384',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
	  sign: 'dsa',
	  hash: 'sha512',
	  id: new Buffer('', 'hex')
	}
	exports['DSA-RIPEMD160'] = {
	  sign: 'dsa',
	  hash: 'rmd160',
	  id: new Buffer('', 'hex')
	}
	exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
	  sign: 'rsa',
	  hash: 'rmd160',
	  id: new Buffer('3021300906052b2403020105000414', 'hex')
	}
	exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
	  sign: 'rsa',
	  hash: 'md5',
	  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
	}


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9)

	exports.createSign = crypto.createSign
	exports.Sign = crypto.Sign

	exports.createVerify = crypto.createVerify
	exports.Verify = crypto.Verify


/***/ },
/* 234 */
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var elliptic = __webpack_require__(8);
	var BN = __webpack_require__(5);

	module.exports = function createECDH(curve) {
		return new ECDH(curve);
	};

	var aliases = {
		secp256k1: {
			name: 'secp256k1',
			byteLength: 32
		},
		secp224r1: {
			name: 'p224',
			byteLength: 28
		},
		prime256v1: {
			name: 'p256',
			byteLength: 32
		},
		prime192v1: {
			name: 'p192',
			byteLength: 24
		},
		ed25519: {
			name: 'ed25519',
			byteLength: 32
		},
		secp384r1: {
			name: 'p384',
			byteLength: 48
		},
		secp521r1: {
			name: 'p521',
			byteLength: 66
		}
	};

	aliases.p224 = aliases.secp224r1;
	aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
	aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
	aliases.p384 = aliases.secp384r1;
	aliases.p521 = aliases.secp521r1;

	function ECDH(curve) {
		this.curveType = aliases[curve];
		if (!this.curveType ) {
			this.curveType = {
				name: curve
			};
		}
		this.curve = new elliptic.ec(this.curveType.name);
		this.keys = void 0;
	}

	ECDH.prototype.generateKeys = function (enc, format) {
		this.keys = this.curve.genKeyPair();
		return this.getPublicKey(enc, format);
	};

	ECDH.prototype.computeSecret = function (other, inenc, enc) {
		inenc = inenc || 'utf8';
		if (!Buffer.isBuffer(other)) {
			other = new Buffer(other, inenc);
		}
		var otherPub = this.curve.keyFromPublic(other).getPublic();
		var out = otherPub.mul(this.keys.getPrivate()).getX();
		return formatReturnValue(out, enc, this.curveType.byteLength);
	};

	ECDH.prototype.getPublicKey = function (enc, format) {
		var key = this.keys.getPublic(format === 'compressed', true);
		if (format === 'hybrid') {
			if (key[key.length - 1] % 2) {
				key[0] = 7;
			} else {
				key [0] = 6;
			}
		}
		return formatReturnValue(key, enc);
	};

	ECDH.prototype.getPrivateKey = function (enc) {
		return formatReturnValue(this.keys.getPrivate(), enc);
	};

	ECDH.prototype.setPublicKey = function (pub, enc) {
		enc = enc || 'utf8';
		if (!Buffer.isBuffer(pub)) {
			pub = new Buffer(pub, enc);
		}
		this.keys._importPublic(pub);
		return this;
	};

	ECDH.prototype.setPrivateKey = function (priv, enc) {
		enc = enc || 'utf8';
		if (!Buffer.isBuffer(priv)) {
			priv = new Buffer(priv, enc);
		}
		var _priv = new BN(priv);
		_priv = _priv.toString(16);
		this.keys._importPrivate(_priv);
		return this;
	};

	function formatReturnValue(bn, enc, len) {
		if (!Array.isArray(bn)) {
			bn = bn.toArray();
		}
		var buf = new Buffer(bn);
		if (len && buf.length < len) {
			var zeros = new Buffer(len - buf.length);
			zeros.fill(0);
			buf = Buffer.concat([zeros, buf]);
		}
		if (!enc) {
			return buf;
		} else {
			return buf.toString(enc);
		}
	}


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var createECDH = __webpack_require__(9).createECDH;

	module.exports = createECDH || __webpack_require__(235);

/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	'use strict';
	var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	exports.hash = hash;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';
	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(237);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9).createHmac;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(52)
	exports.createHash = exports.Hash = __webpack_require__(32)
	exports.createHmac = exports.Hmac = __webpack_require__(239)

	var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(__webpack_require__(232)))
	exports.getHashes = function () {
	  return hashes
	}

	var p = __webpack_require__(95)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync

	var aes = __webpack_require__(231)
	;[
	  'Cipher',
	  'createCipher',
	  'Cipheriv',
	  'createCipheriv',
	  'Decipher',
	  'createDecipher',
	  'Decipheriv',
	  'createDecipheriv',
	  'getCiphers',
	  'listCiphers'
	].forEach(function (key) {
	  exports[key] = aes[key]
	})

	var dh = __webpack_require__(241)
	;[
	  'DiffieHellmanGroup',
	  'createDiffieHellmanGroup',
	  'getDiffieHellman',
	  'createDiffieHellman',
	  'DiffieHellman'
	].forEach(function (key) {
	  exports[key] = dh[key]
	})

	var sign = __webpack_require__(233)
	;[
	  'createSign',
	  'Sign',
	  'createVerify',
	  'Verify'
	].forEach(function (key) {
	  exports[key] = sign[key]
	})

	exports.createECDH = __webpack_require__(236)

	var publicEncrypt = __webpack_require__(331)

	;[
	  'publicEncrypt',
	  'privateEncrypt',
	  'publicDecrypt',
	  'privateDecrypt'
	].forEach(function (key) {
	  exports[key] = publicEncrypt[key]
	})

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	;[
	  'createCredentials'
	].forEach(function (name) {
	  exports[name] = function () {
	    throw new Error([
	      'sorry, ' + name + ' is not implemented yet',
	      'we accept pull requests',
	      'https://github.com/crypto-browserify/crypto-browserify'
	    ].join('\n'))
	  }
	})


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9)

	// getDiffieHellman
	exports.DiffieHellmanGroup = crypto.DiffieHellmanGroup
	exports.createDiffieHellmanGroup = crypto.createDiffieHellmanGroup
	exports.getDiffieHellman = crypto.getDiffieHellman

	// createDiffieHellman
	exports.createDiffieHellman = crypto.createDiffieHellman
	exports.DiffieHellman = crypto.DiffieHellman


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var BN = __webpack_require__(5);
	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var getNAF = utils.getNAF;
	var getJSF = utils.getJSF;
	var assert = utils.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new BN(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

	  // Useful for many curves
	  this.zero = new BN(0).toRed(this.red);
	  this.one = new BN(1).toRed(this.red);
	  this.two = new BN(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new BN(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	module.exports = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  for (var j = 0; j < naf.length; j += doubles.step) {
	    var nafW = 0;
	    for (var k = j + doubles.step - 1; k >= j; k--)
	      nafW = (nafW << 1) + naf[k];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (var j = 0; j < repr.length; j++) {
	      var nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var k = 0; i >= 0 && naf[i] === 0; i--)
	      k++;
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	                                                       points,
	                                                       coeffs,
	                                                       len,
	                                                       jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  for (var i = 0; i < len; i++) {
	    var p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (var i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a]);
	      naf[b] = getNAF(coeffs[b], wndWidth[b]);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b] /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (var j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (var i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (var j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (var j = 0; j < len; j++) {
	      var z = tmp[j];
	      var p;
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (var i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	                          bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var curve = __webpack_require__(33);
	var elliptic = __webpack_require__(8);
	var BN = __webpack_require__(5);
	var inherits = __webpack_require__(1);
	var Base = curve.base;

	var assert = elliptic.utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new BN(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new BN(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new BN(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits(EdwardsCurve, Base);
	module.exports = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new BN(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - 1) / (d y^2 + 1)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.one);
	  var rhs = y2.redMul(this.d).redAdd(this.one);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = z ? new BN(z, 16) : this.curve.one;
	    this.t = t && new BN(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	         this.y.cmp(this.z) === 0;
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // E = a * C
	    var e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      var h = this.z.redSqr();
	      // J = F - 2 * H
	      var j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    var e = c.redAdd(d);
	    // H = (c * Z1)^2
	    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
	    // J = E - 2 * H
	    var j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	                          this.y,
	                          this.z,
	                          this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	  return false;
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var curve = __webpack_require__(33);
	var BN = __webpack_require__(5);
	var inherits = __webpack_require__(1);
	var Base = curve.base;

	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.i4 = new BN(4).toRed(this.red).redInvm();
	  this.two = new BN(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	module.exports = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new BN(x, 16);
	    this.z = new BN(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var curve = __webpack_require__(33);
	var elliptic = __webpack_require__(8);
	var BN = __webpack_require__(5);
	var inherits = __webpack_require__(1);
	var Base = curve.base;

	var assert = elliptic.utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	module.exports = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new BN(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new BN(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new BN(vec.a, 16),
	        b: new BN(vec.b, 16)
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : BN.mont(num);
	  var tinv = new BN(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new BN(1);
	  var y1 = new BN(0);
	  var x2 = new BN(0);
	  var y2 = new BN(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 }
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	  var npoints = this._endoWnafT1;
	  var ncoeffs = this._endoWnafT2;
	  for (var i = 0; i < points.length; i++) {
	    var split = this._endoSplit(coeffs[i]);
	    var p = points[i];
	    var beta = p._getBeta();

	    if (split.k1.negative) {
	      split.k1.ineg();
	      p = p.neg(true);
	    }
	    if (split.k2.negative) {
	      split.k2.ineg();
	      beta = beta.neg(true);
	    }

	    npoints[i * 2] = p;
	    npoints[i * 2 + 1] = beta;
	    ncoeffs[i * 2] = split.k1;
	    ncoeffs[i * 2 + 1] = split.k2;
	  }
	  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	  // Clean-up references to points and coefficients
	  for (var j = 0; j < i * 2; j++) {
	    npoints[j] = null;
	    ncoeffs[j] = null;
	  }
	  return res;
	};

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul)
	      }
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1)
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1)
	    }
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point))
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point))
	    }
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new BN(k, 16);

	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate)
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate)
	      }
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new BN(0);
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = new BN(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (var i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (var i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new BN(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	  return false;
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var curves = exports;

	var hash = __webpack_require__(14);
	var elliptic = __webpack_require__(8);

	var assert = elliptic.utils.assert;

	function PresetCurve(options) {
	  if (options.type === 'short')
	    this.curve = new elliptic.curve.short(options);
	  else if (options.type === 'edwards')
	    this.curve = new elliptic.curve.edwards(options);
	  else
	    this.curve = new elliptic.curve.mont(options);
	  this.g = this.curve.g;
	  this.n = this.curve.n;
	  this.hash = options.hash;

	  assert(this.g.validate(), 'Invalid curve');
	  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
	}
	curves.PresetCurve = PresetCurve;

	function defineCurve(name, options) {
	  Object.defineProperty(curves, name, {
	    configurable: true,
	    enumerable: true,
	    get: function() {
	      var curve = new PresetCurve(options);
	      Object.defineProperty(curves, name, {
	        configurable: true,
	        enumerable: true,
	        value: curve
	      });
	      return curve;
	    }
	  });
	}

	defineCurve('p192', {
	  type: 'short',
	  prime: 'p192',
	  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
	  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
	  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
	    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
	  ]
	});

	defineCurve('p224', {
	  type: 'short',
	  prime: 'p224',
	  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
	  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
	  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
	  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
	    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
	  ]
	});

	defineCurve('p256', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
	  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
	  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
	  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
	    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
	  ]
	});

	defineCurve('p384', {
	  type: 'short',
	  prime: null,
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 ffffffff',
	  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'fffffffe ffffffff 00000000 00000000 fffffffc',
	  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
	     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
	  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
	     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
	  hash: hash.sha384,
	  gRed: false,
	  g: [
	    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
	    '5502f25d bf55296c 3a545e38 72760ab7',
	    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
	    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
	  ]
	});

	defineCurve('p521', {
	  type: 'short',
	  prime: null,
	  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff',
	  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff ffffffff ffffffff fffffffc',
	  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
	     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
	     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
	  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
	     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
	     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
	  hash: hash.sha512,
	  gRed: false,
	  g: [
	    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
	    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
	    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
	    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
	    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
	    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
	  ]
	});

	defineCurve('curve25519', {
	  type: 'mont',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '76d06',
	  b: '0',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '9'
	  ]
	});

	defineCurve('ed25519', {
	  type: 'edwards',
	  prime: 'p25519',
	  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
	  a: '-1',
	  c: '1',
	  // -121665 * (121666^(-1)) (mod P)
	  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
	  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
	  hash: hash.sha256,
	  gRed: false,
	  g: [
	    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

	    // 4/5
	    '6666666666666666666666666666666666666666666666666666666666666658'
	  ]
	});

	var pre;
	try {
	  pre = __webpack_require__(254);
	} catch (e) {
	  pre = undefined;
	}

	defineCurve('secp256k1', {
	  type: 'short',
	  prime: 'k256',
	  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
	  a: '0',
	  b: '7',
	  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
	  h: '1',
	  hash: hash.sha256,

	  // Precomputed endomorphism
	  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
	  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
	  basis: [
	    {
	      a: '3086d221a7d46bcde86c90e49284eb15',
	      b: '-e4437ed6010e88286f547fa90abfe4c3'
	    },
	    {
	      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
	      b: '3086d221a7d46bcde86c90e49284eb15'
	    }
	  ],

	  gRed: false,
	  g: [
	    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
	    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	    pre
	  ]
	});


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var BN = __webpack_require__(5);
	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;

	var KeyPair = __webpack_require__(248);
	var Signature = __webpack_require__(249);

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

	    options = elliptic.curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof elliptic.curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	module.exports = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new KeyPair(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return KeyPair.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return KeyPair.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
	    nonce: this.n.toArray()
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new BN(2));
	  do {
	    var priv = new BN(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  } while (true);
	};

	EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new BN(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray('be', bytes);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray('be', bytes);

	  // Instantiate Hmac_DRBG
	  var drbg = new elliptic.hmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce,
	    pers: options.pers,
	    persEnc: options.persEnc
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new BN(1));

	  for (var iter = 0; true; iter++) {
	    var k = options.k ?
	        options.k(iter) :
	        new BN(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
	  }
	};

	EC.prototype.verify = function verify(msg, signature, key, enc) {
	  msg = this._truncateToN(new BN(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);

	  if (!this.curve._maxwellTrick) {
	    var p = this.g.mulAdd(u1, key.getPublic(), u2);
	    if (p.isInfinity())
	      return false;

	    return p.getX().umod(this.n).cmp(r) === 0;
	  }

	  // NOTE: Greg Maxwell's trick, inspired by:
	  // https://git.io/vad3K

	  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  // Compare `p.x` of Jacobian point with `r`,
	  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
	  // inverse of `p.z^2`
	  return p.eqXToP(r);
	};

	EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
	  assert((3 & j) === j, 'The recovery param is more than two bits');
	  signature = new Signature(signature, enc);

	  var n = this.n;
	  var e = new BN(msg);
	  var r = signature.r;
	  var s = signature.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var eNeg = n.sub(e);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  var rInv = signature.r.invm(n);
	  return this.g.mulAdd(eNeg, r, s).mul(rInv);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
	  signature = new Signature(signature, enc);
	  if (signature.recoveryParam !== null)
	    return signature.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime;
	    try {
	      Qprime = this.recoverPubKey(e, signature, i);
	    } catch (e) {
	      continue;
	    }

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var BN = __webpack_require__(5);

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	module.exports = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new BN(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var BN = __webpack_require__(5);

	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert(options.r && options.s, 'Signature without r or s');
	  this.r = new BN(options.r, 16);
	  this.s = new BN(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	module.exports = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;
	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	  }
	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0 && (r[1] & 0x80)) {
	    r = r.slice(1);
	  }
	  if (s[0] === 0 && (s[1] & 0x80)) {
	    s = s.slice(1);
	  }

	  this.r = new BN(r);
	  this.s = new BN(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils.encode(res, enc);
	};


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var hash = __webpack_require__(14);
	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = __webpack_require__(251);
	var Signature = __webpack_require__(252);

	function EDDSA(curve) {
	  assert(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  var curve = elliptic.curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	module.exports = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	               .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var cachedProperty = utils.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair)
	    return pub;
	  return new KeyPair(eddsa, { pub: pub });
	};

	KeyPair.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair)
	    return secret;
	  return new KeyPair(eddsa, { secret: secret });
	};

	KeyPair.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair.prototype.sign = function sign(message) {
	  assert(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair.prototype.getSecret = function getSecret(enc) {
	  assert(this._secret, 'KeyPair is public only');
	  return utils.encode(this.secret(), enc);
	};

	KeyPair.prototype.getPublic = function getPublic(enc) {
	  return utils.encode(this.pubBytes(), enc);
	};

	module.exports = KeyPair;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var BN = __webpack_require__(5);
	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;
	var cachedProperty = utils.cachedProperty;
	var parseBytes = utils.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength)
	    };
	  }

	  assert(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof BN)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature.prototype.toHex = function toHex() {
	  return utils.encode(this.toBytes(), 'hex').toUpperCase();
	};

	module.exports = Signature;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var hash = __webpack_require__(14);
	var elliptic = __webpack_require__(8);
	var utils = elliptic.utils;
	var assert = utils.assert;

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this.reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils.toArray(options.entropy, options.entropyEnc);
	  var nonce = utils.toArray(options.nonce, options.nonceEnc);
	  var pers = utils.toArray(options.pers, options.persEnc);
	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	module.exports = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this.reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils.toBuffer(entropy, entropyEnc);
	  add = utils.toBuffer(add, addEnc);

	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this.reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this.reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils.toArray(add, addEnc);
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this.reseed++;
	  return utils.encode(res, enc);
	};


/***/ },
/* 254 */
/***/ function(module, exports) {

	module.exports = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
	      ]
	    ]
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
	      ]
	    ]
	  }
	};


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var utils = exports;
	var BN = __webpack_require__(5);

	utils.assert = function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	};

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg !== 'string') {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	    return res;
	  }
	  if (!enc) {
	    for (var i = 0; i < msg.length; i++) {
	      var c = msg.charCodeAt(i);
	      var hi = c >> 8;
	      var lo = c & 0xff;
	      if (hi)
	        res.push(hi, lo);
	      else
	        res.push(lo);
	    }
	  } else if (enc === 'hex') {
	    msg = msg.replace(/[^a-z0-9]+/ig, '');
	    if (msg.length % 2 !== 0)
	      msg = '0' + msg;
	    for (var i = 0; i < msg.length; i += 2)
	      res.push(parseInt(msg[i] + msg[i + 1], 16));
	  }
	  return res;
	}
	utils.toArray = toArray;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	utils.encode = function encode(arr, enc) {
	  if (enc === 'hex')
	    return toHex(arr);
	  else
	    return arr;
	};

	// Represent num in a w-NAF form
	function getNAF(num, w) {
	  var naf = [];
	  var ws = 1 << (w + 1);
	  var k = num.clone();
	  while (k.cmpn(1) >= 0) {
	    var z;
	    if (k.isOdd()) {
	      var mod = k.andln(ws - 1);
	      if (mod > (ws >> 1) - 1)
	        z = (ws >> 1) - mod;
	      else
	        z = mod;
	      k.isubn(z);
	    } else {
	      z = 0;
	    }
	    naf.push(z);

	    // Optimization, shift by word if possible
	    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
	    for (var i = 1; i < shift; i++)
	      naf.push(0);
	    k.iushrn(shift);
	  }

	  return naf;
	}
	utils.getNAF = getNAF;

	// Represent k1, k2 in a Joint Sparse Form
	function getJSF(k1, k2) {
	  var jsf = [
	    [],
	    []
	  ];

	  k1 = k1.clone();
	  k2 = k2.clone();
	  var d1 = 0;
	  var d2 = 0;
	  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

	    // First phase
	    var m14 = (k1.andln(3) + d1) & 3;
	    var m24 = (k2.andln(3) + d2) & 3;
	    if (m14 === 3)
	      m14 = -1;
	    if (m24 === 3)
	      m24 = -1;
	    var u1;
	    if ((m14 & 1) === 0) {
	      u1 = 0;
	    } else {
	      var m8 = (k1.andln(7) + d1) & 7;
	      if ((m8 === 3 || m8 === 5) && m24 === 2)
	        u1 = -m14;
	      else
	        u1 = m14;
	    }
	    jsf[0].push(u1);

	    var u2;
	    if ((m24 & 1) === 0) {
	      u2 = 0;
	    } else {
	      var m8 = (k2.andln(7) + d2) & 7;
	      if ((m8 === 3 || m8 === 5) && m14 === 2)
	        u2 = -m24;
	      else
	        u2 = m24;
	    }
	    jsf[1].push(u2);

	    // Second phase
	    if (2 * d1 === u1 + 1)
	      d1 = 1 - d1;
	    if (2 * d2 === u2 + 1)
	      d2 = 1 - d2;
	    k1.iushrn(1);
	    k2.iushrn(1);
	  }

	  return jsf;
	}
	utils.getJSF = getJSF;

	function cachedProperty(obj, name, computer) {
	  var key = '_' + name;
	  obj.prototype[name] = function cachedProperty() {
	    return this[key] !== undefined ? this[key] :
	           this[key] = computer.call(this);
	  };
	}
	utils.cachedProperty = cachedProperty;

	function parseBytes(bytes) {
	  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
	                                     bytes;
	}
	utils.parseBytes = parseBytes;

	function intFromLE(bytes) {
	  return new BN(bytes, 'hex', 'le');
	}
	utils.intFromLE = intFromLE;



/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var once = __webpack_require__(257);

	var noop = function() {};

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var isChildProcess = function(stream) {
		return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback();
		};

		var onend = function() {
			readable = false;
			if (!writable) callback();
		};

		var onexit = function(exitCode) {
			callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
		};

		var onclose = function() {
			if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
			if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		if (isChildProcess(stream)) stream.on('exit', onexit);

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', callback);
		stream.on('close', onclose);

		return function() {
			stream.removeListener('complete', onfinish);
			stream.removeListener('abort', onclose);
			stream.removeListener('request', onrequest);
			if (stream.req) stream.req.removeListener('finish', onfinish);
			stream.removeListener('end', onlegacyfinish);
			stream.removeListener('close', onlegacyfinish);
			stream.removeListener('finish', onfinish);
			stream.removeListener('exit', onexit);
			stream.removeListener('end', onend);
			stream.removeListener('error', callback);
			stream.removeListener('close', onclose);
		};
	};

	module.exports = eos;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(54)
	module.exports = wrappy(once)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var md5 = __webpack_require__(238)
	module.exports = EVP_BytesToKey
	function EVP_BytesToKey (password, salt, keyLen, ivLen) {
	  if (!Buffer.isBuffer(password)) {
	    password = new Buffer(password, 'binary')
	  }
	  if (salt && !Buffer.isBuffer(salt)) {
	    salt = new Buffer(salt, 'binary')
	  }
	  keyLen = keyLen / 8
	  ivLen = ivLen || 0
	  var ki = 0
	  var ii = 0
	  var key = new Buffer(keyLen)
	  var iv = new Buffer(ivLen)
	  var addmd = 0
	  var md_buf
	  var i
	  var bufs = []
	  while (true) {
	    if (addmd++ > 0) {
	      bufs.push(md_buf)
	    }
	    bufs.push(password)
	    if (salt) {
	      bufs.push(salt)
	    }
	    md_buf = md5(Buffer.concat(bufs))
	    bufs = []
	    i = 0
	    if (keyLen > 0) {
	      while (true) {
	        if (keyLen === 0) {
	          break
	        }
	        if (i === md_buf.length) {
	          break
	        }
	        key[ki++] = md_buf[i]
	        keyLen--
	        i++
	      }
	    }
	    if (ivLen > 0 && i !== md_buf.length) {
	      while (true) {
	        if (ivLen === 0) {
	          break
	        }
	        if (i === md_buf.length) {
	          break
	        }
	        iv[ii++] = md_buf[i]
	        ivLen--
	        i++
	      }
	    }
	    if (keyLen === 0 && ivLen === 0) {
	      break
	    }
	  }
	  for (i = 0; i < md_buf.length; i++) {
	    md_buf[i] = 0
	  }
	  return {
	    key: key,
	    iv: iv
	  }
	}


/***/ },
/* 259 */
/***/ function(module, exports) {

	"use strict";
	"use strict";

	module.exports = function(arr, iter, context) {
	  var results = [];
	  if (!Array.isArray(arr)) return results;
	  arr.forEach(function(value, index, list) {
	    var res = iter.call(context, value, index, list);
	    if (Array.isArray(res)) {
	      results.push.apply(results, res);
	    } else if (res != null) {
	      results.push(res);
	    }
	  });
	  return results;
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var pathModule = __webpack_require__(12);
	var isWindows = process.platform === 'win32';
	var fs = __webpack_require__(11);

	// JavaScript implementation of realpath, ported from node pre-v6

	var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

	function rethrow() {
	  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
	  // is fairly slow to generate.
	  var callback;
	  if (DEBUG) {
	    var backtrace = new Error;
	    callback = debugCallback;
	  } else
	    callback = missingCallback;

	  return callback;

	  function debugCallback(err) {
	    if (err) {
	      backtrace.message = err.message;
	      err = backtrace;
	      missingCallback(err);
	    }
	  }

	  function missingCallback(err) {
	    if (err) {
	      if (process.throwDeprecation)
	        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
	      else if (!process.noDeprecation) {
	        var msg = 'fs: missing callback ' + (err.stack || err.message);
	        if (process.traceDeprecation)
	          console.trace(msg);
	        else
	          console.error(msg);
	      }
	    }
	  }
	}

	function maybeCallback(cb) {
	  return typeof cb === 'function' ? cb : rethrow();
	}

	var normalize = pathModule.normalize;

	// Regexp that finds the next partion of a (partial) path
	// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
	if (isWindows) {
	  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
	} else {
	  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
	}

	// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
	if (isWindows) {
	  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
	} else {
	  var splitRootRe = /^[\/]*/;
	}

	exports.realpathSync = function realpathSync(p, cache) {
	  // make p is absolute
	  p = pathModule.resolve(p);

	  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
	    return cache[p];
	  }

	  var original = p,
	      seenLinks = {},
	      knownHard = {};

	  // current character position in p
	  var pos;
	  // the partial path so far, including a trailing slash if any
	  var current;
	  // the partial path without a trailing slash (except when pointing at a root)
	  var base;
	  // the partial path scanned in the previous round, with slash
	  var previous;

	  start();

	  function start() {
	    // Skip over roots
	    var m = splitRootRe.exec(p);
	    pos = m[0].length;
	    current = m[0];
	    base = m[0];
	    previous = '';

	    // On windows, check that the root exists. On unix there is no need.
	    if (isWindows && !knownHard[base]) {
	      fs.lstatSync(base);
	      knownHard[base] = true;
	    }
	  }

	  // walk down the path, swapping out linked pathparts for their real
	  // values
	  // NB: p.length changes.
	  while (pos < p.length) {
	    // find the next part
	    nextPartRe.lastIndex = pos;
	    var result = nextPartRe.exec(p);
	    previous = current;
	    current += result[0];
	    base = previous + result[1];
	    pos = nextPartRe.lastIndex;

	    // continue if not a symlink
	    if (knownHard[base] || (cache && cache[base] === base)) {
	      continue;
	    }

	    var resolvedLink;
	    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
	      // some known symbolic link.  no need to stat again.
	      resolvedLink = cache[base];
	    } else {
	      var stat = fs.lstatSync(base);
	      if (!stat.isSymbolicLink()) {
	        knownHard[base] = true;
	        if (cache) cache[base] = base;
	        continue;
	      }

	      // read the link if it wasn't read before
	      // dev/ino always return 0 on windows, so skip the check.
	      var linkTarget = null;
	      if (!isWindows) {
	        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
	        if (seenLinks.hasOwnProperty(id)) {
	          linkTarget = seenLinks[id];
	        }
	      }
	      if (linkTarget === null) {
	        fs.statSync(base);
	        linkTarget = fs.readlinkSync(base);
	      }
	      resolvedLink = pathModule.resolve(previous, linkTarget);
	      // track this, if given a cache.
	      if (cache) cache[base] = resolvedLink;
	      if (!isWindows) seenLinks[id] = linkTarget;
	    }

	    // resolve the link, then start over
	    p = pathModule.resolve(resolvedLink, p.slice(pos));
	    start();
	  }

	  if (cache) cache[original] = p;

	  return p;
	};


	exports.realpath = function realpath(p, cache, cb) {
	  if (typeof cb !== 'function') {
	    cb = maybeCallback(cache);
	    cache = null;
	  }

	  // make p is absolute
	  p = pathModule.resolve(p);

	  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
	    return process.nextTick(cb.bind(null, null, cache[p]));
	  }

	  var original = p,
	      seenLinks = {},
	      knownHard = {};

	  // current character position in p
	  var pos;
	  // the partial path so far, including a trailing slash if any
	  var current;
	  // the partial path without a trailing slash (except when pointing at a root)
	  var base;
	  // the partial path scanned in the previous round, with slash
	  var previous;

	  start();

	  function start() {
	    // Skip over roots
	    var m = splitRootRe.exec(p);
	    pos = m[0].length;
	    current = m[0];
	    base = m[0];
	    previous = '';

	    // On windows, check that the root exists. On unix there is no need.
	    if (isWindows && !knownHard[base]) {
	      fs.lstat(base, function(err) {
	        if (err) return cb(err);
	        knownHard[base] = true;
	        LOOP();
	      });
	    } else {
	      process.nextTick(LOOP);
	    }
	  }

	  // walk down the path, swapping out linked pathparts for their real
	  // values
	  function LOOP() {
	    // stop if scanned past end of path
	    if (pos >= p.length) {
	      if (cache) cache[original] = p;
	      return cb(null, p);
	    }

	    // find the next part
	    nextPartRe.lastIndex = pos;
	    var result = nextPartRe.exec(p);
	    previous = current;
	    current += result[0];
	    base = previous + result[1];
	    pos = nextPartRe.lastIndex;

	    // continue if not a symlink
	    if (knownHard[base] || (cache && cache[base] === base)) {
	      return process.nextTick(LOOP);
	    }

	    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
	      // known symbolic link.  no need to stat again.
	      return gotResolvedLink(cache[base]);
	    }

	    return fs.lstat(base, gotStat);
	  }

	  function gotStat(err, stat) {
	    if (err) return cb(err);

	    // if not a symlink, skip to the next path part
	    if (!stat.isSymbolicLink()) {
	      knownHard[base] = true;
	      if (cache) cache[base] = base;
	      return process.nextTick(LOOP);
	    }

	    // stat & read the link if not read before
	    // call gotTarget as soon as the link target is known
	    // dev/ino always return 0 on windows, so skip the check.
	    if (!isWindows) {
	      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
	      if (seenLinks.hasOwnProperty(id)) {
	        return gotTarget(null, seenLinks[id], base);
	      }
	    }
	    fs.stat(base, function(err) {
	      if (err) return cb(err);

	      fs.readlink(base, function(err, target) {
	        if (!isWindows) seenLinks[id] = target;
	        gotTarget(err, target);
	      });
	    });
	  }

	  function gotTarget(err, target, base) {
	    if (err) return cb(err);

	    var resolvedLink = pathModule.resolve(previous, target);
	    if (cache) cache[base] = resolvedLink;
	    gotResolvedLink(resolvedLink);
	  }

	  function gotResolvedLink(resolvedLink) {
	    // resolve the link, then start over
	    p = pathModule.resolve(resolvedLink, p.slice(pos));
	    start();
	  }
	};


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4)

	var INDENT_START = /[\{\[]/
	var INDENT_END = /[\}\]]/

	module.exports = function() {
	  var lines = []
	  var indent = 0

	  var push = function(str) {
	    var spaces = ''
	    while (spaces.length < indent*2) spaces += '  '
	    lines.push(spaces+str)
	  }

	  var line = function(fmt) {
	    if (!fmt) return line

	    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_START.test(fmt[fmt.length-1])) {
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_END.test(fmt.trim()[0])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      return line
	    }

	    push(util.format.apply(util, arguments))
	    return line
	  }

	  line.toString = function() {
	    return lines.join('\n')
	  }

	  line.toFunction = function(scope) {
	    var src = 'return ('+line.toString()+')'

	    var keys = Object.keys(scope || {}).map(function(key) {
	      return key
	    })

	    var vals = keys.map(function(key) {
	      return scope[key]
	    })

	    return Function.apply(null, keys.concat(src)).apply(null, vals)
	  }

	  if (arguments.length) line.apply(null, arguments)

	  return line
	}


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	var isProperty = __webpack_require__(276)

	var gen = function(obj, prop) {
	  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
	}

	gen.valid = isProperty
	gen.property = function (prop) {
	 return isProperty(prop) ? prop : JSON.stringify(prop)
	}

	module.exports = gen


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = globSync
	globSync.GlobSync = GlobSync

	var fs = __webpack_require__(11)
	var rp = __webpack_require__(81)
	var minimatch = __webpack_require__(44)
	var Minimatch = minimatch.Minimatch
	var Glob = __webpack_require__(83).Glob
	var util = __webpack_require__(4)
	var path = __webpack_require__(12)
	var assert = __webpack_require__(55)
	var isAbsolute = __webpack_require__(46)
	var common = __webpack_require__(82)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var childrenIgnored = common.childrenIgnored

	function globSync (pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  return new GlobSync(pattern, options).found
	}

	function GlobSync (pattern, options) {
	  if (!pattern)
	    throw new Error('must provide pattern')

	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  if (!(this instanceof GlobSync))
	    return new GlobSync(pattern, options)

	  setopts(this, pattern, options)

	  if (this.noprocess)
	    return this

	  var n = this.minimatch.set.length
	  this.matches = new Array(n)
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false)
	  }
	  this._finish()
	}

	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync)
	  if (this.realpath) {
	    var self = this
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null)
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p)
	          var real = rp.realpathSync(p, self.realpathCache)
	          set[real] = true
	        } catch (er) {
	          if (er.syscall === 'stat')
	            set[self._makeAbs(p)] = true
	          else
	            throw er
	        }
	      }
	    })
	  }
	  common.finish(this)
	}


	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // See if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip processing
	  if (childrenIgnored(this, read))
	    return

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
	}


	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar)

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix.slice(-1) !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this.matches[index][e] = true
	    }
	    // This was the last one, and no stats were needed
	    return
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix)
	      newPattern = [prefix, e]
	    else
	      newPattern = [e]
	    this._process(newPattern.concat(remain), index, inGlobStar)
	  }
	}


	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e)
	  if (this.mark)
	    e = this._mark(e)

	  if (this.matches[index][e])
	    return

	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  this.matches[index][e] = true
	  if (this.stat)
	    this._stat(e)
	}


	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false)

	  var entries
	  var lstat
	  var stat
	  try {
	    lstat = fs.lstatSync(abs)
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null
	  }

	  var isSym = lstat.isSymbolicLink()
	  this.symlinks[abs] = isSym

	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory())
	    this.cache[abs] = 'FILE'
	  else
	    entries = this._readdir(abs, false)

	  return entries
	}

	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries

	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return null

	    if (Array.isArray(c))
	      return c
	  }

	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs))
	  } catch (er) {
	    this._readdirError(abs, er)
	    return null
	  }
	}

	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries

	  // mark and cache dir-ness
	  return entries
	}

	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      var abs = this._makeAbs(f)
	      this.cache[abs] = 'FILE'
	      if (abs === this.cwdAbs) {
	        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
	        error.path = this.cwd
	        error.code = er.code
	        throw error
	      }
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict)
	        throw er
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }
	}

	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

	  var entries = this._readdir(abs, inGlobStar)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false)

	  var len = entries.length
	  var isSym = this.symlinks[abs]

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true)
	  }
	}

	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this.matches[index][prefix] = true
	}

	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return false

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return c

	    if (needDir && c === 'FILE')
	      return false

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (!stat) {
	    var lstat
	    try {
	      lstat = fs.lstatSync(abs)
	    } catch (er) {
	      return false
	    }

	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs)
	      } catch (er) {
	        stat = lstat
	      }
	    } else {
	      stat = lstat
	    }
	  }

	  this.statCache[abs] = stat

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return false

	  return c
	}

	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(11)
	var polyfills = __webpack_require__(266)
	var legacy = __webpack_require__(265)
	var queue = []

	var util = __webpack_require__(4)

	function noop () {}

	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs4')
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
	    console.error(m)
	  }

	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug(queue)
	    __webpack_require__(55).equal(queue.length, 0)
	  })
	}

	module.exports = patch(__webpack_require__(84))
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs)
	}

	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	module.exports.close =
	fs.close = (function (fs$close) { return function (fd, cb) {
	  return fs$close.call(fs, fd, function (err) {
	    if (!err)
	      retry()

	    if (typeof cb === 'function')
	      cb.apply(this, arguments)
	  })
	}})(fs.close)

	module.exports.closeSync =
	fs.closeSync = (function (fs$closeSync) { return function (fd) {
	  // Note that graceful-fs also retries when fs.closeSync() fails.
	  // Looks like a bug to me, although it's probably a harmless one.
	  var rval = fs$closeSync.apply(fs, arguments)
	  retry()
	  return rval
	}})(fs.closeSync)

	function patch (fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs)
	  fs.gracefulify = patch
	  fs.FileReadStream = ReadStream;  // Legacy name.
	  fs.FileWriteStream = WriteStream;  // Legacy name.
	  fs.createReadStream = createReadStream
	  fs.createWriteStream = createWriteStream
	  var fs$readFile = fs.readFile
	  fs.readFile = readFile
	  function readFile (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null

	    return go$readFile(path, options, cb)

	    function go$readFile (path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readFile, [path, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }

	  var fs$writeFile = fs.writeFile
	  fs.writeFile = writeFile
	  function writeFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null

	    return go$writeFile(path, data, options, cb)

	    function go$writeFile (path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$writeFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }

	  var fs$appendFile = fs.appendFile
	  if (fs$appendFile)
	    fs.appendFile = appendFile
	  function appendFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null

	    return go$appendFile(path, data, options, cb)

	    function go$appendFile (path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$appendFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }

	  var fs$readdir = fs.readdir
	  fs.readdir = readdir
	  function readdir (path, cb) {
	    return go$readdir(path, cb)

	    function go$readdir () {
	      return fs$readdir(path, function (err, files) {
	        if (files && files.sort)
	          files.sort();  // Backwards compatibility with graceful-fs.

	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readdir, [path, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }


	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs)
	    ReadStream = legStreams.ReadStream
	    WriteStream = legStreams.WriteStream
	  }

	  var fs$ReadStream = fs.ReadStream
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
	  ReadStream.prototype.open = ReadStream$open

	  var fs$WriteStream = fs.WriteStream
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
	  WriteStream.prototype.open = WriteStream$open

	  fs.ReadStream = ReadStream
	  fs.WriteStream = WriteStream

	  function ReadStream (path, options) {
	    if (this instanceof ReadStream)
	      return fs$ReadStream.apply(this, arguments), this
	    else
	      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
	  }

	  function ReadStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose)
	          that.destroy()

	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	        that.read()
	      }
	    })
	  }

	  function WriteStream (path, options) {
	    if (this instanceof WriteStream)
	      return fs$WriteStream.apply(this, arguments), this
	    else
	      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
	  }

	  function WriteStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy()
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	      }
	    })
	  }

	  function createReadStream (path, options) {
	    return new ReadStream(path, options)
	  }

	  function createWriteStream (path, options) {
	    return new WriteStream(path, options)
	  }

	  var fs$open = fs.open
	  fs.open = open
	  function open (path, flags, mode, cb) {
	    if (typeof mode === 'function')
	      cb = mode, mode = null

	    return go$open(path, flags, mode, cb)

	    function go$open (path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$open, [path, flags, mode, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }

	  return fs
	}

	function enqueue (elem) {
	  debug('ENQUEUE', elem[0].name, elem[1])
	  queue.push(elem)
	}

	function retry () {
	  var elem = queue.shift()
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1])
	    elem[0].apply(null, elem[1])
	  }
	}


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(3).Stream

	module.exports = legacy

	function legacy (fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  }

	  function ReadStream (path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

	    Stream.call(this);

	    var self = this;

	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;

	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.encoding) this.setEncoding(this.encoding);

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }

	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }

	      this.pos = this.start;
	    }

	    if (this.fd !== null) {
	      process.nextTick(function() {
	        self._read();
	      });
	      return;
	    }

	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }

	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    })
	  }

	  function WriteStream (path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

	    Stream.call(this);

	    this.path = path;
	    this.fd = null;
	    this.writable = true;

	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;

	    options = options || {};

	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }

	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }

	      this.pos = this.start;
	    }

	    this.busy = false;
	    this._queue = [];

	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(84)
	var constants = __webpack_require__(109)

	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	try {
	  process.cwd()
	} catch (er) {}

	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}

	module.exports = patch

	function patch (fs) {
	  // (re-)implement some things that are known busted or missing.

	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') &&
	      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs)
	  }

	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs)
	  }

	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.

	  fs.chown = chownFix(fs.chown)
	  fs.fchown = chownFix(fs.fchown)
	  fs.lchown = chownFix(fs.lchown)

	  fs.chmod = chmodFix(fs.chmod)
	  fs.fchmod = chmodFix(fs.fchmod)
	  fs.lchmod = chmodFix(fs.lchmod)

	  fs.chownSync = chownFixSync(fs.chownSync)
	  fs.fchownSync = chownFixSync(fs.fchownSync)
	  fs.lchownSync = chownFixSync(fs.lchownSync)

	  fs.chmodSync = chmodFixSync(fs.chmodSync)
	  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
	  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      if (cb) process.nextTick(cb)
	    }
	    fs.lchmodSync = function () {}
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      if (cb) process.nextTick(cb)
	    }
	    fs.lchownSync = function () {}
	  }

	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 1 second.
	  if (process.platform === "win32") {
	    fs.rename = (function (fs$rename) { return function (from, to, cb) {
	      var start = Date.now()
	      fs$rename(from, to, function CB (er) {
	        if (er
	            && (er.code === "EACCES" || er.code === "EPERM")
	            && Date.now() - start < 1000) {
	          return fs$rename(from, to, CB)
	        }
	        if (cb) cb(er)
	      })
	    }})(fs.rename)
	  }

	  // if read() returns EAGAIN, then just try it again.
	  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
	    var callback
	    if (callback_ && typeof callback_ === 'function') {
	      var eagCounter = 0
	      callback = function (er, _, __) {
	        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	        }
	        callback_.apply(this, arguments)
	      }
	    }
	    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	  }})(fs.read)

	  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
	    var eagCounter = 0
	    while (true) {
	      try {
	        return fs$readSync.call(fs, fd, buffer, offset, length, position)
	      } catch (er) {
	        if (er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          continue
	        }
	        throw er
	      }
	    }
	  }})(fs.readSync)
	}

	function patchLchmod (fs) {
	  fs.lchmod = function (path, mode, callback) {
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        if (callback) callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          if (callback) callback(err || err2)
	        })
	      })
	    })
	  }

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true
	    var ret
	    try {
	      ret = fs.fchmodSync(fd, mode)
	      threw = false
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd)
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd)
	      }
	    }
	    return ret
	  }
	}

	function patchLutimes (fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        if (er) {
	          if (cb) cb(er)
	          return
	        }
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            if (cb) cb(er || er2)
	          })
	        })
	      })
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	      var ret
	      var threw = true
	      try {
	        ret = fs.futimesSync(fd, at, mt)
	        threw = false
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd)
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd)
	        }
	      }
	      return ret
	    }

	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}

	function chmodFix (orig) {
	  if (!orig) return orig
	  return function (target, mode, cb) {
	    return orig.call(fs, target, mode, function (er) {
	      if (chownErOk(er)) er = null
	      if (cb) cb.apply(this, arguments)
	    })
	  }
	}

	function chmodFixSync (orig) {
	  if (!orig) return orig
	  return function (target, mode) {
	    try {
	      return orig.call(fs, target, mode)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}


	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er) {
	      if (chownErOk(er)) er = null
	      if (cb) cb.apply(this, arguments)
	    })
	  }
	}

	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}

	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true

	  if (er.code === "ENOSYS")
	    return true

	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }

	  return false
	}


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(14);
	var utils = hash.utils;
	var assert = utils.assert;

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	exports.BlockHash = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var hmac = exports;

	var hash = __webpack_require__(14);
	var utils = hash.utils;
	var assert = utils.assert;

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils.toArray(key, enc));
	}
	module.exports = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (var i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(14);
	var utils = hash.utils;

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_3 = utils.sum32_3;
	var sum32_4 = utils.sum32_4;
	var BlockHash = hash.common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils.inherits(RIPEMD160, BlockHash);
	exports.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'little');
	  else
	    return utils.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var hash = __webpack_require__(14);
	var utils = hash.utils;
	var assert = utils.assert;

	var rotr32 = utils.rotr32;
	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_4 = utils.sum32_4;
	var sum32_5 = utils.sum32_5;
	var rotr64_hi = utils.rotr64_hi;
	var rotr64_lo = utils.rotr64_lo;
	var shr64_hi = utils.shr64_hi;
	var shr64_lo = utils.shr64_lo;
	var sum64 = utils.sum64;
	var sum64_hi = utils.sum64_hi;
	var sum64_lo = utils.sum64_lo;
	var sum64_4_hi = utils.sum64_4_hi;
	var sum64_4_lo = utils.sum64_4_lo;
	var sum64_5_hi = utils.sum64_5_hi;
	var sum64_5_lo = utils.sum64_5_lo;
	var BlockHash = hash.common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash.call(this);
	  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils.inherits(SHA256, BlockHash);
	exports.sha256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32(T1, T2);
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	  this.h[5] = sum32(this.h[5], f);
	  this.h[6] = sum32(this.h[6], g);
	  this.h[7] = sum32(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils.inherits(SHA224, SHA256);
	exports.sha224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils.split32(this.h.slice(0, 7), 'big');
	};

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash.call(this);
	  this.h = [ 0x6a09e667, 0xf3bcc908,
	             0xbb67ae85, 0x84caa73b,
	             0x3c6ef372, 0xfe94f82b,
	             0xa54ff53a, 0x5f1d36f1,
	             0x510e527f, 0xade682d1,
	             0x9b05688c, 0x2b3e6c1f,
	             0x1f83d9ab, 0xfb41bd6b,
	             0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils.inherits(SHA512, BlockHash);
	exports.sha512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi(c0_hi, c0_lo,
	                      c1_hi, c1_lo,
	                      c2_hi, c2_lo,
	                      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
	                          c1_hi, c1_lo,
	                          c2_hi, c2_lo,
	                          c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
	                           c1_hi, c1_lo,
	                           c2_hi, c2_lo,
	                           c3_hi, c3_lo,
	                           c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
	                           c1_hi, c1_lo,
	                           c2_hi, c2_lo,
	                           c3_hi, c3_lo,
	                           c4_hi, c4_lo);

	    var c0_hi = s0_512_hi(ah, al);
	    var c0_lo = s0_512_lo(ah, al);
	    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
	    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64(this.h, 0, ah, al);
	  sum64(this.h, 2, bh, bl);
	  sum64(this.h, 4, ch, cl);
	  sum64(this.h, 6, dh, dl);
	  sum64(this.h, 8, eh, el);
	  sum64(this.h, 10, fh, fl);
	  sum64(this.h, 12, gh, gl);
	  sum64(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  SHA512.call(this);
	  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
	             0x629a292a, 0x367cd507,
	             0x9159015a, 0x3070dd17,
	             0x152fecd8, 0xf70e5939,
	             0x67332667, 0xffc00b31,
	             0x8eb44a87, 0x68581511,
	             0xdb0c2e0d, 0x64f98fa7,
	             0x47b5481d, 0xbefa4fa4 ];
	}
	utils.inherits(SHA384, SHA512);
	exports.sha384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils.split32(this.h.slice(0, 12), 'big');
	};

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash.call(this);
	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
	             0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils.inherits(SHA1, BlockHash);
	exports.sha1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (var i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}

	function s0_256(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}

	function s1_256(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}

	function g0_256(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}

	function g1_256(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}

	function ch64_hi(xh, xl, yh, yl, zh, zl) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh, zl) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 28);
	  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 28);
	  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 14);
	  var c1_hi = rotr64_hi(xh, xl, 18);
	  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 14);
	  var c1_lo = rotr64_lo(xh, xl, 18);
	  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 1);
	  var c1_hi = rotr64_hi(xh, xl, 8);
	  var c2_hi = shr64_hi(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 1);
	  var c1_lo = rotr64_lo(xh, xl, 8);
	  var c2_lo = shr64_lo(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 19);
	  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 19);
	  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var utils = exports;
	var inherits = __webpack_require__(1);

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        var hi = c >> 8;
	        var lo = c & 0xff;
	        if (hi)
	          res.push(hi, lo);
	        else
	          res.push(lo);
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (var i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (var i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils.toHex = toHex;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	utils.htonl = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	utils.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils.split32 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils.rotr32 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils.rotl32 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	utils.sum32 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	utils.sum32_3 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	utils.sum32_4 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	utils.sum32_5 = sum32_5;

	function assert(cond, msg) {
	  if (!cond)
	    throw new Error(msg || 'Assertion failed');
	}
	utils.assert = assert;

	utils.inherits = inherits;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	exports.sum64 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	};
	exports.sum64_hi = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	};
	exports.sum64_lo = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	};
	exports.sum64_4_hi = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	};
	exports.sum64_4_lo = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	};
	exports.sum64_5_hi = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	};
	exports.sum64_5_lo = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	};
	exports.rotr64_hi = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	};
	exports.rotr64_lo = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	};
	exports.shr64_hi = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	};
	exports.shr64_lo = shr64_lo;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @preserve
	 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
	 *
	 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
	 * @see http://github.com/homebrewing/brauhaus-diff
	 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	 * @see http://github.com/garycourt/murmurhash-js
	 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
	 * @see http://sites.google.com/site/murmurhash/
	 */
	(function(){
	    var cache;

	    // Call this function without `new` to use the cached object (good for
	    // single-threaded environments), or with `new` to create a new object.
	    //
	    // @param {string} key A UTF-16 or ASCII string
	    // @param {number} seed An optional positive integer
	    // @return {object} A MurmurHash3 object for incremental hashing
	    function MurmurHash3(key, seed) {
	        var m = this instanceof MurmurHash3 ? this : cache;
	        m.reset(seed)
	        if (typeof key === 'string' && key.length > 0) {
	            m.hash(key);
	        }

	        if (m !== this) {
	            return m;
	        }
	    };

	    // Incrementally add a string to this hash
	    //
	    // @param {string} key A UTF-16 or ASCII string
	    // @return {object} this
	    MurmurHash3.prototype.hash = function(key) {
	        var h1, k1, i, top, len;

	        len = key.length;
	        this.len += len;

	        k1 = this.k1;
	        i = 0;
	        switch (this.rem) {
	            case 0: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) : 0;
	            case 1: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 8 : 0;
	            case 2: k1 ^= len > i ? (key.charCodeAt(i++) & 0xffff) << 16 : 0;
	            case 3:
	                k1 ^= len > i ? (key.charCodeAt(i) & 0xff) << 24 : 0;
	                k1 ^= len > i ? (key.charCodeAt(i++) & 0xff00) >> 8 : 0;
	        }

	        this.rem = (len + this.rem) & 3; // & 3 is same as % 4
	        len -= this.rem;
	        if (len > 0) {
	            h1 = this.h1;
	            while (1) {
	                k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
	                k1 = (k1 << 15) | (k1 >>> 17);
	                k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;

	                h1 ^= k1;
	                h1 = (h1 << 13) | (h1 >>> 19);
	                h1 = (h1 * 5 + 0xe6546b64) & 0xffffffff;

	                if (i >= len) {
	                    break;
	                }

	                k1 = ((key.charCodeAt(i++) & 0xffff)) ^
	                     ((key.charCodeAt(i++) & 0xffff) << 8) ^
	                     ((key.charCodeAt(i++) & 0xffff) << 16);
	                top = key.charCodeAt(i++);
	                k1 ^= ((top & 0xff) << 24) ^
	                      ((top & 0xff00) >> 8);
	            }

	            k1 = 0;
	            switch (this.rem) {
	                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xffff) << 16;
	                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xffff) << 8;
	                case 1: k1 ^= (key.charCodeAt(i) & 0xffff);
	            }

	            this.h1 = h1;
	        }

	        this.k1 = k1;
	        return this;
	    };

	    // Get the result of this hash
	    //
	    // @return {number} The 32-bit hash
	    MurmurHash3.prototype.result = function() {
	        var k1, h1;
	        
	        k1 = this.k1;
	        h1 = this.h1;

	        if (k1 > 0) {
	            k1 = (k1 * 0x2d51 + (k1 & 0xffff) * 0xcc9e0000) & 0xffffffff;
	            k1 = (k1 << 15) | (k1 >>> 17);
	            k1 = (k1 * 0x3593 + (k1 & 0xffff) * 0x1b870000) & 0xffffffff;
	            h1 ^= k1;
	        }

	        h1 ^= this.len;

	        h1 ^= h1 >>> 16;
	        h1 = (h1 * 0xca6b + (h1 & 0xffff) * 0x85eb0000) & 0xffffffff;
	        h1 ^= h1 >>> 13;
	        h1 = (h1 * 0xae35 + (h1 & 0xffff) * 0xc2b20000) & 0xffffffff;
	        h1 ^= h1 >>> 16;

	        return h1 >>> 0;
	    };

	    // Reset the hash object for reuse
	    //
	    // @param {number} seed An optional positive integer
	    MurmurHash3.prototype.reset = function(seed) {
	        this.h1 = typeof seed === 'number' ? seed : 0;
	        this.rem = this.k1 = this.len = 0;
	        return this;
	    };

	    // A cached object to use. This can be safely used if you're in a single-
	    // threaded environment, otherwise you need to create new hashes to use.
	    cache = new MurmurHash3();

	    if (true) {
	        module.exports = MurmurHash3;
	    } else {
	        this.MurmurHash3 = MurmurHash3;
	    }
	}());


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(54)
	var reqs = Object.create(null)
	var once = __webpack_require__(93)

	module.exports = wrappy(inflight)

	function inflight (key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb)
	    return null
	  } else {
	    reqs[key] = [cb]
	    return makeres(key)
	  }
	}

	function makeres (key) {
	  return once(function RES () {
	    var cbs = reqs[key]
	    var len = cbs.length
	    var args = slice(arguments)
	    for (var i = 0; i < len; i++) {
	      cbs[i].apply(null, args)
	    }
	    if (cbs.length > len) {
	      // added more in the interim.
	      // de-zalgo, just in case, but don't call again.
	      cbs.splice(0, len)
	      process.nextTick(function () {
	        RES.apply(null, args)
	      })
	    } else {
	      delete reqs[key]
	    }
	  })
	}

	function slice (args) {
	  var length = args.length
	  var array = []

	  for (var i = 0; i < length; i++) array[i] = args[i]
	  return array
	}


/***/ },
/* 274 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var ip = exports;
	var Buffer = __webpack_require__(6).Buffer;
	var os = __webpack_require__(57);

	ip.toBuffer = function(ip, buff, offset) {
	  offset = ~~offset;

	  var result;

	  if (this.isV4Format(ip)) {
	    result = buff || new Buffer(offset + 4);
	    ip.split(/\./g).map(function(byte) {
	      result[offset++] = parseInt(byte, 10) & 0xff;
	    });
	  } else if (this.isV6Format(ip)) {
	    var sections = ip.split(':', 8);

	    var i;
	    for (i = 0; i < sections.length; i++) {
	      var isv4 = this.isV4Format(sections[i]);
	      var v4Buffer;

	      if (isv4) {
	        v4Buffer = this.toBuffer(sections[i]);
	        sections[i] = v4Buffer.slice(0, 2).toString('hex');
	      }

	      if (v4Buffer && ++i < 8) {
	        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
	      }
	    }

	    if (sections[0] === '') {
	      while (sections.length < 8) sections.unshift('0');
	    } else if (sections[sections.length - 1] === '') {
	      while (sections.length < 8) sections.push('0');
	    } else if (sections.length < 8) {
	      for (i = 0; i < sections.length && sections[i] !== ''; i++);
	      var argv = [ i, 1 ];
	      for (i = 9 - sections.length; i > 0; i--) {
	        argv.push('0');
	      }
	      sections.splice.apply(sections, argv);
	    }

	    result = buff || new Buffer(offset + 16);
	    for (i = 0; i < sections.length; i++) {
	      var word = parseInt(sections[i], 16);
	      result[offset++] = (word >> 8) & 0xff;
	      result[offset++] = word & 0xff;
	    }
	  }

	  if (!result) {
	    throw Error('Invalid ip address: ' + ip);
	  }

	  return result;
	};

	ip.toString = function(buff, offset, length) {
	  offset = ~~offset;
	  length = length || (buff.length - offset);

	  var result = [];
	  if (length === 4) {
	    // IPv4
	    for (var i = 0; i < length; i++) {
	      result.push(buff[offset + i]);
	    }
	    result = result.join('.');
	  } else if (length === 16) {
	    // IPv6
	    for (var i = 0; i < length; i += 2) {
	      result.push(buff.readUInt16BE(offset + i).toString(16));
	    }
	    result = result.join(':');
	    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
	    result = result.replace(/:{3,4}/, '::');
	  }

	  return result;
	};

	var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
	var ipv6Regex =
	    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

	ip.isV4Format = function(ip) {
	  return ipv4Regex.test(ip);
	};

	ip.isV6Format = function(ip) {
	  return ipv6Regex.test(ip);
	};
	function _normalizeFamily(family) {
	  return family ? family.toLowerCase() : 'ipv4';
	}

	ip.fromPrefixLen = function(prefixlen, family) {
	  if (prefixlen > 32) {
	    family = 'ipv6';
	  } else {
	    family = _normalizeFamily(family);
	  }

	  var len = 4;
	  if (family === 'ipv6') {
	    len = 16;
	  }
	  var buff = new Buffer(len);

	  for (var i = 0, n = buff.length; i < n; ++i) {
	    var bits = 8;
	    if (prefixlen < 8) {
	      bits = prefixlen;
	    }
	    prefixlen -= bits;

	    buff[i] = ~(0xff >> bits);
	  }

	  return ip.toString(buff);
	};

	ip.mask = function(addr, mask) {
	  addr = ip.toBuffer(addr);
	  mask = ip.toBuffer(mask);

	  var result = new Buffer(Math.max(addr.length, mask.length));

	  // Same protocol - do bitwise and
	  if (addr.length === mask.length) {
	    for (var i = 0; i < addr.length; i++) {
	      result[i] = addr[i] & mask[i];
	    }
	  } else if (mask.length === 4) {
	    // IPv6 address and IPv4 mask
	    // (Mask low bits)
	    for (var i = 0; i < mask.length; i++) {
	      result[i] = addr[addr.length - 4  + i] & mask[i];
	    }
	  } else {
	    // IPv6 mask and IPv4 addr
	    for (var i = 0; i < result.length - 6; i++) {
	      result[i] = 0;
	    }

	    // ::ffff:ipv4
	    result[10] = 0xff;
	    result[11] = 0xff;
	    for (var i = 0; i < addr.length; i++) {
	      result[i + 12] = addr[i] & mask[i + 12];
	    }
	  }

	  return ip.toString(result);
	};

	ip.cidr = function(cidrString) {
	  var cidrParts = cidrString.split('/');

	  var addr = cidrParts[0];
	  if (cidrParts.length !== 2)
	    throw new Error('invalid CIDR subnet: ' + addr);

	  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

	  return ip.mask(addr, mask);
	};

	ip.subnet = function(addr, mask) {
	  var networkAddress = ip.toLong(ip.mask(addr, mask));

	  // Calculate the mask's length.
	  var maskBuffer = ip.toBuffer(mask);
	  var maskLength = 0;

	  for (var i = 0; i < maskBuffer.length; i++) {
	    if (maskBuffer[i] === 0xff) {
	      maskLength += 8;
	    } else {
	      var octet = maskBuffer[i] & 0xff;
	      while (octet) {
	        octet = (octet << 1) & 0xff;
	        maskLength++;
	      }
	    }
	  }

	  var numberOfAddresses = Math.pow(2, 32 - maskLength);

	  return {
	    networkAddress: ip.fromLong(networkAddress),
	    firstAddress: numberOfAddresses <= 2 ?
	                    ip.fromLong(networkAddress) :
	                    ip.fromLong(networkAddress + 1),
	    lastAddress: numberOfAddresses <= 2 ?
	                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
	                    ip.fromLong(networkAddress + numberOfAddresses - 2),
	    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
	    subnetMask: mask,
	    subnetMaskLength: maskLength,
	    numHosts: numberOfAddresses <= 2 ?
	                numberOfAddresses : numberOfAddresses - 2,
	    length: numberOfAddresses,
	    contains: function(other) {
	      return networkAddress === ip.toLong(ip.mask(other, mask));
	    }
	  };
	};

	ip.cidrSubnet = function(cidrString) {
	  var cidrParts = cidrString.split('/');

	  var addr = cidrParts[0];
	  if (cidrParts.length !== 2)
	    throw new Error('invalid CIDR subnet: ' + addr);

	  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

	  return ip.subnet(addr, mask);
	};

	ip.not = function(addr) {
	  var buff = ip.toBuffer(addr);
	  for (var i = 0; i < buff.length; i++) {
	    buff[i] = 0xff ^ buff[i];
	  }
	  return ip.toString(buff);
	};

	ip.or = function(a, b) {
	  a = ip.toBuffer(a);
	  b = ip.toBuffer(b);

	  // same protocol
	  if (a.length === b.length) {
	    for (var i = 0; i < a.length; ++i) {
	      a[i] |= b[i];
	    }
	    return ip.toString(a);

	  // mixed protocols
	  } else {
	    var buff = a;
	    var other = b;
	    if (b.length > a.length) {
	      buff = b;
	      other = a;
	    }

	    var offset = buff.length - other.length;
	    for (var i = offset; i < buff.length; ++i) {
	      buff[i] |= other[i - offset];
	    }

	    return ip.toString(buff);
	  }
	};

	ip.isEqual = function(a, b) {
	  a = ip.toBuffer(a);
	  b = ip.toBuffer(b);

	  // Same protocol
	  if (a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }

	  // Swap
	  if (b.length === 4) {
	    var t = b;
	    b = a;
	    a = t;
	  }

	  // a - IPv4, b - IPv6
	  for (var i = 0; i < 10; i++) {
	    if (b[i] !== 0) return false;
	  }

	  var word = b.readUInt16BE(10);
	  if (word !== 0 && word !== 0xffff) return false;

	  for (var i = 0; i < 4; i++) {
	    if (a[i] !== b[i + 12]) return false;
	  }

	  return true;
	};

	ip.isPrivate = function(addr) {
	  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
	      .test(addr) ||
	    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
	    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
	      .test(addr) ||
	    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
	    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
	    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
	    /^fe80:/i.test(addr) ||
	    /^::1$/.test(addr) ||
	    /^::$/.test(addr);
	};

	ip.isPublic = function(addr) {
	  return !ip.isPrivate(addr);
	};

	ip.isLoopback = function(addr) {
	  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
	      .test(addr) ||
	    /^fe80::1$/.test(addr) ||
	    /^::1$/.test(addr) ||
	    /^::$/.test(addr);
	};

	ip.loopback = function(family) {
	  //
	  // Default to `ipv4`
	  //
	  family = _normalizeFamily(family);

	  if (family !== 'ipv4' && family !== 'ipv6') {
	    throw new Error('family must be ipv4 or ipv6');
	  }

	  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
	};

	//
	// ### function address (name, family)
	// #### @name {string|'public'|'private'} **Optional** Name or security
	//      of the network interface.
	// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
	//      to ipv4).
	//
	// Returns the address for the network interface on the current system with
	// the specified `name`:
	//   * String: First `family` address of the interface.
	//             If not found see `undefined`.
	//   * 'public': the first public ip address of family.
	//   * 'private': the first private ip address of family.
	//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
	//
	ip.address = function(name, family) {
	  var interfaces = os.networkInterfaces();
	  var all;

	  //
	  // Default to `ipv4`
	  //
	  family = _normalizeFamily(family);

	  //
	  // If a specific network interface has been named,
	  // return the address.
	  //
	  if (name && name !== 'private' && name !== 'public') {
	    var res = interfaces[name].filter(function(details) {
	      var itemFamily = details.family.toLowerCase();
	      return itemFamily === family;
	    });
	    if (res.length === 0)
	      return undefined;
	    return res[0].address;
	  }

	  var all = Object.keys(interfaces).map(function (nic) {
	    //
	    // Note: name will only be `public` or `private`
	    // when this is called.
	    //
	    var addresses = interfaces[nic].filter(function (details) {
	      details.family = details.family.toLowerCase();
	      if (details.family !== family || ip.isLoopback(details.address)) {
	        return false;
	      } else if (!name) {
	        return true;
	      }

	      return name === 'public' ? ip.isPrivate(details.address) :
	          ip.isPublic(details.address);
	    });

	    return addresses.length ? addresses[0].address : undefined;
	  }).filter(Boolean);

	  return !all.length ? ip.loopback(family) : all[0];
	};

	ip.toLong = function(ip) {
	  var ipl = 0;
	  ip.split('.').forEach(function(octet) {
	    ipl <<= 8;
	    ipl += parseInt(octet);
	  });
	  return(ipl >>> 0);
	};

	ip.fromLong = function(ipl) {
	  return ((ipl >>> 24) + '.' +
	      (ipl >> 16 & 255) + '.' +
	      (ipl >> 8 & 255) + '.' +
	      (ipl & 255) );
	};


/***/ },
/* 276 */
/***/ function(module, exports) {

	"use strict";
	"use strict"
	function isProperty(str) {
	  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
	}
	module.exports = isProperty

/***/ },
/* 277 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var isStream = module.exports = function (stream) {
		return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
	};

	isStream.writable = function (stream) {
		return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
	};

	isStream.readable = function (stream) {
		return isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
	};

	isStream.duplex = function (stream) {
		return isStream.writable(stream) && isStream.readable(stream);
	};

	isStream.transform = function (stream) {
		return isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';
	};


/***/ },
/* 278 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var stream = __webpack_require__(3)


	function isStream (obj) {
	  return obj instanceof stream.Stream
	}


	function isReadable (obj) {
	  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
	}


	function isWritable (obj) {
	  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
	}


	function isDuplex (obj) {
	  return isReadable(obj) && isWritable(obj)
	}


	module.exports            = isStream
	module.exports.isReadable = isReadable
	module.exports.isWritable = isWritable
	module.exports.isDuplex   = isDuplex


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
	 *
	 *  Licensed under the MIT license.
	 *    http://opensource.org/licenses/mit-license
	 *
	 *  References:
	 *    http://en.wikipedia.org/wiki/Base64
	 */

	(function(global) {
	    'use strict';
	    // existing version for noConflict()
	    var _Base64 = global.Base64;
	    var version = "2.1.9";
	    // if node.js, we use Buffer
	    var buffer;
	    if (typeof module !== 'undefined' && module.exports) {
	        try {
	            buffer = __webpack_require__(6).Buffer;
	        } catch (err) {}
	    }
	    // constants
	    var b64chars
	        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	    var b64tab = function(bin) {
	        var t = {};
	        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
	        return t;
	    }(b64chars);
	    var fromCharCode = String.fromCharCode;
	    // encoder stuff
	    var cb_utob = function(c) {
	        if (c.length < 2) {
	            var cc = c.charCodeAt(0);
	            return cc < 0x80 ? c
	                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
	                                + fromCharCode(0x80 | (cc & 0x3f)))
	                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
	                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                   + fromCharCode(0x80 | ( cc         & 0x3f)));
	        } else {
	            var cc = 0x10000
	                + (c.charCodeAt(0) - 0xD800) * 0x400
	                + (c.charCodeAt(1) - 0xDC00);
	            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
	                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
	                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
	                    + fromCharCode(0x80 | ( cc         & 0x3f)));
	        }
	    };
	    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
	    var utob = function(u) {
	        return u.replace(re_utob, cb_utob);
	    };
	    var cb_encode = function(ccc) {
	        var padlen = [0, 2, 1][ccc.length % 3],
	        ord = ccc.charCodeAt(0) << 16
	            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
	            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
	        chars = [
	            b64chars.charAt( ord >>> 18),
	            b64chars.charAt((ord >>> 12) & 63),
	            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
	            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
	        ];
	        return chars.join('');
	    };
	    var btoa = global.btoa ? function(b) {
	        return global.btoa(b);
	    } : function(b) {
	        return b.replace(/[\s\S]{1,3}/g, cb_encode);
	    };
	    var _encode = buffer ? function (u) {
	        return (u.constructor === buffer.constructor ? u : new buffer(u))
	        .toString('base64')
	    }
	    : function (u) { return btoa(utob(u)) }
	    ;
	    var encode = function(u, urisafe) {
	        return !urisafe
	            ? _encode(String(u))
	            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
	                return m0 == '+' ? '-' : '_';
	            }).replace(/=/g, '');
	    };
	    var encodeURI = function(u) { return encode(u, true) };
	    // decoder stuff
	    var re_btou = new RegExp([
	        '[\xC0-\xDF][\x80-\xBF]',
	        '[\xE0-\xEF][\x80-\xBF]{2}',
	        '[\xF0-\xF7][\x80-\xBF]{3}'
	    ].join('|'), 'g');
	    var cb_btou = function(cccc) {
	        switch(cccc.length) {
	        case 4:
	            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
	                |    ((0x3f & cccc.charCodeAt(1)) << 12)
	                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
	                |     (0x3f & cccc.charCodeAt(3)),
	            offset = cp - 0x10000;
	            return (fromCharCode((offset  >>> 10) + 0xD800)
	                    + fromCharCode((offset & 0x3FF) + 0xDC00));
	        case 3:
	            return fromCharCode(
	                ((0x0f & cccc.charCodeAt(0)) << 12)
	                    | ((0x3f & cccc.charCodeAt(1)) << 6)
	                    |  (0x3f & cccc.charCodeAt(2))
	            );
	        default:
	            return  fromCharCode(
	                ((0x1f & cccc.charCodeAt(0)) << 6)
	                    |  (0x3f & cccc.charCodeAt(1))
	            );
	        }
	    };
	    var btou = function(b) {
	        return b.replace(re_btou, cb_btou);
	    };
	    var cb_decode = function(cccc) {
	        var len = cccc.length,
	        padlen = len % 4,
	        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
	            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
	            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
	            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
	        chars = [
	            fromCharCode( n >>> 16),
	            fromCharCode((n >>>  8) & 0xff),
	            fromCharCode( n         & 0xff)
	        ];
	        chars.length -= [0, 0, 2, 1][padlen];
	        return chars.join('');
	    };
	    var atob = global.atob ? function(a) {
	        return global.atob(a);
	    } : function(a){
	        return a.replace(/[\s\S]{1,4}/g, cb_decode);
	    };
	    var _decode = buffer ? function(a) {
	        return (a.constructor === buffer.constructor
	                ? a : new buffer(a, 'base64')).toString();
	    }
	    : function(a) { return btou(atob(a)) };
	    var decode = function(a){
	        return _decode(
	            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
	                .replace(/[^A-Za-z0-9\+\/]/g, '')
	        );
	    };
	    var noConflict = function() {
	        var Base64 = global.Base64;
	        global.Base64 = _Base64;
	        return Base64;
	    };
	    // export Base64
	    global.Base64 = {
	        VERSION: version,
	        atob: atob,
	        btoa: btoa,
	        fromBase64: decode,
	        toBase64: encode,
	        utob: utob,
	        encode: encode,
	        encodeURI: encodeURI,
	        btou: btou,
	        decode: decode,
	        noConflict: noConflict
	    };
	    // if ES5 is available, make Base64.extendString() available
	    if (typeof Object.defineProperty === 'function') {
	        var noEnum = function(v){
	            return {value:v,enumerable:false,writable:true,configurable:true};
	        };
	        global.Base64.extendString = function () {
	            Object.defineProperty(
	                String.prototype, 'fromBase64', noEnum(function () {
	                    return decode(this)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64', noEnum(function (urisafe) {
	                    return encode(this, urisafe)
	                }));
	            Object.defineProperty(
	                String.prototype, 'toBase64URI', noEnum(function () {
	                    return encode(this, true)
	                }));
	        };
	    }
	    // that's it!
	    if (global['Meteor']) {
	       Base64 = global.Base64; // for normal export in Meteor.js
	    }
	})(this);


/***/ },
/* 281 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "elliptic@^6.0.0",
					"scope": null,
					"escapedName": "elliptic",
					"name": "elliptic",
					"rawSpec": "^6.0.0",
					"spec": ">=6.0.0 <7.0.0",
					"type": "range"
				},
				"/Users/samuli/code/orbit-core/node_modules/browserify-sign"
			]
		],
		"_from": "elliptic@>=6.0.0 <7.0.0",
		"_id": "elliptic@6.3.1",
		"_inCache": true,
		"_installable": true,
		"_location": "/elliptic",
		"_nodeVersion": "6.0.0",
		"_npmOperationalInternal": {
			"host": "packages-16-east.internal.npmjs.com",
			"tmp": "tmp/elliptic-6.3.1.tgz_1465921413402_0.5202967382501811"
		},
		"_npmUser": {
			"name": "indutny",
			"email": "fedor@indutny.com"
		},
		"_npmVersion": "3.8.6",
		"_phantomChildren": {},
		"_requested": {
			"raw": "elliptic@^6.0.0",
			"scope": null,
			"escapedName": "elliptic",
			"name": "elliptic",
			"rawSpec": "^6.0.0",
			"spec": ">=6.0.0 <7.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/browserify-sign",
			"/create-ecdh",
			"/libp2p-crypto",
			"/orbit-crypto",
			"/secp256k1"
		],
		"_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
		"_shasum": "17781f2109ab0ec686b146bdcff5d2e8c6aeceda",
		"_shrinkwrap": null,
		"_spec": "elliptic@^6.0.0",
		"_where": "/Users/samuli/code/orbit-core/node_modules/browserify-sign",
		"author": {
			"name": "Fedor Indutny",
			"email": "fedor@indutny.com"
		},
		"bugs": {
			"url": "https://github.com/indutny/elliptic/issues"
		},
		"dependencies": {
			"bn.js": "^4.4.0",
			"brorand": "^1.0.1",
			"hash.js": "^1.0.0",
			"inherits": "^2.0.1"
		},
		"description": "EC cryptography",
		"devDependencies": {
			"brfs": "^1.4.3",
			"coveralls": "^2.11.3",
			"grunt": "^0.4.5",
			"grunt-browserify": "^5.0.0",
			"grunt-contrib-connect": "^1.0.0",
			"grunt-contrib-copy": "^1.0.0",
			"grunt-contrib-uglify": "^1.0.1",
			"grunt-mocha-istanbul": "^3.0.1",
			"grunt-saucelabs": "^8.6.2",
			"istanbul": "^0.4.2",
			"jscs": "^2.9.0",
			"jshint": "^2.6.0",
			"mocha": "^2.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "17781f2109ab0ec686b146bdcff5d2e8c6aeceda",
			"tarball": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz"
		},
		"files": [
			"lib"
		],
		"gitHead": "c53f5cf3d832c0073eb4a4ed423a464cbce68f3e",
		"homepage": "https://github.com/indutny/elliptic",
		"keywords": [
			"EC",
			"Elliptic",
			"curve",
			"Cryptography"
		],
		"license": "MIT",
		"main": "lib/elliptic.js",
		"maintainers": [
			{
				"name": "indutny",
				"email": "fedor@indutny.com"
			}
		],
		"name": "elliptic",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/indutny/elliptic.git"
		},
		"scripts": {
			"jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
			"jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
			"lint": "npm run jscs && npm run jshint",
			"test": "npm run lint && npm run unit",
			"unit": "istanbul test _mocha --reporter=spec test/index.js",
			"version": "grunt dist && git add dist/"
		},
		"version": "6.3.1"
	};

/***/ },
/* 282 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "ipfs-api@git+https://github.com/haadcode/js-ipfs-api.git",
					"scope": null,
					"escapedName": "ipfs-api",
					"name": "ipfs-api",
					"rawSpec": "git+https://github.com/haadcode/js-ipfs-api.git",
					"spec": "git+https://github.com/haadcode/js-ipfs-api.git",
					"type": "hosted",
					"hosted": {
						"type": "github",
						"ssh": "git@github.com:haadcode/js-ipfs-api.git",
						"sshUrl": "git+ssh://git@github.com/haadcode/js-ipfs-api.git",
						"httpsUrl": "git+https://github.com/haadcode/js-ipfs-api.git",
						"gitUrl": "git://github.com/haadcode/js-ipfs-api.git",
						"shortcut": "github:haadcode/js-ipfs-api",
						"directUrl": "https://raw.githubusercontent.com/haadcode/js-ipfs-api/master/package.json"
					}
				},
				"/Users/samuli/code/orbit-core"
			]
		],
		"_from": "git+https://github.com/haadcode/js-ipfs-api.git",
		"_id": "ipfs-api@8.1.0",
		"_inCache": true,
		"_installable": true,
		"_location": "/ipfs-api",
		"_phantomChildren": {
			"lodash": "4.15.0"
		},
		"_requested": {
			"raw": "ipfs-api@git+https://github.com/haadcode/js-ipfs-api.git",
			"scope": null,
			"escapedName": "ipfs-api",
			"name": "ipfs-api",
			"rawSpec": "git+https://github.com/haadcode/js-ipfs-api.git",
			"spec": "git+https://github.com/haadcode/js-ipfs-api.git",
			"type": "hosted",
			"hosted": {
				"type": "github",
				"ssh": "git@github.com:haadcode/js-ipfs-api.git",
				"sshUrl": "git+ssh://git@github.com/haadcode/js-ipfs-api.git",
				"httpsUrl": "git+https://github.com/haadcode/js-ipfs-api.git",
				"gitUrl": "git://github.com/haadcode/js-ipfs-api.git",
				"shortcut": "github:haadcode/js-ipfs-api",
				"directUrl": "https://raw.githubusercontent.com/haadcode/js-ipfs-api/master/package.json"
			}
		},
		"_requiredBy": [
			"#USER",
			"/",
			"/ipfs",
			"/orbit-db-pubsub"
		],
		"_resolved": "git+https://github.com/haadcode/js-ipfs-api.git#4bfb4c84d74c80cd223700406a0e14ff21474126",
		"_shasum": "f8ac7f8664239ed7522bf42c81ec0c491a8fa2d3",
		"_shrinkwrap": null,
		"_spec": "ipfs-api@git+https://github.com/haadcode/js-ipfs-api.git",
		"_where": "/Users/samuli/code/orbit-core",
		"author": {
			"name": "Matt Bell",
			"email": "mappum@gmail.com"
		},
		"bugs": {
			"url": "https://github.com/ipfs/js-ipfs-api/issues"
		},
		"contributors": [
			{
				"name": "Alex Mingoia",
				"email": "talk@alexmingoia.com"
			},
			{
				"name": "Connor Keenan",
				"email": "ckeenan89@gmail.com"
			},
			{
				"name": "David Braun",
				"email": "David.Braun@Toptal.com"
			},
			{
				"name": "David Dias",
				"email": "daviddias.p@gmail.com"
			},
			{
				"name": "Fil",
				"email": "fil@rezo.net"
			},
			{
				"name": "Francisco Baio Dias",
				"email": "xicombd@gmail.com"
			},
			{
				"name": "Friedel Ziegelmayer",
				"email": "dignifiedquire@gmail.com"
			},
			{
				"name": "Gavin McDermott",
				"email": "gavinmcdermott@gmail.com"
			},
			{
				"name": "Harlan T Wood",
				"email": "harlantwood@users.noreply.github.com"
			},
			{
				"name": "Harlan T Wood",
				"email": "code@harlantwood.net"
			},
			{
				"name": "Holodisc",
				"email": "holodiscent@gmail.com"
			},
			{
				"name": "Jason Carver",
				"email": "jacarver@linkedin.com"
			},
			{
				"name": "Jeromy",
				"email": "jeromyj@gmail.com"
			},
			{
				"name": "Joe Turgeon",
				"email": "arithmetric@gmail.com"
			},
			{
				"name": "Juan Batiz-Benet",
				"email": "juan@benet.ai"
			},
			{
				"name": "Kristoffer Strm",
				"email": "kristoffer@rymdkoloni.se"
			},
			{
				"name": "Matt Bell",
				"email": "mappum@gmail.com"
			},
			{
				"name": "Mithgol",
				"email": "getgit@mithgol.ru"
			},
			{
				"name": "Richard Littauer",
				"email": "richard.littauer@gmail.com"
			},
			{
				"name": "Stephen Whitmore",
				"email": "stephen.whitmore@gmail.com"
			},
			{
				"name": "Travis Person",
				"email": "travis.person@gmail.com"
			},
			{
				"name": "Victor Bjelkholm",
				"email": "victor@typeform.com"
			},
			{
				"name": "ethers",
				"email": "ethereum@outlook.com"
			},
			{
				"name": "greenkeeperio-bot",
				"email": "support@greenkeeper.io"
			},
			{
				"name": "haad",
				"email": "haad@headbanggames.com"
			},
			{
				"name": "nginnever",
				"email": "ginneversource@gmail.com"
			},
			{
				"name": "priecint",
				"email": "tp-dev@seznam.cz"
			},
			{
				"name": "samuli",
				"email": "samuli@nugg.ad"
			}
		],
		"dependencies": {
			"async": "^2.0.1",
			"babel-runtime": "^6.11.6",
			"bl": "^1.1.2",
			"bs58": "^3.0.0",
			"detect-node": "^2.0.3",
			"flatmap": "0.0.3",
			"glob": "^7.0.5",
			"ipfs-block": "^0.3.0",
			"ipfs-merkle-dag": "^0.7.1",
			"is-ipfs": "^0.2.0",
			"isstream": "^0.1.2",
			"multiaddr": "^2.0.2",
			"multipart-stream": "^2.0.1",
			"ndjson": "^1.4.3",
			"promisify-es6": "^1.0.1",
			"qs": "^6.2.1",
			"streamifier": "^0.1.1",
			"tar-stream": "^1.5.2",
			"wreck": "^10.0.0"
		},
		"description": "A client library for the IPFS HTTP API. Follows interface-ipfs-core spec",
		"devDependencies": {
			"aegir": "^8.0.0",
			"chai": "^3.5.0",
			"gulp": "^3.9.1",
			"hapi": "^15.0.2",
			"interface-ipfs-core": "^0.14.2",
			"ipfsd-ctl": "^0.14.0",
			"js-base64": "^2.1.9",
			"pre-commit": "^1.1.3",
			"socket.io": "^1.4.8",
			"socket.io-client": "^1.4.8",
			"stream-equal": "^0.1.8",
			"stream-http": "^2.3.1"
		},
		"engines": {
			"node": ">=4.2.2"
		},
		"gitHead": "4bfb4c84d74c80cd223700406a0e14ff21474126",
		"homepage": "https://github.com/ipfs/js-ipfs-api",
		"jsnext:main": "src/index.js",
		"keywords": [
			"ipfs"
		],
		"license": "MIT",
		"main": "lib/index.js",
		"name": "ipfs-api",
		"optionalDependencies": {},
		"pre-commit": [
			"lint",
			"test"
		],
		"readme": "ipfs-api\n========\n\n[![](https://img.shields.io/badge/made%20by-Protocol%20Labs-blue.svg?style=flat-square)](http://ipn.io)\n[![](https://img.shields.io/badge/project-IPFS-blue.svg?style=flat-square)](http://ipfs.io/)\n[![](https://img.shields.io/badge/freenode-%23ipfs-blue.svg?style=flat-square)](http://webchat.freenode.net/?channels=%23ipfs)\n[![standard-readme compliant](https://img.shields.io/badge/standard--readme-OK-green.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)\n[![Coverage Status](https://coveralls.io/repos/github/ipfs/js-ipfs-api/badge.svg?branch=master)](https://coveralls.io/github/ipfs/js-ipfs-api?branch=master)\n[![Dependency Status](https://david-dm.org/ipfs/js-ipfs-api.svg?style=flat-square)](https://david-dm.org/ipfs/js-ipfs-api)\n[![Travis CI](https://travis-ci.org/ipfs/js-ipfs-api.svg?branch=master)](https://travis-ci.org/ipfs/js-ipfs-api)\n[![Circle CI](https://circleci.com/gh/ipfs/js-ipfs-api.svg?style=svg)](https://circleci.com/gh/ipfs/js-ipfs-api)\n\n> A client library for the IPFS HTTP API, implemented in JavaScript. This client library implements the [interface-ipfs-core](https://github.com/ipfs/interface-ipfs-core) enabling applications to change between a embebed js-ipfs node and any remote IPFS node without having to change the code. In addition, this client library implements a set of utility functions.\n\n![](https://github.com/ipfs/interface-ipfs-core/raw/master/img/badge.png)\n\n## Table of Contents\n\n- [Install](#install)\n  - [Running the daemon with the right port](#running-the-daemon-with-the-right-port)\n  - [Importing the module and usage](#importing-the-module-and-usage)\n  - [In the Browser through browserify](#in-the-browser-through-browserify)\n  - [In the Browser through `<script>` tag](#in-the-browser-through-script-tag)\n  - [CORS](#cors)\n- [Usage](#usage)\n  - [API](#api)\n  - [Callbacks and promises](#callbacks-and-promises)\n- [Contribute](#contribute)\n- [License](#license)\n\n## Install\n\nThis module uses node.js, and can be installed through npm:\n\n```bash\n$ npm install --save ipfs-api\n```\n\n**Note:** ipfs-api requires Node v4.x (LTS) or higher.\n\n### Running the daemon with the right port\n\nTo interact with the API, you need to have a local daemon running. It needs to be open on the right port. `5001` is the default, and is used in the examples below, but it can be set to whatever you need.\n\n```sh\n# Show the ipfs config API port to check it is correct\n$ ipfs config Addresses.API\n/ip4/127.0.0.1/tcp/5001\n# Set it if it does not match the above output\n$ ipfs config Addresses.API /ip4/127.0.0.1/tcp/5001\n# Restart the daemon after changing the config\n\n# Run the daemon\n$ ipfs daemon\n```\n\n### Importing the module and usage\n\n```javascript\nvar ipfsAPI = require('ipfs-api')\n\n// connect to ipfs daemon API server\nvar ipfs = ipfsAPI('localhost', '5001', {protocol: 'http'}) // leaving out the arguments will default to these values\n\n// or connect with multiaddr\nvar ipfs = ipfsAPI('/ip4/127.0.0.1/tcp/5001')\n\n// or using options\nvar ipfs = ipfsAPI({host: 'localhost', port: '5001', procotol: 'http'})\n```\n\n### In the Browser through browserify\n\nSame as in Node.js, you just have to [browserify](http://browserify.org) the code before serving it. See the browserify repo for how to do that.\n\n### In the Browser through `<script>` tag\n\nYou can use [npmcdn](https://npmcdn.com/) to get the latest built version, like this\n\n```html\n<script src=\"https://npmcdn.com/ipfs-api/dist/index.js\"></script>\n```\n\nThis will export the `IpfsApi` constructor on the `window` object, such that:\n\n```\nvar ipfs = window.IpfsApi('localhost', '5001')\n```\n\nIf you omit the host and port, the api will parse `window.host`, and use this information. This also works, and can be useful if you want to write apps that can be run from multiple different gateways:\n\n```\nvar ipfs = window.IpfsApi()\n```\n\n### CORS\n\nIf are using this module in a browser with something like browserify, then you will get an error saying that the origin is not allowed. This would be a CORS (\"Cross Origin Resource Sharing\") failure. The ipfs server rejects requests from unknown domains by default. You can whitelist the domain that you are calling from by changing your ipfs config like this:\n\n```bash\n$ ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \"[\\\"http://example.com\\\"]\"\n```\n\n## Usage\n\n### API\n\n> `js-ipfs-api` follows the spec defined by [`interface-ipfs-core`](https://github.com/ipfs/interface-ipfs-core), which concerns the interface to expect from IPFS implementations. This interface is a currently active endeavor - expect it to be complete in the next few weeks (August 2016). You can use it today to consult the methods available.\n\n### Utility functions\n\nAdding to the methods defined by [`interface-ipfs-core`](https://github.com/ipfs/interface-ipfs-core), `js-ipfs-api` exposes a set of extra utility methods. These utility functions are scoped behind the `ipfs.util`.\n\nComplete documentation for these methods is coming with: https://github.com/ipfs/js-ipfs-api/pull/305\n\n\n#### Add files or entire directories from the FileSystem to IPFS\n\n> `ipfs.util.addFromFs(path, option, callback)`\n\nReads a file from `path` on the filesystem  and adds it to IPFS. If `path` is a directory, use option `{ recursive: true }` to add the directory and all its sub-directories.\n\n```JavaScript\nipfs.util.addFromFs('path/to/a/file', { recursive: true }, (err, result) => {\n  if (err) {\n    throw err\n  }\n  console.log(result)\n})\n```\n\n`result` is an array of objects describing the files that were added, such as:\n\n```\n[{\n  path: 'test-folder',\n  hash: 'QmRNjDeKStKGTQXnJ2NFqeQ9oW23WcpbmvCVrpDHgDg3T6',\n  size: 2278\n},\n// ...\n]\n```\n\n#### Add a file from a URL to IPFS\n\n> `ipfs.util.addFromURL(url, callback)`\n\n```JavaScript\nipfs.util.addFromURL('http://example.com/', (err, result) => {\n  if (err) {\n    throw err\n  }\n  console.log(result)\n})\n\n```\n\n#### Add a file from a stream to IPFS\n\n> `ipfs.util.addFromStream(stream, callback)`\n\nThis is very similar to `ipfs.files.add({path:'', content: stream})`. It is like the reverse of cat\n\n```JavaScript\nipfs.util.addFromStream(<readable-stream>, (err, result) => {\n  if (err) {\n    throw err\n  }\n  console.log(result)\n})\n```\n\n### Callbacks and promises\n\nIf you do not pass in a callback all API functions will return a `Promise`. For example:\n\n```js\nipfs.id()\n  .then(function (id) {\n    console.log('my id is: ', id)\n  })\n  .catch(function(err) {\n  \tconsole.log('Fail: ', err)\n  })\n```\n\nThis relies on a global `Promise` object. If you are in an environment where that is not\nyet available you need to bring your own polyfill.\n\n## Development\n\n### Testing\n\nWe run tests by executing `npm test` in a terminal window. This will run both Node.js and Browser tests, both in Chrome and PhantomJS. To ensure that the module conforms with the [`interface-ipfs-core`](https://github.com/ipfs/interface-ipfs-core) spec, we run the batch of tests provided by the interface module, which can be found [here](https://github.com/ipfs/interface-ipfs-core/tree/master/src).\n\n\n\n## Contribute\n\nThe js-ipfs-api is a work in progress. As such, there's a few things you can do right now to help out:\n\n* **[Check out the existing issues](https://github.com/ipfs/js-ipfs-api/issues)**!\n* **Perform code reviews**. More eyes will help a) speed the project along b) ensure quality and c) reduce possible future bugs.\n* **Add tests**. There can never be enough tests. Note that interface tests exist inside [`interface-ipfs-core`](https://github.com/ipfs/interface-ipfs-core/tree/master/src).\n* **Contribute to the [FAQ repository](https://github.com/ipfs/faq/issues)** with any questions you have about IPFS or any of the relevant technology. A good example would be asking, 'What is a merkledag tree?'. If you don't know a term, odds are, someone else doesn't either. Eventually, we should have a good understanding of where we need to improve communications and teaching together to make IPFS and IPN better.\n\n**Want to hack on IPFS?**\n\n[![](https://cdn.rawgit.com/jbenet/contribute-ipfs-gif/master/img/contribute.gif)](https://github.com/ipfs/community/blob/master/contributing.md)\n\n## Historical context\n\nThis module started as a direct mapping from the go-ipfs cli to a JavaScript implementation, although this was useful and familiar to a lot of developers that were coming to IPFS for the first time, it also created some confusion on how to operate the core of IPFS and have access to the full capacity of the protocol. After much consideration, we decided to create `interface-ipfs-core` with the goal of standardizing the interface of a core implementation of IPFS, and keep the utility functions the IPFS community learned to use and love, such as reading files from disk and storing them directly to IPFS.\n\n## License\n\n[MIT](LICENSE)\n",
		"readmeFilename": "README.md",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/ipfs/js-ipfs-api.git"
		},
		"scripts": {
			"build": "gulp build",
			"coverage": "gulp coverage",
			"coverage-publish": "aegir-coverage publish",
			"lint": "aegir-lint",
			"release": "node --max_old_space_size=4096 node_modules/.bin/gulp release",
			"release-major": "node --max_old_space_size=4096 node_modules/.bin/gulp release --type major",
			"release-minor": "node --max_old_space_size=4096 node_modules/.bin/gulp release --type minor",
			"test": "node --max_old_space_size=4096 node_modules/.bin/gulp test:node",
			"test:browser": "node --max_old_space_size=4096 node_modules/.bin/gulp test:browser",
			"test:node": "gulp test:node"
		},
		"version": "8.1.0"
	};

/***/ },
/* 283 */
/***/ function(module, exports) {

	module.exports = {
		"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
		"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
		"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
		"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
		"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
		"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
		"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
		"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
		"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
		"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
		"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
		"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
	};

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * @name Lazy.js
	 *
	 * @fileOverview
	 * Lazy.js is a lazy evaluation library for JavaScript.
	 *
	 * This has been done before. For examples see:
	 *
	 * - [wu.js](http://fitzgen.github.io/wu.js/)
	 * - [Linq.js](http://linqjs.codeplex.com/)
	 * - [from.js](https://github.com/suckgamoni/fromjs/)
	 * - [IxJS](http://rx.codeplex.com/)
	 * - [sloth.js](http://rfw.name/sloth.js/)
	 *
	 * However, at least at present, Lazy.js is faster (on average) than any of
	 * those libraries. It is also more complete, with nearly all of the
	 * functionality of [Underscore](http://underscorejs.org/) and
	 * [Lo-Dash](http://lodash.com/).
	 *
	 * Finding your way around the code
	 * --------------------------------
	 *
	 * At the heart of Lazy.js is the {@link Sequence} object. You create an initial
	 * sequence using {@link Lazy}, which can accept an array, object, or string.
	 * You can then "chain" together methods from this sequence, creating a new
	 * sequence with each call.
	 *
	 * Here's an example:
	 *
	 *     var data = getReallyBigArray();
	 *
	 *     var statistics = Lazy(data)
	 *       .map(transform)
	 *       .filter(validate)
	 *       .reduce(aggregate);
	 *
	 * {@link Sequence} is the foundation of other, more specific sequence types.
	 *
	 * An {@link ArrayLikeSequence} provides indexed access to its elements.
	 *
	 * An {@link ObjectLikeSequence} consists of key/value pairs.
	 *
	 * A {@link StringLikeSequence} is like a string (duh): actually, it is an
	 * {@link ArrayLikeSequence} whose elements happen to be characters.
	 *
	 * An {@link AsyncSequence} is special: it iterates over its elements
	 * asynchronously (so calling `each` generally begins an asynchronous loop and
	 * returns immediately).
	 *
	 * For more information
	 * --------------------
	 *
	 * I wrote a blog post that explains a little bit more about Lazy.js, which you
	 * can read [here](http://philosopherdeveloper.com/posts/introducing-lazy-js.html).
	 *
	 * You can also [create an issue on GitHub](https://github.com/dtao/lazy.js/issues)
	 * if you have any issues with the library. I work through them eventually.
	 *
	 * [@dtao](https://github.com/dtao)
	 */

	(function(root, factory) {
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.Lazy = factory();
	  }
	})(this, function(context) {
	  /**
	   * Wraps an object and returns a {@link Sequence}. For `null` or `undefined`,
	   * simply returns an empty sequence (see {@link Lazy.strict} for a stricter
	   * implementation).
	   *
	   * - For **arrays**, Lazy will create a sequence comprising the elements in
	   *   the array (an {@link ArrayLikeSequence}).
	   * - For **objects**, Lazy will create a sequence of key/value pairs
	   *   (an {@link ObjectLikeSequence}).
	   * - For **strings**, Lazy will create a sequence of characters (a
	   *   {@link StringLikeSequence}).
	   *
	   * @public
	   * @param {Array|Object|string} source An array, object, or string to wrap.
	   * @returns {Sequence} The wrapped lazy object.
	   *
	   * @exampleHelpers
	   * // Utility functions to provide to all examples
	   * function increment(x) { return x + 1; }
	   * function isEven(x) { return x % 2 === 0; }
	   * function isPositive(x) { return x > 0; }
	   * function isNegative(x) { return x < 0; }
	   *
	   * @examples
	   * Lazy([1, 2, 4])       // instanceof Lazy.ArrayLikeSequence
	   * Lazy({ foo: "bar" })  // instanceof Lazy.ObjectLikeSequence
	   * Lazy("hello, world!") // instanceof Lazy.StringLikeSequence
	   * Lazy()                // sequence: []
	   * Lazy(null)            // sequence: []
	   */
	  function Lazy(source) {
	    if (source instanceof Array) {
	      return new ArrayWrapper(source);

	    } else if (typeof source === "string") {
	      return new StringWrapper(source);

	    } else if (source instanceof Sequence) {
	      return source;
	    }

	    if (Lazy.extensions) {
	      var extensions = Lazy.extensions, length = extensions.length, result;
	      while (!result && length--) {
	        result = extensions[length](source);
	      }
	      if (result) {
	        return result;
	      }
	    }

	    return new ObjectWrapper(source);
	  }

	  Lazy.VERSION = '0.4.2';

	  /*** Utility methods of questionable value ***/

	  Lazy.noop = function noop() {};
	  Lazy.identity = function identity(x) { return x; };

	  /**
	   * Provides a stricter version of {@link Lazy} which throws an error when
	   * attempting to wrap `null`, `undefined`, or numeric or boolean values as a
	   * sequence.
	   *
	   * @public
	   * @returns {Function} A stricter version of the {@link Lazy} helper function.
	   *
	   * @examples
	   * var Strict = Lazy.strict();
	   *
	   * Strict()                  // throws
	   * Strict(null)              // throws
	   * Strict(true)              // throws
	   * Strict(5)                 // throws
	   * Strict([1, 2, 3])         // instanceof Lazy.ArrayLikeSequence
	   * Strict({ foo: "bar" })    // instanceof Lazy.ObjectLikeSequence
	   * Strict("hello, world!")   // instanceof Lazy.StringLikeSequence
	   *
	   * // Let's also ensure the static functions are still there.
	   * Strict.range(3)           // sequence: [0, 1, 2]
	   * Strict.generate(Date.now) // instanceof Lazy.GeneratedSequence
	   */
	  Lazy.strict = function strict() {
	    function StrictLazy(source) {
	      if (source == null) {
	        throw new Error("You cannot wrap null or undefined using Lazy.");
	      }

	      if (typeof source === "number" || typeof source === "boolean") {
	        throw new Error("You cannot wrap primitive values using Lazy.");
	      }

	      return Lazy(source);
	    };

	    Lazy(Lazy).each(function(property, name) {
	      StrictLazy[name] = property;
	    });

	    return StrictLazy;
	  };

	  /**
	   * The `Sequence` object provides a unified API encapsulating the notion of
	   * zero or more consecutive elements in a collection, stream, etc.
	   *
	   * Lazy evaluation
	   * ---------------
	   *
	   * Generally speaking, creating a sequence should not be an expensive operation,
	   * and should not iterate over an underlying source or trigger any side effects.
	   * This means that chaining together methods that return sequences incurs only
	   * the cost of creating the `Sequence` objects themselves and not the cost of
	   * iterating an underlying data source multiple times.
	   *
	   * The following code, for example, creates 4 sequences and does nothing with
	   * `source`:
	   *
	   *     var seq = Lazy(source) // 1st sequence
	   *       .map(func)           // 2nd
	   *       .filter(pred)        // 3rd
	   *       .reverse();          // 4th
	   *
	   * Lazy's convention is to hold off on iterating or otherwise *doing* anything
	   * (aside from creating `Sequence` objects) until you call `each`:
	   *
	   *     seq.each(function(x) { console.log(x); });
	   *
	   * Defining custom sequences
	   * -------------------------
	   *
	   * Defining your own type of sequence is relatively simple:
	   *
	   * 1. Pass a *method name* and an object containing *function overrides* to
	   *    {@link Sequence.define}. If the object includes a function called `init`,
	   *    this function will be called upon initialization.
	   * 2. The object should include at least either a `getIterator` method or an
	   *    `each` method. The former supports both asynchronous and synchronous
	   *    iteration, but is slightly more cumbersome to implement. The latter
	   *    supports synchronous iteration and can be automatically implemented in
	   *    terms of the former. You can also implement both if you want, e.g. to
	   *    optimize performance. For more info, see {@link Iterator} and
	   *    {@link AsyncSequence}.
	   *
	   * As a trivial example, the following code defines a new method, `sample`,
	   * which randomly may or may not include each element from its parent.
	   *
	   *     Lazy.Sequence.define("sample", {
	   *       each: function(fn) {
	   *         return this.parent.each(function(e) {
	   *           // 50/50 chance of including this element.
	   *           if (Math.random() > 0.5) {
	   *             return fn(e);
	   *           }
	   *         });
	   *       }
	   *     });
	   *
	   * (Of course, the above could also easily have been implemented using
	   * {@link #filter} instead of creating a custom sequence. But I *did* say this
	   * was a trivial example, to be fair.)
	   *
	   * Now it will be possible to create this type of sequence from any parent
	   * sequence by calling the method name you specified. In other words, you can
	   * now do this:
	   *
	   *     Lazy(arr).sample();
	   *     Lazy(arr).map(func).sample();
	   *     Lazy(arr).map(func).filter(pred).sample();
	   *
	   * Etc., etc.
	   *
	   * @public
	   * @constructor
	   */
	  function Sequence() {}

	  /**
	   * Create a new constructor function for a type inheriting from `Sequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `Sequence` prototype so that it can be chained with any other
	   *     sequence methods, like {@link #map}, {@link #filter}, etc.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include either `getIterator` or `each` (or
	   *     both). *May* include an `init` method as well. For these overrides,
	   *     `this` will be the new sequence, and `this.parent` will be the base
	   *     sequence from which the new sequence was constructed.
	   * @returns {Function} A constructor for a new type inheriting from `Sequence`.
	   *
	   * @examples
	   * // This sequence type logs every element to the specified logger as it
	   * // iterates over it.
	   * Lazy.Sequence.define("verbose", {
	   *   init: function(logger) {
	   *     this.logger = logger;
	   *   },
	   *
	   *   each: function(fn) {
	   *     var logger = this.logger;
	   *     return this.parent.each(function(e, i) {
	   *       logger(e);
	   *       return fn(e, i);
	   *     });
	   *   }
	   * });
	   *
	   * Lazy([1, 2, 3]).verbose(logger).each(Lazy.noop) // calls logger 3 times
	   */
	  Sequence.define = function define(methodName, overrides) {
	    if (!overrides || (!overrides.getIterator && !overrides.each)) {
	      throw new Error("A custom sequence must implement *at least* getIterator or each!");
	    }

	    return defineSequenceType(Sequence, methodName, overrides);
	  };

	  /**
	   * Gets the number of elements in the sequence. In some cases, this may
	   * require eagerly evaluating the sequence.
	   *
	   * @public
	   * @returns {number} The number of elements in the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).size();                 // => 3
	   * Lazy([1, 2]).map(Lazy.identity).size(); // => 2
	   * Lazy([1, 2, 3]).reject(isEven).size();  // => 2
	   * Lazy([1, 2, 3]).take(1).size();         // => 1
	   * Lazy({ foo: 1, bar: 2 }).size();        // => 2
	   * Lazy('hello').size();                   // => 5
	   */
	  Sequence.prototype.size = function size() {
	    return this.getIndex().length();
	  };

	  /**
	   * Creates an {@link Iterator} object with two methods, `moveNext` -- returning
	   * true or false -- and `current` -- returning the current value.
	   *
	   * This method is used when asynchronously iterating over sequences. Any type
	   * inheriting from `Sequence` must implement this method or it can't support
	   * asynchronous iteration.
	   *
	   * Note that **this method is not intended to be used directly by application
	   * code.** Rather, it is intended as a means for implementors to potentially
	   * define custom sequence types that support either synchronous or
	   * asynchronous iteration.
	   *
	   * @public
	   * @returns {Iterator} An iterator object.
	   *
	   * @examples
	   * var iterator = Lazy([1, 2]).getIterator();
	   *
	   * iterator.moveNext(); // => true
	   * iterator.current();  // => 1
	   * iterator.moveNext(); // => true
	   * iterator.current();  // => 2
	   * iterator.moveNext(); // => false
	   */
	  Sequence.prototype.getIterator = function getIterator() {
	    return new Iterator(this);
	  };

	  /**
	   * Gets the root sequence underlying the current chain of sequences.
	   */
	  Sequence.prototype.root = function root() {
	    return this.parent.root();
	  };

	  /**
	   * Whether or not the current sequence is an asynchronous one. This is more
	   * accurate than checking `instanceof {@link AsyncSequence}` because, for
	   * example, `Lazy([1, 2, 3]).async().map(Lazy.identity)` returns a sequence
	   * that iterates asynchronously even though it's not an instance of
	   * `AsyncSequence`.
	   *
	   * @returns {boolean} Whether or not the current sequence is an asynchronous one.
	   */
	  Sequence.prototype.isAsync = function isAsync() {
	    return this.parent ? this.parent.isAsync() : false;
	  };

	  /**
	   * Evaluates the sequence and produces the appropriate value (an array in most
	   * cases, an object for {@link ObjectLikeSequence}s or a string for
	   * {@link StringLikeSequence}s).
	   *
	   * @returns {Array|string|Object} The value resulting from fully evaluating
	   *     the sequence.
	   */
	  Sequence.prototype.value = function value() {
	    return this.toArray();
	  };

	  /**
	   * Applies the current transformation chain to a given source, returning the
	   * resulting value.
	   *
	   * @examples
	   * var sequence = Lazy([])
	   *   .map(function(x) { return x * -1; })
	   *   .filter(function(x) { return x % 2 === 0; });
	   *
	   * sequence.apply([1, 2, 3, 4]); // => [-2, -4]
	   */
	  Sequence.prototype.apply = function apply(source) {
	    var root = this.root(),
	        previousSource = root.source,
	        result;

	    try {
	      root.source = source;
	      result = this.value();
	    } finally {
	      root.source = previousSource;
	    }

	    return result;
	  };

	  /**
	   * The Iterator object provides an API for iterating over a sequence.
	   *
	   * The purpose of the `Iterator` type is mainly to offer an agnostic way of
	   * iterating over a sequence -- either synchronous (i.e. with a `while` loop)
	   * or asynchronously (with recursive calls to either `setTimeout` or --- if
	   * available --- `setImmediate`). It is not intended to be used directly by
	   * application code.
	   *
	   * @public
	   * @constructor
	   * @param {Sequence} sequence The sequence to iterate over.
	   */
	  function Iterator(sequence) {
	    this.sequence = sequence;
	    this.index    = -1;
	  }

	  /**
	   * Gets the current item this iterator is pointing to.
	   *
	   * @public
	   * @returns {*} The current item.
	   */
	  Iterator.prototype.current = function current() {
	    return this.cachedIndex && this.cachedIndex.get(this.index);
	  };

	  /**
	   * Moves the iterator to the next item in a sequence, if possible.
	   *
	   * @public
	   * @returns {boolean} True if the iterator is able to move to a new item, or else
	   *     false.
	   */
	  Iterator.prototype.moveNext = function moveNext() {
	    var cachedIndex = this.cachedIndex;

	    if (!cachedIndex) {
	      cachedIndex = this.cachedIndex = this.sequence.getIndex();
	    }

	    if (this.index >= cachedIndex.length() - 1) {
	      return false;
	    }

	    ++this.index;
	    return true;
	  };

	  /**
	   * Creates an array snapshot of a sequence.
	   *
	   * Note that for indefinite sequences, this method may raise an exception or
	   * (worse) cause the environment to hang.
	   *
	   * @public
	   * @returns {Array} An array containing the current contents of the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).toArray() // => [1, 2, 3]
	   */
	  Sequence.prototype.toArray = function toArray() {
	    return this.reduce(function(arr, element) {
	      arr.push(element);
	      return arr;
	    }, []);
	  };

	  /**
	   * Provides an indexed view into the sequence.
	   *
	   * For sequences that are already indexed, this will simply return the
	   * sequence. For non-indexed sequences, this will eagerly evaluate the
	   * sequence.
	   *
	   * @returns {ArrayLikeSequence} A sequence containing the current contents of
	   *     the sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).filter(isEven)            // instanceof Lazy.Sequence
	   * Lazy([1, 2, 3]).filter(isEven).getIndex() // instanceof Lazy.ArrayLikeSequence
	   */
	  Sequence.prototype.getIndex = function getIndex() {
	    return new ArrayWrapper(this.toArray());
	  };

	  /**
	   * Returns the element at the specified index. Note that, for sequences that
	   * are not {@link ArrayLikeSequence}s, this may require partially evaluating
	   * the sequence, iterating to reach the result. (In other words for such
	   * sequences this method is not O(1).)
	   *
	   * @public
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   *
	   */
	  Sequence.prototype.get = function get(i) {
	    var element;
	    this.each(function(e, index) {
	      if (index === i) {
	        element = e;
	        return false;
	      }
	    });
	    return element;
	  };

	  /**
	   * Provides an indexed, memoized view into the sequence. This will cache the
	   * result whenever the sequence is first iterated, so that subsequent
	   * iterations will access the same element objects.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} An indexed, memoized sequence containing this
	   *     sequence's elements, cached after the first iteration.
	   *
	   * @example
	   * function createObject() { return new Object(); }
	   *
	   * var plain    = Lazy.generate(createObject, 10),
	   *     memoized = Lazy.generate(createObject, 10).memoize();
	   *
	   * plain.toArray()[0] === plain.toArray()[0];       // => false
	   * memoized.toArray()[0] === memoized.toArray()[0]; // => true
	   */
	  Sequence.prototype.memoize = function memoize() {
	    return new MemoizedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function MemoizedSequence(parent) {
	    this.parent = parent;
	  }

	  // MemoizedSequence needs to have its prototype set up after ArrayLikeSequence

	  /**
	   * Creates an object from a sequence of key/value pairs.
	   *
	   * @public
	   * @returns {Object} An object with keys and values corresponding to the pairs
	   *     of elements in the sequence.
	   *
	   * @examples
	   * var details = [
	   *   ["first", "Dan"],
	   *   ["last", "Tao"],
	   *   ["age", 29]
	   * ];
	   *
	   * Lazy(details).toObject() // => { first: "Dan", last: "Tao", age: 29 }
	   */
	  Sequence.prototype.toObject = function toObject() {
	    return this.reduce(function(object, pair) {
	      object[pair[0]] = pair[1];
	      return object;
	    }, {});
	  };

	  /**
	   * Iterates over this sequence and executes a function for every element.
	   *
	   * @public
	   * @aka forEach
	   * @param {Function} fn The function to call on each element in the sequence.
	   *     Return false from the function to end the iteration.
	   * @returns {boolean} `true` if the iteration evaluated the entire sequence,
	   *     or `false` if iteration was ended early.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).each(fn) // calls fn 4 times
	   */
	  Sequence.prototype.each = function each(fn) {
	    var iterator = this.getIterator(),
	        i = -1;

	    while (iterator.moveNext()) {
	      if (fn(iterator.current(), ++i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  Sequence.prototype.forEach = function forEach(fn) {
	    return this.each(fn);
	  };

	  /**
	   * Creates a new sequence whose values are calculated by passing this sequence's
	   * elements through some mapping function.
	   *
	   * @public
	   * @aka collect
	   * @param {Function} mapFn The mapping function used to project this sequence's
	   *     elements onto a new sequence. This function takes up to two arguments:
	   *     the element, and the current index.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function addIndexToValue(e, i) { return e + i; }
	   *
	   * Lazy([]).map(increment)              // sequence: []
	   * Lazy([1, 2, 3]).map(increment)       // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3]).map(addIndexToValue) // sequence: [1, 3, 5]
	   *
	   * @benchmarks
	   * function increment(x) { return x + 1; }
	   *
	   * var smArr = Lazy.range(10).toArray(),
	   *     lgArr = Lazy.range(100).toArray();
	   *
	   * Lazy(smArr).map(increment).each(Lazy.noop) // lazy - 10 elements
	   * Lazy(lgArr).map(increment).each(Lazy.noop) // lazy - 100 elements
	   * _.each(_.map(smArr, increment), _.noop)    // lodash - 10 elements
	   * _.each(_.map(lgArr, increment), _.noop)    // lodash - 100 elements
	   */
	  Sequence.prototype.map = function map(mapFn) {
	    return new MappedSequence(this, createCallback(mapFn));
	  };

	  Sequence.prototype.collect = function collect(mapFn) {
	    return this.map(mapFn);
	  };

	  /**
	   * @constructor
	   */
	  function MappedSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedSequence.prototype = new Sequence();

	  MappedSequence.prototype.getIterator = function getIterator() {
	    return new MappingIterator(this.parent, this.mapFn);
	  };

	  MappedSequence.prototype.each = function each(fn) {
	    var mapFn = this.mapFn;
	    return this.parent.each(function(e, i) {
	      return fn(mapFn(e, i), i);
	    });
	  };

	  /**
	   * @constructor
	   */
	  function MappingIterator(sequence, mapFn) {
	    this.iterator = sequence.getIterator();
	    this.mapFn    = mapFn;
	    this.index    = -1;
	  }

	  MappingIterator.prototype.current = function current() {
	    return this.mapFn(this.iterator.current(), this.index);
	  };

	  MappingIterator.prototype.moveNext = function moveNext() {
	    if (this.iterator.moveNext()) {
	      ++this.index;
	      return true;
	    }

	    return false;
	  };

	  /**
	   * Creates a new sequence whose values are calculated by accessing the specified
	   * property from each element in this sequence.
	   *
	   * @public
	   * @param {string} propertyName The name of the property to access for every
	   *     element in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { first: "Dan", last: "Tao" },
	   *   { first: "Bob", last: "Smith" }
	   * ];
	   *
	   * Lazy(people).pluck("last") // sequence: ["Tao", "Smith"]
	   */
	  Sequence.prototype.pluck = function pluck(property) {
	    return this.map(property);
	  };

	  /**
	   * Creates a new sequence whose values are calculated by invoking the specified
	   * function on each element in this sequence.
	   *
	   * @public
	   * @param {string} methodName The name of the method to invoke for every element
	   *     in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function Person(first, last) {
	   *   this.fullName = function fullName() {
	   *     return first + " " + last;
	   *   };
	   * }
	   *
	   * var people = [
	   *   new Person("Dan", "Tao"),
	   *   new Person("Bob", "Smith")
	   * ];
	   *
	   * Lazy(people).invoke("fullName") // sequence: ["Dan Tao", "Bob Smith"]
	   */
	  Sequence.prototype.invoke = function invoke(methodName) {
	    return this.map(function(e) {
	      return e[methodName]();
	    });
	  };

	  /**
	   * Creates a new sequence whose values are the elements of this sequence which
	   * satisfy the specified predicate.
	   *
	   * @public
	   * @aka select
	   * @param {Function} filterFn The predicate to call on each element in this
	   *     sequence, which returns true if the element should be included.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5, 6];
	   *
	   * Lazy(numbers).filter(isEven) // sequence: [2, 4, 6]
	   *
	   * @benchmarks
	   * function isEven(x) { return x % 2 === 0; }
	   *
	   * var smArr = Lazy.range(10).toArray(),
	   *     lgArr = Lazy.range(100).toArray();
	   *
	   * Lazy(smArr).filter(isEven).each(Lazy.noop) // lazy - 10 elements
	   * Lazy(lgArr).filter(isEven).each(Lazy.noop) // lazy - 100 elements
	   * _.each(_.filter(smArr, isEven), _.noop)    // lodash - 10 elements
	   * _.each(_.filter(lgArr, isEven), _.noop)    // lodash - 100 elements
	   */
	  Sequence.prototype.filter = function filter(filterFn) {
	    return new FilteredSequence(this, createCallback(filterFn));
	  };

	  Sequence.prototype.select = function select(filterFn) {
	    return this.filter(filterFn);
	  };

	  /**
	   * @constructor
	   */
	  function FilteredSequence(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredSequence.prototype = new Sequence();

	  FilteredSequence.prototype.getIterator = function getIterator() {
	    return new FilteringIterator(this.parent, this.filterFn);
	  };

	  FilteredSequence.prototype.each = function each(fn) {
	    var filterFn = this.filterFn,
	        j = 0;

	    return this.parent.each(function(e, i) {
	      if (filterFn(e, i)) {
	        return fn(e, j++);
	      }
	    });
	  };

	  FilteredSequence.prototype.reverse = function reverse() {
	    return this.parent.reverse().filter(this.filterFn);
	  };

	  /**
	   * @constructor
	   */
	  function FilteringIterator(sequence, filterFn) {
	    this.iterator = sequence.getIterator();
	    this.filterFn = filterFn;
	    this.index    = 0;
	  }

	  FilteringIterator.prototype.current = function current() {
	    return this.value;
	  };

	  FilteringIterator.prototype.moveNext = function moveNext() {
	    var iterator = this.iterator,
	        filterFn = this.filterFn,
	        value;

	    while (iterator.moveNext()) {
	      value = iterator.current();
	      if (filterFn(value, this.index++)) {
	        this.value = value;
	        return true;
	      }
	    }

	    this.value = undefined;
	    return false;
	  };

	  /**
	   * Creates a new sequence whose values exclude the elements of this sequence
	   * identified by the specified predicate.
	   *
	   * @public
	   * @param {Function} rejectFn The predicate to call on each element in this
	   *     sequence, which returns true if the element should be omitted.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).reject(isEven)              // sequence: [1, 3, 5]
	   * Lazy([{ foo: 1 }, { bar: 2 }]).reject('foo')      // sequence: [{ bar: 2 }]
	   * Lazy([{ foo: 1 }, { foo: 2 }]).reject({ foo: 2 }) // sequence: [{ foo: 1 }]
	   */
	  Sequence.prototype.reject = function reject(rejectFn) {
	    rejectFn = createCallback(rejectFn);
	    return this.filter(function(e) { return !rejectFn(e); });
	  };

	  /**
	   * Creates a new sequence whose values have the specified type, as determined
	   * by the `typeof` operator.
	   *
	   * @public
	   * @param {string} type The type of elements to include from the underlying
	   *     sequence, i.e. where `typeof [element] === [type]`.
	   * @returns {Sequence} The new sequence, comprising elements of the specified
	   *     type.
	   *
	   * @examples
	   * Lazy([1, 2, 'foo', 'bar']).ofType('number')  // sequence: [1, 2]
	   * Lazy([1, 2, 'foo', 'bar']).ofType('string')  // sequence: ['foo', 'bar']
	   * Lazy([1, 2, 'foo', 'bar']).ofType('boolean') // sequence: []
	   */
	  Sequence.prototype.ofType = function ofType(type) {
	    return this.filter(function(e) { return typeof e === type; });
	  };

	  /**
	   * Creates a new sequence whose values are the elements of this sequence with
	   * property names and values matching those of the specified object.
	   *
	   * @public
	   * @param {Object} properties The properties that should be found on every
	   *     element that is to be included in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { first: "Dan", last: "Tao" },
	   *   { first: "Bob", last: "Smith" }
	   * ];
	   *
	   * Lazy(people).where({ first: "Dan" }) // sequence: [{ first: "Dan", last: "Tao" }]
	   *
	   * @benchmarks
	   * var animals = ["dog", "cat", "mouse", "horse", "pig", "snake"];
	   *
	   * Lazy(animals).where({ length: 3 }).each(Lazy.noop) // lazy
	   * _.each(_.where(animals, { length: 3 }), _.noop)    // lodash
	   */
	  Sequence.prototype.where = function where(properties) {
	    return this.filter(properties);
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but to be iterated
	   * in the opposite order.
	   *
	   * Note that in some (but not all) cases, the only way to create such a sequence
	   * may require iterating the entire underlying source when `each` is called.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).reverse() // sequence: [3, 2, 1]
	   * Lazy([]).reverse()        // sequence: []
	   */
	  Sequence.prototype.reverse = function reverse() {
	    return new ReversedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ReversedSequence(parent) {
	    this.parent = parent;
	  }

	  ReversedSequence.prototype = new Sequence();

	  ReversedSequence.prototype.getIterator = function getIterator() {
	    return new ReversedIterator(this.parent);
	  };

	  /**
	   * @constuctor
	   */
	  function ReversedIterator(sequence) {
	    this.sequence = sequence;
	  }

	  ReversedIterator.prototype.current = function current() {
	    return this.getIndex().get(this.index);
	  };

	  ReversedIterator.prototype.moveNext = function moveNext() {
	    var index  = this.getIndex(),
	        length = index.length();

	    if (typeof this.index === "undefined") {
	      this.index = length;
	    }

	    return (--this.index >= 0);
	  };

	  ReversedIterator.prototype.getIndex = function getIndex() {
	    if (!this.cachedIndex) {
	      this.cachedIndex = this.sequence.getIndex();
	    }

	    return this.cachedIndex;
	  };

	  /**
	   * Creates a new sequence with all of the elements of this one, plus those of
	   * the given array(s).
	   *
	   * @public
	   * @param {...*} var_args One or more values (or arrays of values) to use for
	   *     additional items after this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var left  = [1, 2, 3];
	   * var right = [4, 5, 6];
	   *
	   * Lazy(left).concat(right)         // sequence: [1, 2, 3, 4, 5, 6]
	   * Lazy(left).concat(Lazy(right))   // sequence: [1, 2, 3, 4, 5, 6]
	   * Lazy(left).concat(right, [7, 8]) // sequence: [1, 2, 3, 4, 5, 6, 7, 8]
	   */
	  Sequence.prototype.concat = function concat(var_args) {
	    return new ConcatenatedSequence(this, arraySlice.call(arguments, 0));
	  };

	  /**
	   * @constructor
	   */
	  function ConcatenatedSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  ConcatenatedSequence.prototype = new Sequence();

	  ConcatenatedSequence.prototype.each = function each(fn) {
	    var done = false,
	        i = 0;

	    this.parent.each(function(e) {
	      if (fn(e, i++) === false) {
	        done = true;
	        return false;
	      }
	    });

	    if (!done) {
	      Lazy(this.arrays).flatten().each(function(e) {
	        if (fn(e, i++) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Creates a new sequence comprising the first N elements from this sequence, OR
	   * (if N is `undefined`) simply returns the first element of this sequence.
	   *
	   * @public
	   * @aka head, take
	   * @param {number=} count The number of elements to take from this sequence. If
	   *     this value exceeds the length of the sequence, the resulting sequence
	   *     will be essentially the same as this one.
	   * @returns {*} The new sequence (or the first element from this sequence if
	   *     no count was given).
	   *
	   * @examples
	   * function powerOfTwo(exp) {
	   *   return Math.pow(2, exp);
	   * }
	   *
	   * Lazy.generate(powerOfTwo).first()          // => 1
	   * Lazy.generate(powerOfTwo).first(5)         // sequence: [1, 2, 4, 8, 16]
	   * Lazy.generate(powerOfTwo).skip(2).first()  // => 4
	   * Lazy.generate(powerOfTwo).skip(2).first(2) // sequence: [4, 8]
	   */
	  Sequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return getFirst(this);
	    }
	    return new TakeSequence(this, count);
	  };

	  Sequence.prototype.head =
	  Sequence.prototype.take = function (count) {
	    return this.first(count);
	  };

	  /**
	   * @constructor
	   */
	  function TakeSequence(parent, count) {
	    this.parent = parent;
	    this.count  = count;
	  }

	  TakeSequence.prototype = new Sequence();

	  TakeSequence.prototype.getIterator = function getIterator() {
	    return new TakeIterator(this.parent, this.count);
	  };

	  TakeSequence.prototype.each = function each(fn) {
	    var count = this.count,
	        i     = 0;

	    var result;
	    var handle = this.parent.each(function(e) {
	      if (i < count) { result = fn(e, i++); }
	      if (i >= count) { return false; }
	      return result;
	    });

	    if (handle instanceof AsyncHandle) {
	      return handle;
	    }

	    return i === count && result !== false;
	  };

	  /**
	   * @constructor
	   */
	  function TakeIterator(sequence, count) {
	    this.iterator = sequence.getIterator();
	    this.count    = count;
	  }

	  TakeIterator.prototype.current = function current() {
	    return this.iterator.current();
	  };

	  TakeIterator.prototype.moveNext = function moveNext() {
	    return ((--this.count >= 0) && this.iterator.moveNext());
	  };

	  /**
	   * Creates a new sequence comprising the elements from the head of this sequence
	   * that satisfy some predicate. Once an element is encountered that doesn't
	   * satisfy the predicate, iteration will stop.
	   *
	   * @public
	   * @param {Function} predicate
	   * @returns {Sequence} The new sequence
	   *
	   * @examples
	   * function lessThan(x) {
	   *   return function(y) {
	   *     return y < x;
	   *   };
	   * }
	   *
	   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(3)) // sequence: [1, 2]
	   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(0)) // sequence: []
	   */
	  Sequence.prototype.takeWhile = function takeWhile(predicate) {
	    return new TakeWhileSequence(this, predicate);
	  };

	  /**
	   * @constructor
	   */
	  function TakeWhileSequence(parent, predicate) {
	    this.parent    = parent;
	    this.predicate = predicate;
	  }

	  TakeWhileSequence.prototype = new Sequence();

	  TakeWhileSequence.prototype.each = function each(fn) {
	    var predicate = this.predicate,
	        finished = false,
	        j = 0;

	    var result = this.parent.each(function(e, i) {
	      if (!predicate(e, i)) {
	        finished = true;
	        return false;
	      }

	      return fn(e, j++);
	    });

	    if (result instanceof AsyncHandle) {
	      return result;
	    }

	    return finished;
	  };

	  /**
	   * Creates a new sequence comprising all but the last N elements of this
	   * sequence.
	   *
	   * @public
	   * @param {number=} count The number of items to omit from the end of the
	   *     sequence (defaults to 1).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).initial()                    // sequence: [1, 2, 3]
	   * Lazy([1, 2, 3, 4]).initial(2)                   // sequence: [1, 2]
	   * Lazy([1, 2, 3]).filter(Lazy.identity).initial() // sequence: [1, 2]
	   */
	  Sequence.prototype.initial = function initial(count) {
	    return new InitialSequence(this, count);
	  };

	  function InitialSequence(parent, count) {
	    this.parent = parent;
	    this.count = typeof count === "number" ? count : 1;
	  }

	  InitialSequence.prototype = new Sequence();

	  InitialSequence.prototype.each = function each(fn) {
	    var index = this.parent.getIndex();
	    return index.take(index.length() - this.count).each(fn);
	  };

	  /**
	   * Creates a new sequence comprising the last N elements of this sequence, OR
	   * (if N is `undefined`) simply returns the last element of this sequence.
	   *
	   * @public
	   * @param {number=} count The number of items to take from the end of the
	   *     sequence.
	   * @returns {*} The new sequence (or the last element from this sequence
	   *     if no count was given).
	   *
	   * @examples
	   * Lazy([1, 2, 3]).last()                 // => 3
	   * Lazy([1, 2, 3]).last(2)                // sequence: [2, 3]
	   * Lazy([1, 2, 3]).filter(isEven).last(2) // sequence: [2]
	   */
	  Sequence.prototype.last = function last(count) {
	    if (typeof count === "undefined") {
	      return this.reverse().first();
	    }
	    return this.reverse().take(count).reverse();
	  };

	  /**
	   * Returns the first element in this sequence with property names and values
	   * matching those of the specified object.
	   *
	   * @public
	   * @param {Object} properties The properties that should be found on some
	   *     element in this sequence.
	   * @returns {*} The found element, or `undefined` if none exists in this
	   *     sequence.
	   *
	   * @examples
	   * var words = ["foo", "bar"];
	   *
	   * Lazy(words).findWhere({ 0: "f" }); // => "foo"
	   * Lazy(words).findWhere({ 0: "z" }); // => undefined
	   */
	  Sequence.prototype.findWhere = function findWhere(properties) {
	    return this.where(properties).first();
	  };

	  /**
	   * Creates a new sequence comprising all but the first N elements of this
	   * sequence.
	   *
	   * @public
	   * @aka skip, tail, rest
	   * @param {number=} count The number of items to omit from the beginning of the
	   *     sequence (defaults to 1).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4]).rest()  // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3, 4]).rest(0) // sequence: [1, 2, 3, 4]
	   * Lazy([1, 2, 3, 4]).rest(2) // sequence: [3, 4]
	   * Lazy([1, 2, 3, 4]).rest(5) // sequence: []
	   */
	  Sequence.prototype.rest = function rest(count) {
	    return new DropSequence(this, count);
	  };

	  Sequence.prototype.skip =
	  Sequence.prototype.tail =
	  Sequence.prototype.drop = function drop(count) {
	    return this.rest(count);
	  };

	  /**
	   * @constructor
	   */
	  function DropSequence(parent, count) {
	    this.parent = parent;
	    this.count  = typeof count === "number" ? count : 1;
	  }

	  DropSequence.prototype = new Sequence();

	  DropSequence.prototype.each = function each(fn) {
	    var count   = this.count,
	        dropped = 0,
	        i       = 0;

	    return this.parent.each(function(e) {
	      if (dropped++ < count) { return; }
	      return fn(e, i++);
	    });
	  };

	  /**
	   * Creates a new sequence comprising the elements from this sequence *after*
	   * those that satisfy some predicate. The sequence starts with the first
	   * element that does not match the predicate.
	   *
	   * @public
	   * @aka skipWhile
	   * @param {Function} predicate
	   * @returns {Sequence} The new sequence
	   */
	  Sequence.prototype.dropWhile = function dropWhile(predicate) {
	    return new DropWhileSequence(this, predicate);
	  };

	  Sequence.prototype.skipWhile = function skipWhile(predicate) {
	    return this.dropWhile(predicate);
	  };

	  /**
	   * @constructor
	   */
	  function DropWhileSequence(parent, predicate) {
	    this.parent    = parent;
	    this.predicate = predicate;
	  }

	  DropWhileSequence.prototype = new Sequence();

	  DropWhileSequence.prototype.each = function each(fn) {
	    var predicate = this.predicate,
	        done      = false;

	    return this.parent.each(function(e) {
	      if (!done) {
	        if (predicate(e)) {
	          return;
	        }

	        done = true;
	      }

	      return fn(e);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but ordered
	   * using the specified comparison function.
	   *
	   * This has essentially the same behavior as calling
	   * [`Array#sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort),
	   * but obviously instead of modifying the collection it returns a new
	   * {@link Sequence} object.
	   *
	   * @public
	   * @param {Function=} sortFn The function used to compare elements in the
	   *     sequence. The function will be passed two elements and should return:
	   *     - 1 if the first is greater
	   *     - -1 if the second is greater
	   *     - 0 if the two values are the same
	   * @param {boolean} descending Whether or not the resulting sequence should be
	   *     in descending order (defaults to `false`).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([5, 10, 1]).sort()                // sequence: [1, 5, 10]
	   * Lazy(['foo', 'bar']).sort()            // sequence: ['bar', 'foo']
	   * Lazy(['b', 'c', 'a']).sort(null, true) // sequence: ['c', 'b', 'a']
	   * Lazy([5, 10, 1]).sort(null, true)      // sequence: [10, 5, 1]
	   *
	   * // Sorting w/ custom comparison function
	   * Lazy(['a', 'ab', 'aa', 'ba', 'b', 'abc']).sort(function compare(x, y) {
	   *   if (x.length && (x.length !== y.length)) { return compare(x.length, y.length); }
	   *   if (x === y) { return 0; }
	   *   return x > y ? 1 : -1;
	   * });
	   * // => sequence: ['a', 'b', 'aa', 'ab', 'ba', 'abc']
	   */
	  Sequence.prototype.sort = function sort(sortFn, descending) {
	    sortFn || (sortFn = compare);
	    if (descending) { sortFn = reverseArguments(sortFn); }
	    return new SortedSequence(this, sortFn);
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, but ordered by
	   * the results of the given function.
	   *
	   * You can pass:
	   *
	   * - a *string*, to sort by the named property
	   * - a function, to sort by the result of calling the function on each element
	   *
	   * @public
	   * @param {Function} sortFn The function to call on the elements in this
	   *     sequence, in order to sort them.
	   * @param {boolean} descending Whether or not the resulting sequence should be
	   *     in descending order (defaults to `false`).
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function population(country) {
	   *   return country.pop;
	   * }
	   *
	   * function area(country) {
	   *   return country.sqkm;
	   * }
	   *
	   * var countries = [
	   *   { name: "USA", pop: 320000000, sqkm: 9600000 },
	   *   { name: "Brazil", pop: 194000000, sqkm: 8500000 },
	   *   { name: "Nigeria", pop: 174000000, sqkm: 924000 },
	   *   { name: "China", pop: 1350000000, sqkm: 9700000 },
	   *   { name: "Russia", pop: 143000000, sqkm: 17000000 },
	   *   { name: "Australia", pop: 23000000, sqkm: 7700000 }
	   * ];
	   *
	   * Lazy(countries).sortBy(population).last(3).pluck('name') // sequence: ["Brazil", "USA", "China"]
	   * Lazy(countries).sortBy(area).last(3).pluck('name')       // sequence: ["USA", "China", "Russia"]
	   * Lazy(countries).sortBy(area, true).first(3).pluck('name') // sequence: ["Russia", "China", "USA"]
	   *
	   * @benchmarks
	   * var randoms = Lazy.generate(Math.random).take(100).toArray();
	   *
	   * Lazy(randoms).sortBy(Lazy.identity).each(Lazy.noop) // lazy
	   * _.each(_.sortBy(randoms, Lazy.identity), _.noop)    // lodash
	   */
	  Sequence.prototype.sortBy = function sortBy(sortFn, descending) {
	    sortFn = createComparator(sortFn);
	    if (descending) { sortFn = reverseArguments(sortFn); }
	    return new SortedSequence(this, sortFn);
	  };

	  /**
	   * @constructor
	   */
	  function SortedSequence(parent, sortFn) {
	    this.parent = parent;
	    this.sortFn = sortFn;
	  }

	  SortedSequence.prototype = new Sequence();

	  SortedSequence.prototype.each = function each(fn) {
	    var sortFn = this.sortFn,
	        result = this.parent.toArray();

	    result.sort(sortFn);

	    return forEach(result, fn);
	  };

	  /**
	   * @examples
	   * var items = [{ a: 4 }, { a: 3 }, { a: 5 }];
	   *
	   * Lazy(items).sortBy('a').reverse();
	   * // => sequence: [{ a: 5 }, { a: 4 }, { a: 3 }]
	   *
	   * Lazy(items).sortBy('a').reverse().reverse();
	   * // => sequence: [{ a: 3 }, { a: 4 }, { a: 5 }]
	   */
	  SortedSequence.prototype.reverse = function reverse() {
	    return new SortedSequence(this.parent, reverseArguments(this.sortFn));
	  };

	  /**
	   * Creates a new {@link ObjectLikeSequence} comprising the elements in this
	   * one, grouped together according to some key. The value associated with each
	   * key in the resulting object-like sequence is an array containing all of
	   * the elements in this sequence with that key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to group them, or a string representing
	   *     a parameter to read from all the elements in this sequence.
	   * @param {Function|string} valFn (Optional) The function to call on the elements
	   *     in this sequence to assign to the value for each instance to appear in the
	   *     group, or a string representing a parameter to read from all the elements
	   *     in this sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * function oddOrEven(x) {
	   *   return x % 2 === 0 ? 'even' : 'odd';
	   * }
	   * function square(x) {
	   *   return x*x;
	   * }
	   *
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).groupBy(oddOrEven)                     // sequence: { odd: [1, 3, 5], even: [2, 4] }
	   * Lazy(numbers).groupBy(oddOrEven).get("odd")          // => [1, 3, 5]
	   * Lazy(numbers).groupBy(oddOrEven).get("foo")          // => undefined
	   * Lazy(numbers).groupBy(oddOrEven, square).get("even") // => [4, 16]
	   *
	   * Lazy([
	   *   { name: 'toString' },
	   *   { name: 'toString' }
	   * ]).groupBy('name');
	   * // => sequence: {
	   *   'toString': [
	   *     { name: 'toString' },
	   *     { name: 'toString' }
	   *   ]
	   * }
	   */
	  Sequence.prototype.groupBy = function groupBy(keyFn, valFn) {
	    return new GroupedSequence(this, keyFn, valFn);
	  };

	  /**
	   * @constructor
	   */
	  function GroupedSequence(parent, keyFn, valFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	    this.valFn  = valFn;
	  }

	  // GroupedSequence must have its prototype set after ObjectLikeSequence has
	  // been fully initialized.

	  /**
	   * Creates a new {@link ObjectLikeSequence} comprising the elements in this
	   * one, indexed according to some key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to index them, or a string
	   *     representing a property to read from all the elements in this sequence.
	   * @param {Function|string} valFn (Optional) The function to call on the elements
	   *     in this sequence to assign to the value of the indexed object, or a string
	   *     representing a parameter to read from all the elements in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var people = [
	   *   { name: 'Bob', age: 25 },
	   *   { name: 'Fred', age: 34 }
	   * ];
	   *
	   * var bob  = people[0],
	   *     fred = people[1];
	   *
	   * Lazy(people).indexBy('name')        // sequence: { 'Bob': bob, 'Fred': fred }
	   * Lazy(people).indexBy('name', 'age') // sequence: { 'Bob': 25, 'Fred': 34 }
	   */
	  Sequence.prototype.indexBy = function(keyFn, valFn) {
	    return new IndexedSequence(this, keyFn, valFn);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedSequence(parent, keyFn, valFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	    this.valFn  = valFn;
	  }

	  // IndexedSequence must have its prototype set after ObjectLikeSequence has
	  // been fully initialized.

	  /**
	   * Creates a new {@link ObjectLikeSequence} containing the unique keys of all
	   * the elements in this sequence, each paired with the number of elements
	   * in this sequence having that key.
	   *
	   * @public
	   * @param {Function|string} keyFn The function to call on the elements in this
	   *     sequence to obtain a key by which to count them, or a string representing
	   *     a parameter to read from all the elements in this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * function oddOrEven(x) {
	   *   return x % 2 === 0 ? 'even' : 'odd';
	   * }
	   *
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).countBy(oddOrEven)            // sequence: { odd: 3, even: 2 }
	   * Lazy(numbers).countBy(oddOrEven).get("odd") // => 3
	   * Lazy(numbers).countBy(oddOrEven).get("foo") // => undefined
	   */
	  Sequence.prototype.countBy = function countBy(keyFn) {
	    return new CountedSequence(this, keyFn);
	  };

	  /**
	   * @constructor
	   */
	  function CountedSequence(parent, keyFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	  }

	  // CountedSequence, like GroupedSequence, must have its prototype set after
	  // ObjectLikeSequence has been fully initialized.

	  /**
	   * Creates a new sequence with every unique element from this one appearing
	   * exactly once (i.e., with duplicates removed).
	   *
	   * @public
	   * @aka unique
	   * @param {Function} keyFn An optional function to produce the key for each
	   *     object. This key is then tested for uniqueness as  opposed to the
	   *     object reference.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 2, 3, 3, 3]).uniq() // sequence: [1, 2, 3]
	   * Lazy([{ name: 'mike' }, 
	   * 	{ name: 'sarah' }, 
	   * 	{ name: 'mike' }
	   * ]).uniq('name')
	   * // sequence: [{ name: 'mike' }, { name: 'sarah' }]
	   *
	   * @benchmarks
	   * function randomOf(array) {
	   *   return function() {
	   *     return array[Math.floor(Math.random() * array.length)];
	   *   };
	   * }
	   *
	   * var mostUnique = Lazy.generate(randomOf(_.range(100)), 100).toArray(),
	   *     someUnique = Lazy.generate(randomOf(_.range(50)), 100).toArray(),
	   *     mostDupes  = Lazy.generate(randomOf(_.range(5)), 100).toArray();
	   *
	   * Lazy(mostUnique).uniq().each(Lazy.noop) // lazy - mostly unique elements
	   * Lazy(someUnique).uniq().each(Lazy.noop) // lazy - some unique elements
	   * Lazy(mostDupes).uniq().each(Lazy.noop)  // lazy - mostly duplicate elements
	   * _.each(_.uniq(mostUnique), _.noop)      // lodash - mostly unique elements
	   * _.each(_.uniq(someUnique), _.noop)      // lodash - some unique elements
	   * _.each(_.uniq(mostDupes), _.noop)       // lodash - mostly duplicate elements
	   */
	  Sequence.prototype.uniq = function uniq(keyFn) {
	    return new UniqueSequence(this, keyFn);
	  };

	  Sequence.prototype.unique = function unique(keyFn) {
	    return this.uniq(keyFn);
	  };

	  /**
	   * @constructor
	   */
	  function UniqueSequence(parent, keyFn) {
	    this.parent = parent;
	    this.keyFn  = keyFn;
	  }

	  UniqueSequence.prototype = new Sequence();

	  UniqueSequence.prototype.each = function each(fn) {
	    var cache = new Set(),
	        keyFn = this.keyFn,
	        i     = 0;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      return this.parent.each(function(e) {
	        if (cache.add(keyFn(e))) {
	          return fn(e, i++);
	        }
	      });

	    } else {
	      return this.parent.each(function(e) {
	        if (cache.add(e)) {
	          return fn(e, i++);
	        }
	      });
	    }
	  };

	  /**
	   * Creates a new sequence by combining the elements from this sequence with
	   * corresponding elements from the specified array(s).
	   *
	   * @public
	   * @param {...Array} var_args One or more arrays of elements to combine with
	   *     those of this sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2]).zip([3, 4]) // sequence: [[1, 3], [2, 4]]
	   *
	   * @benchmarks
	   * var smArrL = Lazy.range(10).toArray(),
	   *     smArrR = Lazy.range(10, 20).toArray(),
	   *     lgArrL = Lazy.range(100).toArray(),
	   *     lgArrR = Lazy.range(100, 200).toArray();
	   *
	   * Lazy(smArrL).zip(smArrR).each(Lazy.noop) // lazy - zipping 10-element arrays
	   * Lazy(lgArrL).zip(lgArrR).each(Lazy.noop) // lazy - zipping 100-element arrays
	   * _.each(_.zip(smArrL, smArrR), _.noop)    // lodash - zipping 10-element arrays
	   * _.each(_.zip(lgArrL, lgArrR), _.noop)    // lodash - zipping 100-element arrays
	   */
	  Sequence.prototype.zip = function zip(var_args) {
	    if (arguments.length === 1) {
	      return new SimpleZippedSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return new ZippedSequence(this, arraySlice.call(arguments, 0));
	    }
	  };

	  /**
	   * @constructor
	   */
	  function ZippedSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  ZippedSequence.prototype = new Sequence();

	  ZippedSequence.prototype.each = function each(fn) {
	    var arrays = this.arrays,
	        i = 0;
	    this.parent.each(function(e) {
	      var group = [e];
	      for (var j = 0; j < arrays.length; ++j) {
	        if (arrays[j].length > i) {
	          group.push(arrays[j][i]);
	        }
	      }
	      return fn(group, i++);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, in a randomized
	   * order.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).shuffle().value() // =~ [1, 2, 3, 4, 5]
	   */
	  Sequence.prototype.shuffle = function shuffle() {
	    return new ShuffledSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ShuffledSequence(parent) {
	    this.parent = parent;
	  }

	  ShuffledSequence.prototype = new Sequence();

	  ShuffledSequence.prototype.each = function each(fn) {
	    var shuffled = this.parent.toArray(),
	        floor = Math.floor,
	        random = Math.random,
	        j = 0;

	    for (var i = shuffled.length - 1; i > 0; --i) {
	      swap(shuffled, i, floor(random() * (i + 1)));
	      if (fn(shuffled[i], j++) === false) {
	        return;
	      }
	    }
	    fn(shuffled[0], j);
	  };

	  /**
	   * Creates a new sequence with every element from this sequence, and with arrays
	   * exploded so that a sequence of arrays (of arrays) becomes a flat sequence of
	   * values.
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, [2, 3], [4, [5]]]).flatten() // sequence: [1, 2, 3, 4, 5]
	   * Lazy([1, Lazy([2, 3])]).flatten()     // sequence: [1, 2, 3]
	   */
	  Sequence.prototype.flatten = function flatten() {
	    return new FlattenedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function FlattenedSequence(parent) {
	    this.parent = parent;
	  }

	  FlattenedSequence.prototype = new Sequence();

	  FlattenedSequence.prototype.each = function each(fn) {
	    var index = 0;

	    return this.parent.each(function recurseVisitor(e) {
	      if (e instanceof Array) {
	        return forEach(e, recurseVisitor);
	      }

	      if (e instanceof Sequence) {
	        return e.each(recurseVisitor);
	      }

	      return fn(e, index++);
	    });
	  };

	  /**
	   * Creates a new sequence with the same elements as this one, except for all
	   * falsy values (`false`, `0`, `""`, `null`, and `undefined`).
	   *
	   * @public
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", null, "bar", undefined]).compact() // sequence: ["foo", "bar"]
	   */
	  Sequence.prototype.compact = function compact() {
	    return this.filter(function(e) { return !!e; });
	  };

	  /**
	   * Creates a new sequence with all the elements of this sequence that are not
	   * also among the specified arguments.
	   *
	   * @public
	   * @aka difference
	   * @param {...*} var_args The values, or array(s) of values, to be excluded from the
	   *     resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).without(2, 3)   // sequence: [1, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).without([4, 5]) // sequence: [1, 2, 3]
	   */
	  Sequence.prototype.without = function without(var_args) {
	    return new WithoutSequence(this, arraySlice.call(arguments, 0));
	  };

	  Sequence.prototype.difference = function difference(var_args) {
	    return this.without.apply(this, arguments);
	  };

	  /**
	   * @constructor
	   */
	  function WithoutSequence(parent, values) {
	    this.parent = parent;
	    this.values = values;
	  }

	  WithoutSequence.prototype = new Sequence();

	  WithoutSequence.prototype.each = function each(fn) {
	    var set = createSet(this.values),
	        i = 0;
	    return this.parent.each(function(e) {
	      if (!set.contains(e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  /**
	   * Creates a new sequence with all the unique elements either in this sequence
	   * or among the specified arguments.
	   *
	   * @public
	   * @param {...*} var_args The values, or array(s) of values, to be additionally
	   *     included in the resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", "bar"]).union([])             // sequence: ["foo", "bar"]
	   * Lazy(["foo", "bar"]).union(["bar", "baz"]) // sequence: ["foo", "bar", "baz"]
	   */
	  Sequence.prototype.union = function union(var_args) {
	    return this.concat(var_args).uniq();
	  };

	  /**
	   * Creates a new sequence with all the elements of this sequence that also
	   * appear among the specified arguments.
	   *
	   * @public
	   * @param {...*} var_args The values, or array(s) of values, in which elements
	   *     from this sequence must also be included to end up in the resulting sequence.
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * Lazy(["foo", "bar"]).intersection([])             // sequence: []
	   * Lazy(["foo", "bar"]).intersection(["bar", "baz"]) // sequence: ["bar"]
	   */
	  Sequence.prototype.intersection = function intersection(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new SimpleIntersectionSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return new IntersectionSequence(this, arraySlice.call(arguments, 0));
	    }
	  };

	  /**
	   * @constructor
	   */
	  function IntersectionSequence(parent, arrays) {
	    this.parent = parent;
	    this.arrays = arrays;
	  }

	  IntersectionSequence.prototype = new Sequence();

	  IntersectionSequence.prototype.each = function each(fn) {
	    var sets = Lazy(this.arrays).map(function(values) {
	      return new UniqueMemoizer(Lazy(values).getIterator());
	    });

	    var setIterator = new UniqueMemoizer(sets.getIterator()),
	        i = 0;

	    return this.parent.each(function(e) {
	      var includedInAll = true;
	      setIterator.each(function(set) {
	        if (!set.contains(e)) {
	          includedInAll = false;
	          return false;
	        }
	      });

	      if (includedInAll) {
	        return fn(e, i++);
	      }
	    });
	  };

	  /**
	   * @constructor
	   */
	  function UniqueMemoizer(iterator) {
	    this.iterator     = iterator;
	    this.set          = new Set();
	    this.memo         = [];
	    this.currentValue = undefined;
	  }

	  UniqueMemoizer.prototype.current = function current() {
	    return this.currentValue;
	  };

	  UniqueMemoizer.prototype.moveNext = function moveNext() {
	    var iterator = this.iterator,
	        set = this.set,
	        memo = this.memo,
	        current;

	    while (iterator.moveNext()) {
	      current = iterator.current();
	      if (set.add(current)) {
	        memo.push(current);
	        this.currentValue = current;
	        return true;
	      }
	    }
	    return false;
	  };

	  UniqueMemoizer.prototype.each = function each(fn) {
	    var memo = this.memo,
	        length = memo.length,
	        i = -1;

	    while (++i < length) {
	      if (fn(memo[i], i) === false) {
	        return false;
	      }
	    }

	    while (this.moveNext()) {
	      if (fn(this.currentValue, i++) === false) {
	        break;
	      }
	    }
	  };

	  UniqueMemoizer.prototype.contains = function contains(e) {
	    if (this.set.contains(e)) {
	      return true;
	    }

	    while (this.moveNext()) {
	      if (this.currentValue === e) {
	        return true;
	      }
	    }

	    return false;
	  };

	  /**
	   * Checks whether every element in this sequence satisfies a given predicate.
	   *
	   * @public
	   * @aka all
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` returns true for every element in the
	   *     sequence (or the sequence is empty). False if `predicate` returns false
	   *     for at least one element.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * var objects = [{ foo: true }, { foo: false, bar: true }];
	   *
	   * Lazy(numbers).every(isEven)     // => false
	   * Lazy(numbers).every(isPositive) // => true
	   * Lazy(objects).all('foo')        // => false
	   * Lazy(objects).all('bar')        // => false
	   */
	  Sequence.prototype.every = function every(predicate) {
	    predicate = createCallback(predicate);

	    return this.each(function(e, i) {
	      return !!predicate(e, i);
	    });
	  };

	  Sequence.prototype.all = function all(predicate) {
	    return this.every(predicate);
	  };

	  /**
	   * Checks whether at least one element in this sequence satisfies a given
	   * predicate (or, if no predicate is specified, whether the sequence contains at
	   * least one element).
	   *
	   * @public
	   * @aka any
	   * @param {Function=} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` returns true for at least one element
	   *     in the sequence. False if `predicate` returns false for every element (or
	   *     the sequence is empty).
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).some()           // => true
	   * Lazy(numbers).some(isEven)     // => true
	   * Lazy(numbers).some(isNegative) // => false
	   * Lazy([]).some()                // => false
	   */
	  Sequence.prototype.some = function some(predicate) {
	    predicate = createCallback(predicate, true);

	    var success = false;
	    this.each(function(e) {
	      if (predicate(e)) {
	        success = true;
	        return false;
	      }
	    });
	    return success;
	  };

	  Sequence.prototype.any = function any(predicate) {
	    return this.some(predicate);
	  };

	  /**
	   * Checks whether NO elements in this sequence satisfy the given predicate
	   * (the opposite of {@link Sequence#all}, basically).
	   *
	   * @public
	   * @param {Function=} predicate A function to call on (potentially) every element
	   *     in this sequence.
	   * @returns {boolean} True if `predicate` does not return true for any element
	   *     in the sequence. False if `predicate` returns true for at least one
	   *     element.
	   *
	   * @examples
	   * var numbers = [1, 2, 3, 4, 5];
	   *
	   * Lazy(numbers).none()           // => false
	   * Lazy(numbers).none(isEven)     // => false
	   * Lazy(numbers).none(isNegative) // => true
	   * Lazy([]).none(isEven)          // => true
	   * Lazy([]).none(isNegative)      // => true
	   * Lazy([]).none()                // => true
	   */
	  Sequence.prototype.none = function none(predicate) {
	    return !this.any(predicate);
	  };

	  /**
	   * Checks whether the sequence has no elements.
	   *
	   * @public
	   * @returns {boolean} True if the sequence is empty, false if it contains at
	   *     least one element.
	   *
	   * @examples
	   * Lazy([]).isEmpty()        // => true
	   * Lazy([1, 2, 3]).isEmpty() // => false
	   */
	  Sequence.prototype.isEmpty = function isEmpty() {
	    return !this.any();
	  };

	  /**
	   * Performs (at worst) a linear search from the head of this sequence,
	   * returning the first index at which the specified value is found.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} The index within this sequence where the given value is
	   *     located, or -1 if the sequence doesn't contain the value.
	   *
	   * @examples
	   * function reciprocal(x) { return 1 / x; }
	   *
	   * Lazy(["foo", "bar", "baz"]).indexOf("bar")   // => 1
	   * Lazy([1, 2, 3]).indexOf(4)                   // => -1
	   * Lazy([1, 2, 3]).map(reciprocal).indexOf(0.5) // => 1
	   */
	  Sequence.prototype.indexOf = function indexOf(value) {
	    var foundIndex = -1;
	    this.each(function(e, i) {
	      if (e === value) {
	        foundIndex = i;
	        return false;
	      }
	    });
	    return foundIndex;
	  };

	  /**
	   * Performs (at worst) a linear search from the tail of this sequence,
	   * returning the last index at which the specified value is found.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} The last index within this sequence where the given value
	   *     is located, or -1 if the sequence doesn't contain the value.
	   *
	   * @examples
	   * Lazy(["a", "b", "c", "b", "a"]).lastIndexOf("b")    // => 3
	   * Lazy([1, 2, 3]).lastIndexOf(0)                      // => -1
	   * Lazy([2, 2, 1, 2, 4]).filter(isEven).lastIndexOf(2) // 2
	   */
	  Sequence.prototype.lastIndexOf = function lastIndexOf(value) {
	    var reversed = this.getIndex().reverse(),
	        index    = reversed.indexOf(value);
	    if (index !== -1) {
	      index = reversed.length() - index - 1;
	    }
	    return index;
	  };

	  /**
	   * Performs a binary search of this sequence, returning the lowest index where
	   * the given value is either found, or where it belongs (if it is not already
	   * in the sequence).
	   *
	   * This method assumes the sequence is in sorted order and will fail otherwise.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {number} An index within this sequence where the given value is
	   *     located, or where it belongs in sorted order.
	   *
	   * @examples
	   * Lazy([1, 3, 6, 9]).sortedIndex(3)                    // => 1
	   * Lazy([1, 3, 6, 9]).sortedIndex(7)                    // => 3
	   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(10) // => 0
	   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(12) // => 1
	   */
	  Sequence.prototype.sortedIndex = function sortedIndex(value) {
	    var indexed = this.getIndex(),
	        lower   = 0,
	        upper   = indexed.length(),
	        i;

	    while (lower < upper) {
	      i = (lower + upper) >>> 1;
	      if (compare(indexed.get(i), value) === -1) {
	        lower = i + 1;
	      } else {
	        upper = i;
	      }
	    }
	    return lower;
	  };

	  /**
	   * Checks whether the given value is in this sequence.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {boolean} True if the sequence contains the value, false if not.
	   *
	   * @examples
	   * var numbers = [5, 10, 15, 20];
	   *
	   * Lazy(numbers).contains(15) // => true
	   * Lazy(numbers).contains(13) // => false
	   */
	  Sequence.prototype.contains = function contains(value) {
	    return this.indexOf(value) !== -1;
	  };

	  /**
	   * Aggregates a sequence into a single value according to some accumulator
	   * function.
	   *
	   * For an asynchronous sequence, instead of immediately returning a result
	   * (which it can't, obviously), this method returns an {@link AsyncHandle}
	   * whose `onComplete` method can be called to supply a callback to handle the
	   * final result once iteration has completed.
	   *
	   * @public
	   * @aka inject, foldl
	   * @param {Function} aggregator The function through which to pass every element
	   *     in the sequence. For every element, the function will be passed the total
	   *     aggregated result thus far and the element itself, and should return a
	   *     new aggregated result.
	   * @param {*=} memo The starting value to use for the aggregated result
	   *     (defaults to the first element in the sequence).
	   * @returns {*} The result of the aggregation, or, for asynchronous sequences,
	   *     an {@link AsyncHandle} whose `onComplete` method accepts a callback to
	   *     handle the final result.
	   *
	   * @examples
	   * function multiply(x, y) { return x * y; }
	   *
	   * var numbers = [1, 2, 3, 4];
	   *
	   * Lazy(numbers).reduce(multiply)    // => 24
	   * Lazy(numbers).reduce(multiply, 5) // => 120
	   */
	  Sequence.prototype.reduce = function reduce(aggregator, memo) {
	    if (arguments.length < 2) {
	      return this.tail().reduce(aggregator, this.head());
	    }

	    var eachResult = this.each(function(e, i) {
	      memo = aggregator(memo, e, i);
	    });

	    // TODO: Think of a way more efficient solution to this problem.
	    if (eachResult instanceof AsyncHandle) {
	      return eachResult.then(function() { return memo; });
	    }

	    return memo;
	  };

	  Sequence.prototype.inject =
	  Sequence.prototype.foldl = function foldl(aggregator, memo) {
	    return this.reduce(aggregator, memo);
	  };

	  /**
	   * Aggregates a sequence, from the tail, into a single value according to some
	   * accumulator function.
	   *
	   * @public
	   * @aka foldr
	   * @param {Function} aggregator The function through which to pass every element
	   *     in the sequence. For every element, the function will be passed the total
	   *     aggregated result thus far and the element itself, and should return a
	   *     new aggregated result.
	   * @param {*} memo The starting value to use for the aggregated result.
	   * @returns {*} The result of the aggregation.
	   *
	   * @examples
	   * function append(s1, s2) {
	   *   return s1 + s2;
	   * }
	   *
	   * function isVowel(str) {
	   *   return "aeiou".indexOf(str) !== -1;
	   * }
	   *
	   * Lazy("abcde").reduceRight(append)                 // => "edcba"
	   * Lazy("abcde").filter(isVowel).reduceRight(append) // => "ea"
	   */
	  Sequence.prototype.reduceRight = function reduceRight(aggregator, memo) {
	    if (arguments.length < 2) {
	      return this.initial(1).reduceRight(aggregator, this.last());
	    }

	    // This bothers me... but frankly, calling reverse().reduce() is potentially
	    // going to eagerly evaluate the sequence anyway; so it's really not an issue.
	    var indexed = this.getIndex(),
	        i = indexed.length() - 1;
	    return indexed.reverse().reduce(function(m, e) {
	      return aggregator(m, e, i--);
	    }, memo);
	  };

	  Sequence.prototype.foldr = function foldr(aggregator, memo) {
	    return this.reduceRight(aggregator, memo);
	  };

	  /**
	   * Groups this sequence into consecutive (overlapping) segments of a specified
	   * length. If the underlying sequence has fewer elements than the specfied
	   * length, then this sequence will be empty.
	   *
	   * @public
	   * @param {number} length The length of each consecutive segment.
	   * @returns {Sequence} The resulting sequence of consecutive segments.
	   *
	   * @examples
	   * Lazy([]).consecutive(2)        // => sequence: []
	   * Lazy([1]).consecutive(2)       // => sequence: []
	   * Lazy([1, 2]).consecutive(2)    // => sequence: [[1, 2]]
	   * Lazy([1, 2, 3]).consecutive(2) // => sequence: [[1, 2], [2, 3]]
	   * Lazy([1, 2, 3]).consecutive(0) // => sequence: [[]]
	   * Lazy([1, 2, 3]).consecutive(1) // => sequence: [[1], [2], [3]]
	   */
	  Sequence.prototype.consecutive = function consecutive(count) {
	    var queue    = new Queue(count);
	    var segments = this.map(function(element) {
	      if (queue.add(element).count === count) {
	        return queue.toArray();
	      }
	    });
	    return segments.compact();
	  };

	  /**
	   * Breaks this sequence into chunks (arrays) of a specified length.
	   *
	   * @public
	   * @param {number} size The size of each chunk.
	   * @returns {Sequence} The resulting sequence of chunks.
	   *
	   * @examples
	   * Lazy([]).chunk(2)        // sequence: []
	   * Lazy([1, 2, 3]).chunk(2) // sequence: [[1, 2], [3]]
	   * Lazy([1, 2, 3]).chunk(1) // sequence: [[1], [2], [3]]
	   * Lazy([1, 2, 3]).chunk(4) // sequence: [[1, 2, 3]]
	   * Lazy([1, 2, 3]).chunk(0) // throws
	   */
	  Sequence.prototype.chunk = function chunk(size) {
	    if (size < 1) {
	      throw new Error("You must specify a positive chunk size.");
	    }

	    return new ChunkedSequence(this, size);
	  };

	  /**
	   * @constructor
	   */
	  function ChunkedSequence(parent, size) {
	    this.parent    = parent;
	    this.chunkSize = size;
	  }

	  ChunkedSequence.prototype = new Sequence();

	  ChunkedSequence.prototype.getIterator = function getIterator() {
	    return new ChunkedIterator(this.parent, this.chunkSize);
	  };

	  /**
	   * @constructor
	   */
	  function ChunkedIterator(sequence, size) {
	    this.iterator = sequence.getIterator();
	    this.size     = size;
	  }

	  ChunkedIterator.prototype.current = function current() {
	    return this.currentChunk;
	  };

	  ChunkedIterator.prototype.moveNext = function moveNext() {
	    var iterator  = this.iterator,
	        chunkSize = this.size,
	        chunk     = [];

	    while (chunk.length < chunkSize && iterator.moveNext()) {
	      chunk.push(iterator.current());
	    }

	    if (chunk.length === 0) {
	      return false;
	    }

	    this.currentChunk = chunk;
	    return true;
	  };

	  /**
	   * Passes each element in the sequence to the specified callback during
	   * iteration. This is like {@link Sequence#each}, except that it can be
	   * inserted anywhere in the middle of a chain of methods to "intercept" the
	   * values in the sequence at that point.
	   *
	   * @public
	   * @param {Function} callback A function to call on every element in the
	   *     sequence during iteration. The return value of this function does not
	   *     matter.
	   * @returns {Sequence} A sequence comprising the same elements as this one.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).tap(fn).each(Lazy.noop); // calls fn 3 times
	   */
	  Sequence.prototype.tap = function tap(callback) {
	    return new TappedSequence(this, callback);
	  };

	  /**
	   * @constructor
	   */
	  function TappedSequence(parent, callback) {
	    this.parent = parent;
	    this.callback = callback;
	  }

	  TappedSequence.prototype = new Sequence();

	  TappedSequence.prototype.each = function each(fn) {
	    var callback = this.callback;
	    return this.parent.each(function(e, i) {
	      callback(e, i);
	      return fn(e, i);
	    });
	  };

	  /**
	   * Seaches for the first element in the sequence satisfying a given predicate.
	   *
	   * @public
	   * @aka detect
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in the sequence.
	   * @returns {*} The first element in the sequence for which `predicate` returns
	   *     `true`, or `undefined` if no such element is found.
	   *
	   * @examples
	   * function divisibleBy3(x) {
	   *   return x % 3 === 0;
	   * }
	   *
	   * var numbers = [5, 6, 7, 8, 9, 10];
	   *
	   * Lazy(numbers).find(divisibleBy3) // => 6
	   * Lazy(numbers).find(isNegative)   // => undefined
	   */
	  Sequence.prototype.find = function find(predicate) {
	    return this.filter(predicate).first();
	  };

	  Sequence.prototype.detect = function detect(predicate) {
	    return this.find(predicate);
	  };

	  /**
	   * Gets the minimum value in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function by which the value for comparison is
	   *     calculated for each element in the sequence.
	   * @returns {*} The element with the lowest value in the sequence, or
	   *     `Infinity` if the sequence is empty.
	   *
	   * @examples
	   * function negate(x) { return x * -1; }
	   *
	   * Lazy([]).min()                       // => Infinity
	   * Lazy([6, 18, 2, 49, 34]).min()       // => 2
	   * Lazy([6, 18, 2, 49, 34]).min(negate) // => 49
	   */
	  Sequence.prototype.min = function min(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.minBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return y < x ? y : x; }, Infinity);
	  };

	  Sequence.prototype.minBy = function minBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return valueFn(y) < valueFn(x) ? y : x; });
	  };

	  /**
	   * Gets the maximum value in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function by which the value for comparison is
	   *     calculated for each element in the sequence.
	   * @returns {*} The element with the highest value in the sequence, or
	   *     `-Infinity` if the sequence is empty.
	   *
	   * @examples
	   * function reverseDigits(x) {
	   *   return Number(String(x).split('').reverse().join(''));
	   * }
	   *
	   * Lazy([]).max()                              // => -Infinity
	   * Lazy([6, 18, 2, 48, 29]).max()              // => 48
	   * Lazy([6, 18, 2, 48, 29]).max(reverseDigits) // => 29
	   */
	  Sequence.prototype.max = function max(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.maxBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return y > x ? y : x; }, -Infinity);
	  };

	  Sequence.prototype.maxBy = function maxBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return valueFn(y) > valueFn(x) ? y : x; });
	  };

	  /**
	   * Gets the sum of the values in the sequence.
	   *
	   * @public
	   * @param {Function=} valueFn The function used to select the values that will
	   *     be summed up.
	   * @returns {*} The sum.
	   *
	   * @examples
	   * Lazy([]).sum()                     // => 0
	   * Lazy([1, 2, 3, 4]).sum()           // => 10
	   * Lazy([1.2, 3.4]).sum(Math.floor)   // => 4
	   * Lazy(['foo', 'bar']).sum('length') // => 6
	   */
	  Sequence.prototype.sum = function sum(valueFn) {
	    if (typeof valueFn !== "undefined") {
	      return this.sumBy(valueFn);
	    }

	    return this.reduce(function(x, y) { return x + y; }, 0);
	  };

	  Sequence.prototype.sumBy = function sumBy(valueFn) {
	    valueFn = createCallback(valueFn);
	    return this.reduce(function(x, y) { return x + valueFn(y); }, 0);
	  };

	  /**
	   * Creates a string from joining together all of the elements in this sequence,
	   * separated by the given delimiter.
	   *
	   * @public
	   * @aka toString
	   * @param {string=} delimiter The separator to insert between every element from
	   *     this sequence in the resulting string (defaults to `","`).
	   * @returns {string} The delimited string.
	   *
	   * @examples
	   * Lazy([6, 29, 1984]).join("/")  // => "6/29/1984"
	   * Lazy(["a", "b", "c"]).join()   // => "a,b,c"
	   * Lazy(["a", "b", "c"]).join("") // => "abc"
	   * Lazy([1, 2, 3]).join()         // => "1,2,3"
	   * Lazy([1, 2, 3]).join("")       // => "123"
	   * Lazy(["", "", ""]).join(",")   // => ",,"
	   */
	  Sequence.prototype.join = function join(delimiter) {
	    delimiter = typeof delimiter === "string" ? delimiter : ",";

	    return this.reduce(function(str, e, i) {
	      if (i > 0) {
	        str += delimiter;
	      }
	      return str + e;
	    }, "");
	  };

	  Sequence.prototype.toString = function toString(delimiter) {
	    return this.join(delimiter);
	  };

	  /**
	   * Creates a sequence, with the same elements as this one, that will be iterated
	   * over asynchronously when calling `each`.
	   *
	   * @public
	   * @param {number=} interval The approximate period, in milliseconds, that
	   *     should elapse between each element in the resulting sequence. Omitting
	   *     this argument will result in the fastest possible asynchronous iteration.
	   * @returns {AsyncSequence} The new asynchronous sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).async(100).each(fn) // calls fn 3 times asynchronously
	   */
	  Sequence.prototype.async = function async(interval) {
	    return new AsyncSequence(this, interval);
	  };

	  /**
	   * @constructor
	   */
	  function SimpleIntersectionSequence(parent, array) {
	    this.parent = parent;
	    this.array  = array;
	    this.each   = getEachForIntersection(array);
	  }

	  SimpleIntersectionSequence.prototype = new Sequence();

	  SimpleIntersectionSequence.prototype.eachMemoizerCache = function eachMemoizerCache(fn) {
	    var iterator = new UniqueMemoizer(Lazy(this.array).getIterator()),
	        i = 0;

	    return this.parent.each(function(e) {
	      if (iterator.contains(e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  SimpleIntersectionSequence.prototype.eachArrayCache = function eachArrayCache(fn) {
	    var array = this.array,
	        find  = arrayContains,
	        i = 0;

	    return this.parent.each(function(e) {
	      if (find(array, e)) {
	        return fn(e, i++);
	      }
	    });
	  };

	  function getEachForIntersection(source) {
	    if (source.length < 40) {
	      return SimpleIntersectionSequence.prototype.eachArrayCache;
	    } else {
	      return SimpleIntersectionSequence.prototype.eachMemoizerCache;
	    }
	  }

	  /**
	   * An optimized version of {@link ZippedSequence}, when zipping a sequence with
	   * only one array.
	   *
	   * @param {Sequence} parent The underlying sequence.
	   * @param {Array} array The array with which to zip the sequence.
	   * @constructor
	   */
	  function SimpleZippedSequence(parent, array) {
	    this.parent = parent;
	    this.array  = array;
	  }

	  SimpleZippedSequence.prototype = new Sequence();

	  SimpleZippedSequence.prototype.each = function each(fn) {
	    var array = this.array;
	    return this.parent.each(function(e, i) {
	      return fn([e, array[i]], i);
	    });
	  };

	  /**
	   * An `ArrayLikeSequence` is a {@link Sequence} that provides random access to
	   * its elements. This extends the API for iterating with the additional methods
	   * {@link #get} and {@link #length}, allowing a sequence to act as a "view" into
	   * a collection or other indexed data source.
	   *
	   * The initial sequence created by wrapping an array with `Lazy(array)` is an
	   * `ArrayLikeSequence`.
	   *
	   * All methods of `ArrayLikeSequence` that conceptually should return
	   * something like a array (with indexed access) return another
	   * `ArrayLikeSequence`, for example:
	   *
	   * - {@link Sequence#map}
	   * - {@link ArrayLikeSequence#slice}
	   * - {@link Sequence#take} and {@link Sequence#drop}
	   * - {@link Sequence#reverse}
	   *
	   * The above is not an exhaustive list. There are also certain other cases
	   * where it might be possible to return an `ArrayLikeSequence` (e.g., calling
	   * {@link Sequence#concat} with a single array argument), but this is not
	   * guaranteed by the API.
	   *
	   * Note that in many cases, it is not possible to provide indexed access
	   * without first performing at least a partial iteration of the underlying
	   * sequence. In these cases an `ArrayLikeSequence` will not be returned:
	   *
	   * - {@link Sequence#filter}
	   * - {@link Sequence#uniq}
	   * - {@link Sequence#union}
	   * - {@link Sequence#intersect}
	   *
	   * etc. The above methods only return ordinary {@link Sequence} objects.
	   *
	   * Defining custom array-like sequences
	   * ------------------------------------
	   *
	   * Creating a custom `ArrayLikeSequence` is essentially the same as creating a
	   * custom {@link Sequence}. You just have a couple more methods you need to
	   * implement: `get` and (optionally) `length`.
	   *
	   * Here's an example. Let's define a sequence type called `OffsetSequence` that
	   * offsets each of its parent's elements by a set distance, and circles back to
	   * the beginning after reaching the end. **Remember**: the initialization
	   * function you pass to {@link #define} should always accept a `parent` as its
	   * first parameter.
	   *
	   *     ArrayLikeSequence.define("offset", {
	   *       init: function(parent, offset) {
	   *         this.offset = offset;
	   *       },
	   *
	   *       get: function(i) {
	   *         return this.parent.get((i + this.offset) % this.parent.length());
	   *       }
	   *     });
	   *
	   * It's worth noting a couple of things here.
	   *
	   * First, Lazy's default implementation of `length` simply returns the parent's
	   * length. In this case, since an `OffsetSequence` will always have the same
	   * number of elements as its parent, that implementation is fine; so we don't
	   * need to override it.
	   *
	   * Second, the default implementation of `each` uses `get` and `length` to
	   * essentially create a `for` loop, which is fine here. If you want to implement
	   * `each` your own way, you can do that; but in most cases (as here), you can
	   * probably just stick with the default.
	   *
	   * So we're already done, after only implementing `get`! Pretty easy, huh?
	   *
	   * Now the `offset` method will be chainable from any `ArrayLikeSequence`. So
	   * for example:
	   *
	   *     Lazy([1, 2, 3]).map(mapFn).offset(3);
	   *
	   * ...will work, but:
	   *
	   *     Lazy([1, 2, 3]).filter(mapFn).offset(3);
	   *
	   * ...will not (because `filter` does not return an `ArrayLikeSequence`).
	   *
	   * (Also, as with the example provided for defining custom {@link Sequence}
	   * types, this example really could have been implemented using a function
	   * already available as part of Lazy.js: in this case, {@link Sequence#map}.)
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * Lazy([1, 2, 3])                    // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).take(2)            // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).drop(2)            // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).reverse()          // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2, 3]).slice(1, 2)        // instanceof Lazy.ArrayLikeSequence
	   */
	  function ArrayLikeSequence() {}

	  ArrayLikeSequence.prototype = new Sequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `ArrayLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `ArrayLikeSequence` prototype so that it can be chained with any other
	   *     methods that return array-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include `get`. *May* include `init`,
	   *     `length`, `getIterator`, and `each`. For each function, `this` will be
	   *     the new sequence and `this.parent` will be the source sequence.
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `ArrayLikeSequence`.
	   *
	   * @examples
	   * Lazy.ArrayLikeSequence.define("offset", {
	   *   init: function(offset) {
	   *     this.offset = offset;
	   *   },
	   *
	   *   get: function(i) {
	   *     return this.parent.get((i + this.offset) % this.parent.length());
	   *   }
	   * });
	   *
	   * Lazy([1, 2, 3]).offset(1) // sequence: [2, 3, 1]
	   */
	  ArrayLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.get !== 'function') {
	      throw new Error("A custom array-like sequence must implement *at least* get!");
	    }

	    return defineSequenceType(ArrayLikeSequence, methodName, overrides);
	  };

	  /**
	   * Returns the element at the specified index.
	   *
	   * @public
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   *
	   * @examples
	   * function increment(x) { return x + 1; }
	   *
	   * Lazy([1, 2, 3]).get(1)                // => 2
	   * Lazy([1, 2, 3]).get(-1)               // => undefined
	   * Lazy([1, 2, 3]).map(increment).get(1) // => 3
	   */
	  ArrayLikeSequence.prototype.get = function get(i) {
	    return this.parent.get(i);
	  };

	  /**
	   * Returns the length of the sequence.
	   *
	   * @public
	   * @returns {number} The length.
	   *
	   * @examples
	   * function increment(x) { return x + 1; }
	   *
	   * Lazy([]).length()                       // => 0
	   * Lazy([1, 2, 3]).length()                // => 3
	   * Lazy([1, 2, 3]).map(increment).length() // => 3
	   */
	  ArrayLikeSequence.prototype.length = function length() {
	    return this.parent.length();
	  };

	  /**
	   * Returns the current sequence (since it is already indexed).
	   */
	  ArrayLikeSequence.prototype.getIndex = function getIndex() {
	    return this;
	  };

	  /**
	   * An optimized version of {@link Sequence#getIterator}.
	   */
	  ArrayLikeSequence.prototype.getIterator = function getIterator() {
	    return new IndexedIterator(this);
	  };

	  /**
	   * An optimized version of {@link Iterator} meant to work with already-indexed
	   * sequences.
	   *
	   * @param {ArrayLikeSequence} sequence The sequence to iterate over.
	   * @constructor
	   */
	  function IndexedIterator(sequence) {
	    this.sequence = sequence;
	    this.index    = -1;
	  }

	  IndexedIterator.prototype.current = function current() {
	    return this.sequence.get(this.index);
	  };

	  IndexedIterator.prototype.moveNext = function moveNext() {
	    if (this.index >= this.sequence.length() - 1) {
	      return false;
	    }

	    ++this.index;
	    return true;
	  };

	  /**
	   * An optimized version of {@link Sequence#each}.
	   */
	  ArrayLikeSequence.prototype.each = function each(fn) {
	    var length = this.length(),
	        i = -1;

	    while (++i < length) {
	      if (fn(this.get(i), i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * Returns a new sequence with the same elements as this one, minus the last
	   * element.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).pop() // sequence: [1, 2]
	   * Lazy([]).pop()        // sequence: []
	   */
	  ArrayLikeSequence.prototype.pop = function pop() {
	    return this.initial();
	  };

	  /**
	   * Returns a new sequence with the same elements as this one, minus the first
	   * element.
	   *
	   * @public
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3]).shift() // sequence: [2, 3]
	   * Lazy([]).shift()        // sequence: []
	   */
	  ArrayLikeSequence.prototype.shift = function shift() {
	    return this.drop();
	  };

	  /**
	   * Returns a new sequence comprising the portion of this sequence starting
	   * from the specified starting index and continuing until the specified ending
	   * index or to the end of the sequence.
	   *
	   * @public
	   * @param {number} begin The index at which the new sequence should start.
	   * @param {number=} end The index at which the new sequence should end.
	   * @returns {ArrayLikeSequence} The new array-like sequence.
	   *
	   * @examples
	   * Lazy([1, 2, 3, 4, 5]).slice(0)     // sequence: [1, 2, 3, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).slice(2)     // sequence: [3, 4, 5]
	   * Lazy([1, 2, 3, 4, 5]).slice(2, 4)  // sequence: [3, 4]
	   * Lazy([1, 2, 3, 4, 5]).slice(-1)    // sequence: [5]
	   * Lazy([1, 2, 3, 4, 5]).slice(1, -1) // sequence: [2, 3, 4]
	   * Lazy([1, 2, 3, 4, 5]).slice(0, 10) // sequence: [1, 2, 3, 4, 5]
	   */
	  ArrayLikeSequence.prototype.slice = function slice(begin, end) {
	    var length = this.length();

	    if (begin < 0) {
	      begin = length + begin;
	    }

	    var result = this.drop(begin);

	    if (typeof end === "number") {
	      if (end < 0) {
	        end = length + end;
	      }
	      result = result.take(end - begin);
	    }

	    return result;
	  };

	  /**
	   * An optimized version of {@link Sequence#map}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.map = function map(mapFn) {
	    return new IndexedMappedSequence(this, createCallback(mapFn));
	  };

	  /**
	   * @constructor
	   */
	  function IndexedMappedSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  IndexedMappedSequence.prototype = new ArrayLikeSequence();

	  IndexedMappedSequence.prototype.get = function get(i) {
	    if (i < 0 || i >= this.parent.length()) {
	      return undefined;
	    }

	    return this.mapFn(this.parent.get(i), i);
	  };

	  /**
	   * An optimized version of {@link Sequence#filter}.
	   */
	  ArrayLikeSequence.prototype.filter = function filter(filterFn) {
	    return new IndexedFilteredSequence(this, createCallback(filterFn));
	  };

	  /**
	   * @constructor
	   */
	  function IndexedFilteredSequence(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  IndexedFilteredSequence.prototype = new FilteredSequence();

	  IndexedFilteredSequence.prototype.each = function each(fn) {
	    var parent = this.parent,
	        filterFn = this.filterFn,
	        length = this.parent.length(),
	        i = -1,
	        j = 0,
	        e;

	    while (++i < length) {
	      e = parent.get(i);
	      if (filterFn(e, i) && fn(e, j++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * An optimized version of {@link Sequence#reverse}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).reverse() // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.reverse = function reverse() {
	    return new IndexedReversedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedReversedSequence(parent) {
	    this.parent = parent;
	  }

	  IndexedReversedSequence.prototype = new ArrayLikeSequence();

	  IndexedReversedSequence.prototype.get = function get(i) {
	    return this.parent.get(this.length() - i - 1);
	  };

	  /**
	   * An optimized version of {@link Sequence#first}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).first(2) // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return this.get(0);
	    }

	    return new IndexedTakeSequence(this, count);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedTakeSequence(parent, count) {
	    this.parent = parent;
	    this.count  = count;
	  }

	  IndexedTakeSequence.prototype = new ArrayLikeSequence();

	  IndexedTakeSequence.prototype.length = function length() {
	    var parentLength = this.parent.length();
	    return this.count <= parentLength ? this.count : parentLength;
	  };

	  /**
	   * An optimized version of {@link Sequence#rest}, which creates an
	   * {@link ArrayLikeSequence} so that the result still provides random access.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy([1, 2, 3]).rest() // instanceof Lazy.ArrayLikeSequence
	   */
	  ArrayLikeSequence.prototype.rest = function rest(count) {
	    return new IndexedDropSequence(this, count);
	  };

	  /**
	   * @constructor
	   */
	  function IndexedDropSequence(parent, count) {
	    this.parent = parent;
	    this.count  = typeof count === "number" ? count : 1;
	  }

	  IndexedDropSequence.prototype = new ArrayLikeSequence();

	  IndexedDropSequence.prototype.get = function get(i) {
	    return this.parent.get(this.count + i);
	  };

	  IndexedDropSequence.prototype.length = function length() {
	    var parentLength = this.parent.length();
	    return this.count <= parentLength ? parentLength - this.count : 0;
	  };

	  /**
	   * An optimized version of {@link Sequence#concat} that returns another
	   * {@link ArrayLikeSequence} *if* the argument is an array.
	   *
	   * @public
	   * @param {...*} var_args
	   *
	   * @examples
	   * Lazy([1, 2]).concat([3, 4]) // instanceof Lazy.ArrayLikeSequence
	   * Lazy([1, 2]).concat([3, 4]) // sequence: [1, 2, 3, 4]
	   */
	  ArrayLikeSequence.prototype.concat = function concat(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new IndexedConcatenatedSequence(this, (/** @type {Array} */ var_args));
	    } else {
	      return Sequence.prototype.concat.apply(this, arguments);
	    }
	  };

	  /**
	   * @constructor
	   */
	  function IndexedConcatenatedSequence(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  IndexedConcatenatedSequence.prototype = new ArrayLikeSequence();

	  IndexedConcatenatedSequence.prototype.get = function get(i) {
	    var parentLength = this.parent.length();
	    if (i < parentLength) {
	      return this.parent.get(i);
	    } else {
	      return this.other[i - parentLength];
	    }
	  };

	  IndexedConcatenatedSequence.prototype.length = function length() {
	    return this.parent.length() + this.other.length;
	  };

	  /**
	   * An optimized version of {@link Sequence#uniq}.
	   */
	  ArrayLikeSequence.prototype.uniq = function uniq(keyFn) {
	    return new IndexedUniqueSequence(this, createCallback(keyFn));
	  };

	  /**
	   * @param {ArrayLikeSequence} parent
	   * @constructor
	   */
	  function IndexedUniqueSequence(parent, keyFn) {
	    this.parent = parent;
	    this.each   = getEachForParent(parent);
	    this.keyFn  = keyFn;
	  }

	  IndexedUniqueSequence.prototype = new Sequence();

	  IndexedUniqueSequence.prototype.eachArrayCache = function eachArrayCache(fn) {
	    // Basically the same implementation as w/ the set, but using an array because
	    // it's cheaper for smaller sequences.
	    var parent = this.parent,
	        keyFn  = this.keyFn,
	        length = parent.length(),
	        cache  = [],
	        find   = arrayContains,
	        key, value,
	        i = -1,
	        j = 0;

	    while (++i < length) {
	      value = parent.get(i);
	      key = keyFn(value);
	      if (!find(cache, key)) {
	        cache.push(key);
	        if (fn(value, j++) === false) {
	          return false;
	        }
	      }
	    }
	  };

	  IndexedUniqueSequence.prototype.eachSetCache = UniqueSequence.prototype.each;

	  function getEachForParent(parent) {
	    if (parent.length() < 100) {
	      return IndexedUniqueSequence.prototype.eachArrayCache;
	    } else {
	      return UniqueSequence.prototype.each;
	    }
	  }

	  // Now that we've fully initialized the ArrayLikeSequence prototype, we can
	  // set the prototype for MemoizedSequence.

	  MemoizedSequence.prototype = new ArrayLikeSequence();

	  MemoizedSequence.prototype.cache = function cache() {
	    return this.cachedResult || (this.cachedResult = this.parent.toArray());
	  };

	  MemoizedSequence.prototype.get = function get(i) {
	    return this.cache()[i];
	  };

	  MemoizedSequence.prototype.length = function length() {
	    return this.cache().length;
	  };

	  MemoizedSequence.prototype.slice = function slice(begin, end) {
	    return this.cache().slice(begin, end);
	  };

	  MemoizedSequence.prototype.toArray = function toArray() {
	    return this.cache().slice(0);
	  };

	  /**
	   * ArrayWrapper is the most basic {@link Sequence}. It directly wraps an array
	   * and implements the same methods as {@link ArrayLikeSequence}, but more
	   * efficiently.
	   *
	   * @constructor
	   */
	  function ArrayWrapper(source) {
	    this.source = source;
	  }

	  ArrayWrapper.prototype = new ArrayLikeSequence();

	  ArrayWrapper.prototype.root = function root() {
	    return this;
	  };

	  ArrayWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  /**
	   * Returns the element at the specified index in the source array.
	   *
	   * @param {number} i The index to access.
	   * @returns {*} The element.
	   */
	  ArrayWrapper.prototype.get = function get(i) {
	    return this.source[i];
	  };

	  /**
	   * Returns the length of the source array.
	   *
	   * @returns {number} The length.
	   */
	  ArrayWrapper.prototype.length = function length() {
	    return this.source.length;
	  };

	  /**
	   * An optimized version of {@link Sequence#each}.
	   */
	  ArrayWrapper.prototype.each = function each(fn) {
	    return forEach(this.source, fn);
	  };

	  /**
	   * An optimized version of {@link Sequence#map}.
	   */
	  ArrayWrapper.prototype.map = function map(mapFn) {
	    return new MappedArrayWrapper(this, createCallback(mapFn));
	  };

	  /**
	   * An optimized version of {@link Sequence#filter}.
	   */
	  ArrayWrapper.prototype.filter = function filter(filterFn) {
	    return new FilteredArrayWrapper(this, createCallback(filterFn));
	  };

	  /**
	   * An optimized version of {@link Sequence#uniq}.
	   */
	  ArrayWrapper.prototype.uniq = function uniq(keyFn) {
	    return new UniqueArrayWrapper(this, keyFn);
	  };

	  /**
	   * An optimized version of {@link ArrayLikeSequence#concat}.
	   *
	   * @param {...*} var_args
	   */
	  ArrayWrapper.prototype.concat = function concat(var_args) {
	    if (arguments.length === 1 && arguments[0] instanceof Array) {
	      return new ConcatArrayWrapper(this, (/** @type {Array} */ var_args));
	    } else {
	      return ArrayLikeSequence.prototype.concat.apply(this, arguments);
	    }
	  };

	  /**
	   * An optimized version of {@link Sequence#toArray}.
	   */
	  ArrayWrapper.prototype.toArray = function toArray() {
	    return this.source.slice(0);
	  };

	  /**
	   * @constructor
	   */
	  function MappedArrayWrapper(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedArrayWrapper.prototype = new ArrayLikeSequence();

	  MappedArrayWrapper.prototype.get = function get(i) {
	    var source = this.parent.source;

	    if (i < 0 || i >= source.length) {
	      return undefined;
	    }

	    return this.mapFn(source[i]);
	  };

	  MappedArrayWrapper.prototype.length = function length() {
	    return this.parent.source.length;
	  };

	  MappedArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        length = source.length,
	        mapFn  = this.mapFn,
	        i = -1;

	    while (++i < length) {
	      if (fn(mapFn(source[i], i), i) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * @constructor
	   */
	  function FilteredArrayWrapper(parent, filterFn) {
	    this.parent   = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredArrayWrapper.prototype = new FilteredSequence();

	  FilteredArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        filterFn = this.filterFn,
	        length = source.length,
	        i = -1,
	        j = 0,
	        e;

	    while (++i < length) {
	      e = source[i];
	      if (filterFn(e, i) && fn(e, j++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * @constructor
	   */
	  function UniqueArrayWrapper(parent, keyFn) {
	    this.parent = parent;
	    this.each   = getEachForSource(parent.source);
	    this.keyFn  = keyFn;
	  }

	  UniqueArrayWrapper.prototype = new Sequence();

	  UniqueArrayWrapper.prototype.eachNoCache = function eachNoCache(fn) {
	    var source = this.parent.source,
	        keyFn  = this.keyFn,
	        length = source.length,
	        find   = arrayContainsBefore,
	        value,

	        // Yes, this is hideous.
	        // Trying to get performance first, will refactor next!
	        i = -1,
	        k = 0;

	    while (++i < length) {
	      value = source[i];
	      if (!find(source, value, i, keyFn) && fn(value, k++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  UniqueArrayWrapper.prototype.eachArrayCache = function eachArrayCache(fn) {
	    // Basically the same implementation as w/ the set, but using an array because
	    // it's cheaper for smaller sequences.
	    var source = this.parent.source,
	        keyFn  = this.keyFn,
	        length = source.length,
	        cache  = [],
	        find   = arrayContains,
	        key, value,
	        i = -1,
	        j = 0;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      while (++i < length) {
	        value = source[i];
	        key = keyFn(value);
	        if (!find(cache, key)) {
	          cache.push(key);
	          if (fn(value, j++) === false) {
	            return false;
	          }
	        }
	      }

	    } else {
	      while (++i < length) {
	        value = source[i];
	        if (!find(cache, value)) {
	          cache.push(value);
	          if (fn(value, j++) === false) {
	            return false;
	          }
	        }
	      }
	    }

	    return true;
	  };

	  UniqueArrayWrapper.prototype.eachSetCache = UniqueSequence.prototype.each;

	  /**
	   * My latest findings here...
	   *
	   * So I hadn't really given the set-based approach enough credit. The main issue
	   * was that my Set implementation was totally not optimized at all. After pretty
	   * heavily optimizing it (just take a look; it's a monstrosity now!), it now
	   * becomes the fastest option for much smaller values of N.
	   */
	  function getEachForSource(source) {
	    if (source.length < 40) {
	      return UniqueArrayWrapper.prototype.eachNoCache;
	    } else if (source.length < 100) {
	      return UniqueArrayWrapper.prototype.eachArrayCache;
	    } else {
	      return UniqueArrayWrapper.prototype.eachSetCache;
	    }
	  }

	  /**
	   * @constructor
	   */
	  function ConcatArrayWrapper(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  ConcatArrayWrapper.prototype = new ArrayLikeSequence();

	  ConcatArrayWrapper.prototype.get = function get(i) {
	    var source = this.parent.source,
	        sourceLength = source.length;

	    if (i < sourceLength) {
	      return source[i];
	    } else {
	      return this.other[i - sourceLength];
	    }
	  };

	  ConcatArrayWrapper.prototype.length = function length() {
	    return this.parent.source.length + this.other.length;
	  };

	  ConcatArrayWrapper.prototype.each = function each(fn) {
	    var source = this.parent.source,
	        sourceLength = source.length,
	        other = this.other,
	        otherLength = other.length,
	        i = 0,
	        j = -1;

	    while (++j < sourceLength) {
	      if (fn(source[j], i++) === false) {
	        return false;
	      }
	    }

	    j = -1;
	    while (++j < otherLength) {
	      if (fn(other[j], i++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * An `ObjectLikeSequence` object represents a sequence of key/value pairs.
	   *
	   * The initial sequence you get by wrapping an object with `Lazy(object)` is
	   * an `ObjectLikeSequence`.
	   *
	   * All methods of `ObjectLikeSequence` that conceptually should return
	   * something like an object return another `ObjectLikeSequence`.
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * var obj = { foo: 'bar' };
	   *
	   * Lazy(obj).assign({ bar: 'baz' })   // instanceof Lazy.ObjectLikeSequence
	   * Lazy(obj).defaults({ bar: 'baz' }) // instanceof Lazy.ObjectLikeSequence
	   * Lazy(obj).invert()                 // instanceof Lazy.ObjectLikeSequence
	   */
	  function ObjectLikeSequence() {}

	  ObjectLikeSequence.prototype = new Sequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `ObjectLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `ObjectLikeSequence` prototype so that it can be chained with any other
	   *     methods that return object-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. **Must** include `each`. *May* include `init` and
	   *     `get` (for looking up an element by key).
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `ObjectLikeSequence`.
	   *
	   * @examples
	   * function downcaseKey(value, key) {
	   *   return [key.toLowerCase(), value];
	   * }
	   *
	   * Lazy.ObjectLikeSequence.define("caseInsensitive", {
	   *   init: function() {
	   *     var downcased = this.parent
	   *       .map(downcaseKey)
	   *       .toObject();
	   *     this.downcased = Lazy(downcased);
	   *   },
	   *
	   *   get: function(key) {
	   *     return this.downcased.get(key.toLowerCase());
	   *   },
	   *
	   *   each: function(fn) {
	   *     return this.downcased.each(fn);
	   *   }
	   * });
	   *
	   * Lazy({ Foo: 'bar' }).caseInsensitive()            // sequence: { foo: 'bar' }
	   * Lazy({ FOO: 'bar' }).caseInsensitive().get('foo') // => 'bar'
	   * Lazy({ FOO: 'bar' }).caseInsensitive().get('FOO') // => 'bar'
	   */
	  ObjectLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.each !== 'function') {
	      throw new Error("A custom object-like sequence must implement *at least* each!");
	    }

	    return defineSequenceType(ObjectLikeSequence, methodName, overrides);
	  };

	  ObjectLikeSequence.prototype.value = function value() {
	    return this.toObject();
	  };

	  /**
	   * Gets the element at the specified key in this sequence.
	   *
	   * @public
	   * @param {string} key The key.
	   * @returns {*} The element.
	   *
	   * @examples
	   * Lazy({ foo: "bar" }).get("foo")                          // => "bar"
	   * Lazy({ foo: "bar" }).extend({ foo: "baz" }).get("foo")   // => "baz"
	   * Lazy({ foo: "bar" }).defaults({ bar: "baz" }).get("bar") // => "baz"
	   * Lazy({ foo: "bar" }).invert().get("bar")                 // => "foo"
	   * Lazy({ foo: 1, bar: 2 }).pick(["foo"]).get("foo")        // => 1
	   * Lazy({ foo: 1, bar: 2 }).pick(["foo"]).get("bar")        // => undefined
	   * Lazy({ foo: 1, bar: 2 }).omit(["foo"]).get("bar")        // => 2
	   * Lazy({ foo: 1, bar: 2 }).omit(["foo"]).get("foo")        // => undefined
	   */
	  ObjectLikeSequence.prototype.get = function get(key) {
	    var pair = this.pairs().find(function(pair) {
	      return pair[0] === key;
	    });

	    return pair ? pair[1] : undefined;
	  };

	  /**
	   * Returns a {@link Sequence} whose elements are the keys of this object-like
	   * sequence.
	   *
	   * @public
	   * @returns {Sequence} The sequence based on this sequence's keys.
	   *
	   * @examples
	   * Lazy({ hello: "hola", goodbye: "hasta luego" }).keys() // sequence: ["hello", "goodbye"]
	   */
	  ObjectLikeSequence.prototype.keys = function keys() {
	    return this.map(function(v, k) { return k; });
	  };

	  /**
	   * Returns a {@link Sequence} whose elements are the values of this object-like
	   * sequence.
	   *
	   * @public
	   * @returns {Sequence} The sequence based on this sequence's values.
	   *
	   * @examples
	   * Lazy({ hello: "hola", goodbye: "hasta luego" }).values() // sequence: ["hola", "hasta luego"]
	   */
	  ObjectLikeSequence.prototype.values = function values() {
	    return this.map(function(v, k) { return v; });
	  };

	  /**
	   * Throws an exception. Asynchronous iteration over object-like sequences is
	   * not supported.
	   *
	   * @public
	   * @examples
	   * Lazy({ foo: 'bar' }).async() // throws
	   */
	  ObjectLikeSequence.prototype.async = function async() {
	    throw new Error('An ObjectLikeSequence does not support asynchronous iteration.');
	  };

	  ObjectLikeSequence.prototype.filter = function filter(filterFn) {
	    return new FilteredObjectLikeSequence(this, createCallback(filterFn));
	  };

	  function FilteredObjectLikeSequence(parent, filterFn) {
	    this.parent = parent;
	    this.filterFn = filterFn;
	  }

	  FilteredObjectLikeSequence.prototype = new ObjectLikeSequence();

	  FilteredObjectLikeSequence.prototype.each = function each(fn) {
	    var filterFn = this.filterFn;

	    return this.parent.each(function(v, k) {
	      if (filterFn(v, k)) {
	        return fn(v, k);
	      }
	    });
	  };

	  /**
	   * Returns this same sequence. (Reversing an object-like sequence doesn't make
	   * any sense.)
	   */
	  ObjectLikeSequence.prototype.reverse = function reverse() {
	    return this;
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose elements are the combination of
	   * this sequence and another object. In the case of a key appearing in both this
	   * sequence and the given object, the other object's value will override the
	   * one in this sequence.
	   *
	   * @public
	   * @aka extend
	   * @param {Object} other The other object to assign to this sequence.
	   * @returns {ObjectLikeSequence} A new sequence comprising elements from this
	   *     sequence plus the contents of `other`.
	   *
	   * @examples
	   * Lazy({ "uno": 1, "dos": 2 }).assign({ "tres": 3 }) // sequence: { uno: 1, dos: 2, tres: 3 }
	   * Lazy({ foo: "bar" }).assign({ foo: "baz" });       // sequence: { foo: "baz" }
	   */
	  ObjectLikeSequence.prototype.assign = function assign(other) {
	    return new AssignSequence(this, other);
	  };

	  ObjectLikeSequence.prototype.extend = function extend(other) {
	    return this.assign(other);
	  };

	  /**
	   * @constructor
	   */
	  function AssignSequence(parent, other) {
	    this.parent = parent;
	    this.other  = other;
	  }

	  AssignSequence.prototype = new ObjectLikeSequence();

	  AssignSequence.prototype.get = function get(key) {
	    return this.other[key] || this.parent.get(key);
	  };

	  AssignSequence.prototype.each = function each(fn) {
	    var merged = new Set(),
	        done   = false;

	    Lazy(this.other).each(function(value, key) {
	      if (fn(value, key) === false) {
	        done = true;
	        return false;
	      }

	      merged.add(key);
	    });

	    if (!done) {
	      return this.parent.each(function(value, key) {
	        if (!merged.contains(key) && fn(value, key) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose elements are the combination of
	   * this sequence and a 'default' object. In the case of a key appearing in both
	   * this sequence and the given object, this sequence's value will override the
	   * default object's.
	   *
	   * @public
	   * @param {Object} defaults The 'default' object to use for missing keys in this
	   *     sequence.
	   * @returns {ObjectLikeSequence} A new sequence comprising elements from this
	   *     sequence supplemented by the contents of `defaults`.
	   *
	   * @examples
	   * Lazy({ name: "Dan" }).defaults({ name: "User", password: "passw0rd" }) // sequence: { name: "Dan", password: "passw0rd" }
	   */
	  ObjectLikeSequence.prototype.defaults = function defaults(defaults) {
	    return new DefaultsSequence(this, defaults);
	  };

	  /**
	   * @constructor
	   */
	  function DefaultsSequence(parent, defaults) {
	    this.parent   = parent;
	    this.defaults = defaults;
	  }

	  DefaultsSequence.prototype = new ObjectLikeSequence();

	  DefaultsSequence.prototype.get = function get(key) {
	    return this.parent.get(key) || this.defaults[key];
	  };

	  DefaultsSequence.prototype.each = function each(fn) {
	    var merged = new Set(),
	        done   = false;

	    this.parent.each(function(value, key) {
	      if (fn(value, key) === false) {
	        done = true;
	        return false;
	      }

	      if (typeof value !== "undefined") {
	        merged.add(key);
	      }
	    });

	    if (!done) {
	      Lazy(this.defaults).each(function(value, key) {
	        if (!merged.contains(key) && fn(value, key) === false) {
	          return false;
	        }
	      });
	    }
	  };

	  /**
	   * Returns an {@link ObjectLikeSequence} whose values are this sequence's keys,
	   * and whose keys are this sequence's values.
	   *
	   * @public
	   * @returns {ObjectLikeSequence} A new sequence comprising the inverted keys and
	   *     values from this sequence.
	   *
	   * @examples
	   * Lazy({ first: "Dan", last: "Tao" }).invert() // sequence: { Dan: "first", Tao: "last" }
	   */
	  ObjectLikeSequence.prototype.invert = function invert() {
	    return new InvertedSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function InvertedSequence(parent) {
	    this.parent = parent;
	  }

	  InvertedSequence.prototype = new ObjectLikeSequence();

	  InvertedSequence.prototype.each = function each(fn) {
	    this.parent.each(function(value, key) {
	      return fn(key, value);
	    });
	  };

	  /**
	   * Produces an {@link ObjectLikeSequence} consisting of all the recursively
	   * merged values from this and the given object(s) or sequence(s).
	   *
	   * Note that by default this method only merges "vanilla" objects (bags of
	   * key/value pairs), not arrays or any other custom object types. To customize
	   * how merging works, you can provide the mergeFn argument, e.g. to handling
	   * merging arrays, strings, or other types of objects.
	   *
	   * @public
	   * @param {...Object|ObjectLikeSequence} others The other object(s) or
	   *     sequence(s) whose values will be merged into this one.
	   * @param {Function=} mergeFn An optional function used to customize merging
	   *     behavior. The function should take two values as parameters and return
	   *     whatever the "merged" form of those values is. If the function returns
	   *     undefined then the new value will simply replace the old one in the
	   *     final result.
	   * @returns {ObjectLikeSequence} The new sequence consisting of merged values.
	   *
	   * @examples
	   * // These examples are completely stolen from Lo-Dash's documentation:
	   * // lodash.com/docs#merge
	   *
	   * var names = {
	   *   'characters': [
	   *     { 'name': 'barney' },
	   *     { 'name': 'fred' }
	   *   ]
	   * };
	   *
	   * var ages = {
	   *   'characters': [
	   *     { 'age': 36 },
	   *     { 'age': 40 }
	   *   ]
	   * };
	   *
	   * var food = {
	   *   'fruits': ['apple'],
	   *   'vegetables': ['beet']
	   * };
	   *
	   * var otherFood = {
	   *   'fruits': ['banana'],
	   *   'vegetables': ['carrot']
	   * };
	   *
	   * function mergeArrays(a, b) {
	   *   return Array.isArray(a) ? a.concat(b) : undefined;
	   * }
	   *
	   * Lazy(names).merge(ages); // => sequence: { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
	   * Lazy(food).merge(otherFood, mergeArrays); // => sequence: { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	   *
	   * // ----- Now for my own tests: -----
	   *
	   * // merges objects
	   * Lazy({ foo: 1 }).merge({ foo: 2 }); // => sequence: { foo: 2 }
	   * Lazy({ foo: 1 }).merge({ bar: 2 }); // => sequence: { foo: 1, bar: 2 }
	   *
	   * // goes deep
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { bar: 2 } }); // => sequence: { foo: { bar: 2 } }
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }
	   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }
	   *
	   * // gives precedence to later sources
	   * Lazy({ foo: 1 }).merge({ bar: 2 }, { bar: 3 }); // => sequence: { foo: 1, bar: 3 }
	   *
	   * // undefined gets passed over
	   * Lazy({ foo: 1 }).merge({ foo: undefined }); // => sequence: { foo: 1 }
	   *
	   * // null doesn't get passed over
	   * Lazy({ foo: 1 }).merge({ foo: null }); // => sequence: { foo: null }
	   *
	   * // array contents get merged as well
	   * Lazy({ foo: [{ bar: 1 }] }).merge({ foo: [{ baz: 2 }] }); // => sequence: { foo: [{ bar: 1, baz: 2}] }
	   */
	  ObjectLikeSequence.prototype.merge = function merge(var_args) {
	    var mergeFn = arguments.length > 1 && typeof arguments[arguments.length - 1] === "function" ?
	      arrayPop.call(arguments) : null;
	    return new MergedSequence(this, arraySlice.call(arguments, 0), mergeFn);
	  };

	  /**
	   * @constructor
	   */
	  function MergedSequence(parent, others, mergeFn) {
	    this.parent  = parent;
	    this.others  = others;
	    this.mergeFn = mergeFn;
	  }

	  MergedSequence.prototype = new ObjectLikeSequence();

	  MergedSequence.prototype.each = function each(fn) {
	    var others  = this.others,
	        mergeFn = this.mergeFn || mergeObjects,
	        keys    = {};

	    var iteratedFullSource = this.parent.each(function(value, key) {
	      var merged = value;

	      forEach(others, function(other) {
	        if (key in other) {
	          merged = mergeFn(merged, other[key]);
	        }
	      });

	      keys[key] = true;

	      return fn(merged, key);
	    });

	    if (iteratedFullSource === false) {
	      return false;
	    }

	    var remaining = {};

	    forEach(others, function(other) {
	      for (var k in other) {
	        if (!keys[k]) {
	          remaining[k] = mergeFn(remaining[k], other[k]);
	        }
	      }
	    });

	    return Lazy(remaining).each(fn);
	  };

	  /**
	   * @private
	   * @examples
	   * mergeObjects({ foo: 1 }, { bar: 2 }); // => { foo: 1, bar: 2 }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: { baz: 2 } }); // => { foo: { bar: 1, baz: 2 } }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: undefined }); // => { foo: { bar: 1 } }
	   * mergeObjects({ foo: { bar: 1 } }, { foo: null }); // => { foo: null }
	   * mergeObjects({ array: [0, 1, 2] }, { array: [3, 4, 5] }).array; // instanceof Array
	   * mergeObjects({ date: new Date() }, { date: new Date() }).date; // instanceof Date
	   * mergeObjects([{ foo: 1 }], [{ bar: 2 }]); // => [{ foo: 1, bar: 2 }]
	   */
	  function mergeObjects(a, b) {
	    var merged, prop;

	    if (typeof b === 'undefined') {
	      return a;
	    }

	    // Check that we're dealing with two objects or two arrays.
	    if (isVanillaObject(a) && isVanillaObject(b)) {
	      merged = {};
	    } else if (a instanceof Array && b instanceof Array) {
	      merged = [];
	    } else {
	      // Otherwise there's no merging to do -- just replace a w/ b.
	      return b;
	    }

	    for (prop in a) {
	      merged[prop] = mergeObjects(a[prop], b[prop]);
	    }
	    for (prop in b) {
	      if (!merged[prop]) {
	        merged[prop] = b[prop];
	      }
	    }
	    return merged;
	  }

	  /**
	   * Checks whether an object is a "vanilla" object, i.e. {'foo': 'bar'} as
	   * opposed to an array, date, etc.
	   *
	   * @private
	   * @examples
	   * isVanillaObject({foo: 'bar'}); // => true
	   * isVanillaObject(new Date());   // => false
	   * isVanillaObject([1, 2, 3]);    // => false
	   */
	  function isVanillaObject(object) {
	    return object && object.constructor === Object;
	  }

	  /**
	   * Creates a {@link Sequence} consisting of the keys from this sequence whose
	   *     values are functions.
	   *
	   * @public
	   * @aka methods
	   * @returns {Sequence} The new sequence.
	   *
	   * @examples
	   * var dog = {
	   *   name: "Fido",
	   *   breed: "Golden Retriever",
	   *   bark: function() { console.log("Woof!"); },
	   *   wagTail: function() { console.log("TODO: implement robotic dog interface"); }
	   * };
	   *
	   * Lazy(dog).functions() // sequence: ["bark", "wagTail"]
	   */
	  ObjectLikeSequence.prototype.functions = function functions() {
	    return this
	      .filter(function(v, k) { return typeof(v) === "function"; })
	      .map(function(v, k) { return k; });
	  };

	  ObjectLikeSequence.prototype.methods = function methods() {
	    return this.functions();
	  };

	  /**
	   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from
	   * this sequence whose keys are included in the given array of property names.
	   *
	   * @public
	   * @param {Array} properties An array of the properties to "pick" from this
	   *     sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * var players = {
	   *   "who": "first",
	   *   "what": "second",
	   *   "i don't know": "third"
	   * };
	   *
	   * Lazy(players).pick(["who", "what"]) // sequence: { who: "first", what: "second" }
	   */
	  ObjectLikeSequence.prototype.pick = function pick(properties) {
	    return new PickSequence(this, properties);
	  };

	  /**
	   * @constructor
	   */
	  function PickSequence(parent, properties) {
	    this.parent     = parent;
	    this.properties = properties;
	  }

	  PickSequence.prototype = new ObjectLikeSequence();

	  PickSequence.prototype.get = function get(key) {
	    return arrayContains(this.properties, key) ? this.parent.get(key) : undefined;
	  };

	  PickSequence.prototype.each = function each(fn) {
	    var inArray    = arrayContains,
	        properties = this.properties;

	    return this.parent.each(function(value, key) {
	      if (inArray(properties, key)) {
	        return fn(value, key);
	      }
	    });
	  };

	  /**
	   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from
	   * this sequence excluding those with the specified keys.
	   *
	   * @public
	   * @param {Array} properties An array of the properties to *omit* from this
	   *     sequence.
	   * @returns {ObjectLikeSequence} The new sequence.
	   *
	   * @examples
	   * var players = {
	   *   "who": "first",
	   *   "what": "second",
	   *   "i don't know": "third"
	   * };
	   *
	   * Lazy(players).omit(["who", "what"]) // sequence: { "i don't know": "third" }
	   */
	  ObjectLikeSequence.prototype.omit = function omit(properties) {
	    return new OmitSequence(this, properties);
	  };

	  /**
	   * @constructor
	   */
	  function OmitSequence(parent, properties) {
	    this.parent     = parent;
	    this.properties = properties;
	  }

	  OmitSequence.prototype = new ObjectLikeSequence();

	  OmitSequence.prototype.get = function get(key) {
	    return arrayContains(this.properties, key) ? undefined : this.parent.get(key);
	  };

	  OmitSequence.prototype.each = function each(fn) {
	    var inArray    = arrayContains,
	        properties = this.properties;

	    return this.parent.each(function(value, key) {
	      if (!inArray(properties, key)) {
	        return fn(value, key);
	      }
	    });
	  };

	  /**
	   * Maps the key/value pairs in this sequence to arrays.
	   *
	   * @public
	   * @aka toArray
	   * @returns {Sequence} An sequence of `[key, value]` pairs.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).pairs() // sequence: [["red", "#f00"], ["green", "#0f0"], ["blue", "#00f"]]
	   */
	  ObjectLikeSequence.prototype.pairs = function pairs() {
	    return this.map(function(v, k) { return [k, v]; });
	  };

	  /**
	   * Creates an array from the key/value pairs in this sequence.
	   *
	   * @public
	   * @returns {Array} An array of `[key, value]` elements.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).toArray() // => [["red", "#f00"], ["green", "#0f0"], ["blue", "#00f"]]
	   */
	  ObjectLikeSequence.prototype.toArray = function toArray() {
	    return this.pairs().toArray();
	  };

	  /**
	   * Creates an object with the key/value pairs from this sequence.
	   *
	   * @public
	   * @returns {Object} An object with the same key/value pairs as this sequence.
	   *
	   * @examples
	   * var colorCodes = {
	   *   red: "#f00",
	   *   green: "#0f0",
	   *   blue: "#00f"
	   * };
	   *
	   * Lazy(colorCodes).toObject() // => { red: "#f00", green: "#0f0", blue: "#00f" }
	   */
	  ObjectLikeSequence.prototype.toObject = function toObject() {
	    return this.reduce(function(object, value, key) {
	      object[key] = value;
	      return object;
	    }, {});
	  };

	  // Now that we've fully initialized the ObjectLikeSequence prototype, we can
	  // actually set the prototypes for GroupedSequence, IndexedSequence, and
	  // CountedSequence.

	  GroupedSequence.prototype = new ObjectLikeSequence();

	  GroupedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        valFn   = createCallback(this.valFn),
	        result;

	    result = this.parent.reduce(function(grouped,e) {
	      var key = keyFn(e),
	          val = valFn(e);
	      if (!(grouped[key] instanceof Array)) {
	        grouped[key] = [val];
	      } else {
	        grouped[key].push(val);
	      }
	      return grouped;
	    },{});

	    return transform(function(grouped) {
	      for (var key in grouped) {
	        if (fn(grouped[key], key) === false) {
	          return false;
	        }
	      }
	    }, result);
	  };

	  IndexedSequence.prototype = new ObjectLikeSequence();

	  IndexedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        valFn   = createCallback(this.valFn),
	        indexed = {};

	    return this.parent.each(function(e) {
	      var key = keyFn(e),
	          val = valFn(e);

	      if (!indexed[key]) {
	        indexed[key] = val;
	        return fn(val, key);
	      }
	    });
	  };

	  CountedSequence.prototype = new ObjectLikeSequence();

	  CountedSequence.prototype.each = function each(fn) {
	    var keyFn   = createCallback(this.keyFn),
	        counted = {};

	    this.parent.each(function(e) {
	      var key = keyFn(e);
	      if (!counted[key]) {
	        counted[key] = 1;
	      } else {
	        counted[key] += 1;
	      }
	    });

	    for (var key in counted) {
	      if (fn(counted[key], key) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * Watches for all changes to a specified property (or properties) of an
	   * object and produces a sequence whose elements have the properties
	   * `{ property, value }` indicating which property changed and what it was
	   * changed to.
	   *
	   * Note that this method **only works on directly wrapped objects**; it will
	   * *not* work on any arbitrary {@link ObjectLikeSequence}.
	   *
	   * @public
	   * @param {(string|Array)=} propertyNames A property name or array of property
	   *     names to watch. If this parameter is `undefined`, all of the object's
	   *     current (enumerable) properties will be watched.
	   * @returns {Sequence} A sequence comprising `{ property, value }` objects
	   *     describing each change to the specified property/properties.
	   *
	   * @examples
	   * var obj = {},
	   *     changes = [];
	   *
	   * Lazy(obj).watch('foo').each(function(change) {
	   *   changes.push(change);
	   * });
	   *
	   * obj.foo = 1;
	   * obj.bar = 2;
	   * obj.foo = 3;
	   *
	   * obj.foo; // => 3
	   * changes; // => [{ property: 'foo', value: 1 }, { property: 'foo', value: 3 }]
	   */
	  ObjectLikeSequence.prototype.watch = function watch(propertyNames) {
	    throw new Error('You can only call #watch on a directly wrapped object.');
	  };

	  /**
	   * @constructor
	   */
	  function ObjectWrapper(source) {
	    this.source = source;
	  }

	  ObjectWrapper.prototype = new ObjectLikeSequence();

	  ObjectWrapper.prototype.root = function root() {
	    return this;
	  };

	  ObjectWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  ObjectWrapper.prototype.get = function get(key) {
	    return this.source[key];
	  };

	  ObjectWrapper.prototype.each = function each(fn) {
	    var source = this.source,
	        key;

	    for (key in source) {
	      if (fn(source[key], key) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  /**
	   * A `StringLikeSequence` represents a sequence of characters.
	   *
	   * The initial sequence you get by wrapping a string with `Lazy(string)` is a
	   * `StringLikeSequence`.
	   *
	   * All methods of `StringLikeSequence` that conceptually should return
	   * something like a string return another `StringLikeSequence`.
	   *
	   * @public
	   * @constructor
	   *
	   * @examples
	   * function upcase(str) { return str.toUpperCase(); }
	   *
	   * Lazy('foo')               // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').toUpperCase() // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').reverse()     // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').take(2)       // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').drop(1)       // instanceof Lazy.StringLikeSequence
	   * Lazy('foo').substring(1)  // instanceof Lazy.StringLikeSequence
	   *
	   * // Note that `map` does not create a `StringLikeSequence` because there's
	   * // no guarantee the mapping function will return characters. In the event
	   * // you do want to map a string onto a string-like sequence, use
	   * // `mapString`:
	   * Lazy('foo').map(Lazy.identity)       // instanceof Lazy.ArrayLikeSequence
	   * Lazy('foo').mapString(Lazy.identity) // instanceof Lazy.StringLikeSequence
	   */
	  function StringLikeSequence() {}

	  StringLikeSequence.prototype = new ArrayLikeSequence();

	  /**
	   * Create a new constructor function for a type inheriting from
	   * `StringLikeSequence`.
	   *
	   * @public
	   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be
	   *     used for constructing the new sequence. The method will be attached to
	   *     the `StringLikeSequence` prototype so that it can be chained with any other
	   *     methods that return string-like sequences.
	   * @param {Object} overrides An object containing function overrides for this
	   *     new sequence type. Has the same requirements as
	   *     {@link ArrayLikeSequence.define}.
	   * @returns {Function} A constructor for a new type inheriting from
	   *     `StringLikeSequence`.
	   *
	   * @examples
	   * Lazy.StringLikeSequence.define("zomg", {
	   *   length: function() {
	   *     return this.parent.length() + "!!ZOMG!!!1".length;
	   *   },
	   *
	   *   get: function(i) {
	   *     if (i < this.parent.length()) {
	   *       return this.parent.get(i);
	   *     }
	   *     return "!!ZOMG!!!1".charAt(i - this.parent.length());
	   *   }
	   * });
	   *
	   * Lazy('foo').zomg() // sequence: "foo!!ZOMG!!!1"
	   */
	  StringLikeSequence.define = function define(methodName, overrides) {
	    if (!overrides || typeof overrides.get !== 'function') {
	      throw new Error("A custom string-like sequence must implement *at least* get!");
	    }

	    return defineSequenceType(StringLikeSequence, methodName, overrides);
	  };

	  StringLikeSequence.prototype.value = function value() {
	    return this.toString();
	  };

	  /**
	   * Returns an {@link IndexedIterator} that will step over each character in this
	   * sequence one by one.
	   *
	   * @returns {IndexedIterator} The iterator.
	   */
	  StringLikeSequence.prototype.getIterator = function getIterator() {
	    return new CharIterator(this);
	  };

	  /**
	   * @constructor
	   */
	  function CharIterator(source) {
	    this.source = Lazy(source);
	    this.index = -1;
	  }

	  CharIterator.prototype.current = function current() {
	    return this.source.charAt(this.index);
	  };

	  CharIterator.prototype.moveNext = function moveNext() {
	    return (++this.index < this.source.length());
	  };

	  /**
	   * Returns the character at the given index of this sequence, or the empty
	   * string if the specified index lies outside the bounds of the sequence.
	   *
	   * @public
	   * @param {number} i The index of this sequence.
	   * @returns {string} The character at the specified index.
	   *
	   * @examples
	   * Lazy("foo").charAt(0)  // => "f"
	   * Lazy("foo").charAt(-1) // => ""
	   * Lazy("foo").charAt(10) // => ""
	   */
	  StringLikeSequence.prototype.charAt = function charAt(i) {
	    return this.get(i);
	  };

	  /**
	   * Returns the character code at the given index of this sequence, or `NaN` if
	   * the index lies outside the bounds of the sequence.
	   *
	   * @public
	   * @param {number} i The index of the character whose character code you want.
	   * @returns {number} The character code.
	   *
	   * @examples
	   * Lazy("abc").charCodeAt(0)  // => 97
	   * Lazy("abc").charCodeAt(-1) // => NaN
	   * Lazy("abc").charCodeAt(10) // => NaN
	   */
	  StringLikeSequence.prototype.charCodeAt = function charCodeAt(i) {
	    var char = this.charAt(i);
	    if (!char) { return NaN; }

	    return char.charCodeAt(0);
	  };

	  /**
	   * Returns a {@link StringLikeSequence} comprising the characters from *this*
	   * sequence starting at `start` and ending at `stop` (exclusive), or---if
	   * `stop` is `undefined`, including the rest of the sequence.
	   *
	   * @public
	   * @param {number} start The index where this sequence should begin.
	   * @param {number=} stop The index (exclusive) where this sequence should end.
	   * @returns {StringLikeSequence} The new sequence.
	   *
	   * @examples
	   * Lazy("foo").substring(1)      // sequence: "oo"
	   * Lazy("foo").substring(-1)     // sequence: "foo"
	   * Lazy("hello").substring(1, 3) // sequence: "el"
	   * Lazy("hello").substring(1, 9) // sequence: "ello"
	   */
	  StringLikeSequence.prototype.substring = function substring(start, stop) {
	    return new StringSegment(this, start, stop);
	  };

	  /**
	   * @constructor
	   */
	  function StringSegment(parent, start, stop) {
	    this.parent = parent;
	    this.start  = Math.max(0, start);
	    this.stop   = stop;
	  }

	  StringSegment.prototype = new StringLikeSequence();

	  StringSegment.prototype.get = function get(i) {
	    return this.parent.get(i + this.start);
	  };

	  StringSegment.prototype.length = function length() {
	    return (typeof this.stop === "number" ? this.stop : this.parent.length()) - this.start;
	  };

	  /**
	   * An optimized version of {@link Sequence#first} that returns another
	   * {@link StringLikeSequence} (or just the first character, if `count` is
	   * undefined).
	   *
	   * @public
	   * @examples
	   * Lazy('foo').first()                // => 'f'
	   * Lazy('fo').first(2)                // sequence: 'fo'
	   * Lazy('foo').first(10)              // sequence: 'foo'
	   * Lazy('foo').toUpperCase().first()  // => 'F'
	   * Lazy('foo').toUpperCase().first(2) // sequence: 'FO'
	   */
	  StringLikeSequence.prototype.first = function first(count) {
	    if (typeof count === "undefined") {
	      return this.charAt(0);
	    }

	    return this.substring(0, count);
	  };

	  /**
	   * An optimized version of {@link Sequence#last} that returns another
	   * {@link StringLikeSequence} (or just the last character, if `count` is
	   * undefined).
	   *
	   * @public
	   * @examples
	   * Lazy('foo').last()                // => 'o'
	   * Lazy('foo').last(2)               // sequence: 'oo'
	   * Lazy('foo').last(10)              // sequence: 'foo'
	   * Lazy('foo').toUpperCase().last()  // => 'O'
	   * Lazy('foo').toUpperCase().last(2) // sequence: 'OO'
	   */
	  StringLikeSequence.prototype.last = function last(count) {
	    if (typeof count === "undefined") {
	      return this.charAt(this.length() - 1);
	    }

	    return this.substring(this.length() - count);
	  };

	  StringLikeSequence.prototype.drop = function drop(count) {
	    return this.substring(count);
	  };

	  /**
	   * Finds the index of the first occurrence of the given substring within this
	   * sequence, starting from the specified index (or the beginning of the
	   * sequence).
	   *
	   * @public
	   * @param {string} substring The substring to search for.
	   * @param {number=} startIndex The index from which to start the search.
	   * @returns {number} The first index where the given substring is found, or
	   *     -1 if it isn't in the sequence.
	   *
	   * @examples
	   * Lazy('canal').indexOf('a')    // => 1
	   * Lazy('canal').indexOf('a', 2) // => 3
	   * Lazy('canal').indexOf('ana')  // => 1
	   * Lazy('canal').indexOf('andy') // => -1
	   * Lazy('canal').indexOf('x')    // => -1
	   */
	  StringLikeSequence.prototype.indexOf = function indexOf(substring, startIndex) {
	    return this.toString().indexOf(substring, startIndex);
	  };

	  /**
	   * Finds the index of the last occurrence of the given substring within this
	   * sequence, starting from the specified index (or the end of the sequence)
	   * and working backwards.
	   *
	   * @public
	   * @param {string} substring The substring to search for.
	   * @param {number=} startIndex The index from which to start the search.
	   * @returns {number} The last index where the given substring is found, or
	   *     -1 if it isn't in the sequence.
	   *
	   * @examples
	   * Lazy('canal').lastIndexOf('a')    // => 3
	   * Lazy('canal').lastIndexOf('a', 2) // => 1
	   * Lazy('canal').lastIndexOf('ana')  // => 1
	   * Lazy('canal').lastIndexOf('andy') // => -1
	   * Lazy('canal').lastIndexOf('x')    // => -1
	   */
	  StringLikeSequence.prototype.lastIndexOf = function lastIndexOf(substring, startIndex) {
	    return this.toString().lastIndexOf(substring, startIndex);
	  };

	  /**
	   * Checks if this sequence contains a given substring.
	   *
	   * @public
	   * @param {string} substring The substring to check for.
	   * @returns {boolean} Whether or not this sequence contains `substring`.
	   *
	   * @examples
	   * Lazy('hello').contains('ell') // => true
	   * Lazy('hello').contains('')    // => true
	   * Lazy('hello').contains('abc') // => false
	   */
	  StringLikeSequence.prototype.contains = function contains(substring) {
	    return this.indexOf(substring) !== -1;
	  };

	  /**
	   * Checks if this sequence ends with a given suffix.
	   *
	   * @public
	   * @param {string} suffix The suffix to check for.
	   * @returns {boolean} Whether or not this sequence ends with `suffix`.
	   *
	   * @examples
	   * Lazy('foo').endsWith('oo')  // => true
	   * Lazy('foo').endsWith('')    // => true
	   * Lazy('foo').endsWith('abc') // => false
	   */
	  StringLikeSequence.prototype.endsWith = function endsWith(suffix) {
	    return this.substring(this.length() - suffix.length).toString() === suffix;
	  };

	  /**
	   * Checks if this sequence starts with a given prefix.
	   *
	   * @public
	   * @param {string} prefix The prefix to check for.
	   * @returns {boolean} Whether or not this sequence starts with `prefix`.
	   *
	   * @examples
	   * Lazy('foo').startsWith('fo')  // => true
	   * Lazy('foo').startsWith('')    // => true
	   * Lazy('foo').startsWith('abc') // => false
	   */
	  StringLikeSequence.prototype.startsWith = function startsWith(prefix) {
	    return this.substring(0, prefix.length).toString() === prefix;
	  };

	  /**
	   * Converts all of the characters in this string to uppercase.
	   *
	   * @public
	   * @returns {StringLikeSequence} A new sequence with the same characters as
	   *     this sequence, all uppercase.
	   *
	   * @examples
	   * function nextLetter(a) {
	   *   return String.fromCharCode(a.charCodeAt(0) + 1);
	   * }
	   *
	   * Lazy('foo').toUpperCase()                       // sequence: 'FOO'
	   * Lazy('foo').substring(1).toUpperCase()          // sequence: 'OO'
	   * Lazy('abc').mapString(nextLetter).toUpperCase() // sequence: 'BCD'
	   */
	  StringLikeSequence.prototype.toUpperCase = function toUpperCase() {
	    return this.mapString(function(char) { return char.toUpperCase(); });
	  };

	  /**
	   * Converts all of the characters in this string to lowercase.
	   *
	   * @public
	   * @returns {StringLikeSequence} A new sequence with the same characters as
	   *     this sequence, all lowercase.
	   *
	   * @examples
	   * function nextLetter(a) {
	   *   return String.fromCharCode(a.charCodeAt(0) + 1);
	   * }
	   *
	   * Lazy('FOO').toLowerCase()                       // sequence: 'foo'
	   * Lazy('FOO').substring(1).toLowerCase()          // sequence: 'oo'
	   * Lazy('ABC').mapString(nextLetter).toLowerCase() // sequence: 'bcd'
	   */
	  StringLikeSequence.prototype.toLowerCase = function toLowerCase() {
	    return this.mapString(function(char) { return char.toLowerCase(); });
	  };

	  /**
	   * Maps the characters of this sequence onto a new {@link StringLikeSequence}.
	   *
	   * @public
	   * @param {Function} mapFn The function used to map characters from this
	   *     sequence onto the new sequence.
	   * @returns {StringLikeSequence} The new sequence.
	   *
	   * @examples
	   * function upcase(char) { return char.toUpperCase(); }
	   *
	   * Lazy("foo").mapString(upcase)               // sequence: "FOO"
	   * Lazy("foo").mapString(upcase).charAt(0)     // => "F"
	   * Lazy("foo").mapString(upcase).charCodeAt(0) // => 70
	   * Lazy("foo").mapString(upcase).substring(1)  // sequence: "OO"
	   */
	  StringLikeSequence.prototype.mapString = function mapString(mapFn) {
	    return new MappedStringLikeSequence(this, mapFn);
	  };

	  /**
	   * @constructor
	   */
	  function MappedStringLikeSequence(parent, mapFn) {
	    this.parent = parent;
	    this.mapFn  = mapFn;
	  }

	  MappedStringLikeSequence.prototype = new StringLikeSequence();
	  MappedStringLikeSequence.prototype.get = IndexedMappedSequence.prototype.get;
	  MappedStringLikeSequence.prototype.length = IndexedMappedSequence.prototype.length;

	  /**
	   * Returns a copy of this sequence that reads back to front.
	   *
	   * @public
	   *
	   * @examples
	   * Lazy("abcdefg").reverse() // sequence: "gfedcba"
	   */
	  StringLikeSequence.prototype.reverse = function reverse() {
	    return new ReversedStringLikeSequence(this);
	  };

	  /**
	   * @constructor
	   */
	  function ReversedStringLikeSequence(parent) {
	    this.parent = parent;
	  }

	  ReversedStringLikeSequence.prototype = new StringLikeSequence();
	  ReversedStringLikeSequence.prototype.get = IndexedReversedSequence.prototype.get;
	  ReversedStringLikeSequence.prototype.length = IndexedReversedSequence.prototype.length;

	  StringLikeSequence.prototype.toString = function toString() {
	    return this.join("");
	  };

	  /**
	   * Creates a {@link Sequence} comprising all of the matches for the specified
	   * pattern in the underlying string.
	   *
	   * @public
	   * @param {RegExp} pattern The pattern to match.
	   * @returns {Sequence} A sequence of all the matches.
	   *
	   * @examples
	   * Lazy("abracadabra").match(/a[bcd]/) // sequence: ["ab", "ac", "ad", "ab"]
	   * Lazy("fee fi fo fum").match(/\w+/)  // sequence: ["fee", "fi", "fo", "fum"]
	   * Lazy("hello").match(/xyz/)          // sequence: []
	   */
	  StringLikeSequence.prototype.match = function match(pattern) {
	    return new StringMatchSequence(this, pattern);
	  };

	  /**
	   * @constructor
	   */
	  function StringMatchSequence(parent, pattern) {
	    this.parent = parent;
	    this.pattern = pattern;
	  }

	  StringMatchSequence.prototype = new Sequence();

	  StringMatchSequence.prototype.getIterator = function getIterator() {
	    return new StringMatchIterator(this.parent.toString(), this.pattern);
	  };

	  /**
	   * @constructor
	   */
	  function StringMatchIterator(source, pattern) {
	    this.source  = source;
	    this.pattern = cloneRegex(pattern);
	  }

	  StringMatchIterator.prototype.current = function current() {
	    return this.match[0];
	  };

	  StringMatchIterator.prototype.moveNext = function moveNext() {
	    return !!(this.match = this.pattern.exec(this.source));
	  };

	  /**
	   * Creates a {@link Sequence} comprising all of the substrings of this string
	   * separated by the given delimiter, which can be either a string or a regular
	   * expression.
	   *
	   * @public
	   * @param {string|RegExp} delimiter The delimiter to use for recognizing
	   *     substrings.
	   * @returns {Sequence} A sequence of all the substrings separated by the given
	   *     delimiter.
	   *
	   * @examples
	   * Lazy("foo").split("")                      // sequence: ["f", "o", "o"]
	   * Lazy("yo dawg").split(" ")                 // sequence: ["yo", "dawg"]
	   * Lazy("bah bah\tblack  sheep").split(/\s+/) // sequence: ["bah", "bah", "black", "sheep"]
	   */
	  StringLikeSequence.prototype.split = function split(delimiter) {
	    return new SplitStringSequence(this, delimiter);
	  };

	  /**
	   * @constructor
	   */
	  function SplitStringSequence(parent, pattern) {
	    this.parent = parent;
	    this.pattern = pattern;
	  }

	  SplitStringSequence.prototype = new Sequence();

	  SplitStringSequence.prototype.getIterator = function getIterator() {
	    var source = this.parent.toString();

	    if (this.pattern instanceof RegExp) {
	      if (this.pattern.source === "" || this.pattern.source === "(?:)") {
	        return new CharIterator(source);
	      } else {
	        return new SplitWithRegExpIterator(source, this.pattern);
	      }
	    } else if (this.pattern === "") {
	      return new CharIterator(source);
	    } else {
	      return new SplitWithStringIterator(source, this.pattern);
	    }
	  };

	  /**
	   * @constructor
	   */
	  function SplitWithRegExpIterator(source, pattern) {
	    this.source  = source;
	    this.pattern = cloneRegex(pattern);
	  }

	  SplitWithRegExpIterator.prototype.current = function current() {
	    return this.source.substring(this.start, this.end);
	  };

	  SplitWithRegExpIterator.prototype.moveNext = function moveNext() {
	    if (!this.pattern) {
	      return false;
	    }

	    var match = this.pattern.exec(this.source);

	    if (match) {
	      this.start = this.nextStart ? this.nextStart : 0;
	      this.end = match.index;
	      this.nextStart = match.index + match[0].length;
	      return true;

	    } else if (this.pattern) {
	      this.start = this.nextStart;
	      this.end = undefined;
	      this.nextStart = undefined;
	      this.pattern = undefined;
	      return true;
	    }

	    return false;
	  };

	  /**
	   * @constructor
	   */
	  function SplitWithStringIterator(source, delimiter) {
	    this.source = source;
	    this.delimiter = delimiter;
	  }

	  SplitWithStringIterator.prototype.current = function current() {
	    return this.source.substring(this.leftIndex, this.rightIndex);
	  };

	  SplitWithStringIterator.prototype.moveNext = function moveNext() {
	    if (!this.finished) {
	      this.leftIndex = typeof this.leftIndex !== "undefined" ?
	        this.rightIndex + this.delimiter.length :
	        0;
	      this.rightIndex = this.source.indexOf(this.delimiter, this.leftIndex);
	    }

	    if (this.rightIndex === -1) {
	      this.finished = true;
	      this.rightIndex = undefined;
	      return true;
	    }

	    return !this.finished;
	  };

	  /**
	   * Wraps a string exposing {@link #match} and {@link #split} methods that return
	   * {@link Sequence} objects instead of arrays, improving on the efficiency of
	   * JavaScript's built-in `String#split` and `String.match` methods and
	   * supporting asynchronous iteration.
	   *
	   * @param {string} source The string to wrap.
	   * @constructor
	   */
	  function StringWrapper(source) {
	    this.source = source;
	  }

	  StringWrapper.prototype = new StringLikeSequence();

	  StringWrapper.prototype.root = function root() {
	    return this;
	  };

	  StringWrapper.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  StringWrapper.prototype.get = function get(i) {
	    return this.source.charAt(i);
	  };

	  StringWrapper.prototype.length = function length() {
	    return this.source.length;
	  };

	  StringWrapper.prototype.toString = function toString() {
	    return this.source;
	  };

	  /**
	   * A `GeneratedSequence` does not wrap an in-memory colllection but rather
	   * determines its elements on-the-fly during iteration according to a generator
	   * function.
	   *
	   * You create a `GeneratedSequence` by calling {@link Lazy.generate}.
	   *
	   * @public
	   * @constructor
	   * @param {function(number):*} generatorFn A function which accepts an index
	   *     and returns a value for the element at that position in the sequence.
	   * @param {number=} length The length of the sequence. If this argument is
	   *     omitted, the sequence will go on forever.
	   */
	  function GeneratedSequence(generatorFn, length) {
	    this.get = generatorFn;
	    this.fixedLength = length;
	  }

	  GeneratedSequence.prototype = new Sequence();

	  GeneratedSequence.prototype.isAsync = function isAsync() {
	    return false;
	  };

	  /**
	   * Returns the length of this sequence.
	   *
	   * @public
	   * @returns {number} The length, or `undefined` if this is an indefinite
	   *     sequence.
	   */
	  GeneratedSequence.prototype.length = function length() {
	    return this.fixedLength;
	  };

	  /**
	   * Iterates over the sequence produced by invoking this sequence's generator
	   * function up to its specified length, or, if length is `undefined`,
	   * indefinitely (in which case the sequence will go on forever--you would need
	   * to call, e.g., {@link Sequence#take} to limit iteration).
	   *
	   * @public
	   * @param {Function} fn The function to call on each output from the generator
	   *     function.
	   */
	  GeneratedSequence.prototype.each = function each(fn) {
	    var generatorFn = this.get,
	        length = this.fixedLength,
	        i = 0;

	    while (typeof length === "undefined" || i < length) {
	      if (fn(generatorFn(i), i++) === false) {
	        return false;
	      }
	    }

	    return true;
	  };

	  GeneratedSequence.prototype.getIterator = function getIterator() {
	    return new GeneratedIterator(this);
	  };

	  /**
	   * Iterates over a generated sequence. (This allows generated sequences to be
	   * iterated asynchronously.)
	   *
	   * @param {GeneratedSequence} sequence The generated sequence to iterate over.
	   * @constructor
	   */
	  function GeneratedIterator(sequence) {
	    this.sequence     = sequence;
	    this.index        = 0;
	    this.currentValue = null;
	  }

	  GeneratedIterator.prototype.current = function current() {
	    return this.currentValue;
	  };

	  GeneratedIterator.prototype.moveNext = function moveNext() {
	    var sequence = this.sequence;

	    if (typeof sequence.fixedLength === "number" && this.index >= sequence.fixedLength) {
	      return false;
	    }

	    this.currentValue = sequence.get(this.index++);
	    return true;
	  };

	  /**
	   * An `AsyncSequence` iterates over its elements asynchronously when
	   * {@link #each} is called.
	   *
	   * You get an `AsyncSequence` by calling {@link Sequence#async} on any
	   * sequence. Note that some sequence types may not support asynchronous
	   * iteration.
	   *
	   * Returning values
	   * ----------------
	   *
	   * Because of its asynchronous nature, an `AsyncSequence` cannot be used in the
	   * same way as other sequences for functions that return values directly (e.g.,
	   * `reduce`, `max`, `any`, even `toArray`).
	   *
	   * Instead, these methods return an `AsyncHandle` whose `onComplete` method
	   * accepts a callback that will be called with the final result once iteration
	   * has finished.
	   *
	   * Defining custom asynchronous sequences
	   * --------------------------------------
	   *
	   * There are plenty of ways to define an asynchronous sequence. Here's one.
	   *
	   * 1. First, implement an {@link Iterator}. This is an object whose prototype
	   *    has the methods {@link Iterator#moveNext} (which returns a `boolean`) and
	   *    {@link current} (which returns the current value).
	   * 2. Next, create a simple wrapper that inherits from `AsyncSequence`, whose
	   *    `getIterator` function returns an instance of the iterator type you just
	   *    defined.
	   *
	   * The default implementation for {@link #each} on an `AsyncSequence` is to
	   * create an iterator and then asynchronously call {@link Iterator#moveNext}
	   * (using `setImmediate`, if available, otherwise `setTimeout`) until the iterator
	   * can't move ahead any more.
	   *
	   * @public
	   * @constructor
	   * @param {Sequence} parent A {@link Sequence} to wrap, to expose asynchronous
	   *     iteration.
	   * @param {number=} interval How many milliseconds should elapse between each
	   *     element when iterating over this sequence. If this argument is omitted,
	   *     asynchronous iteration will be executed as fast as possible.
	   */
	  function AsyncSequence(parent, interval) {
	    if (parent instanceof AsyncSequence) {
	      throw new Error("Sequence is already asynchronous!");
	    }

	    this.parent         = parent;
	    this.interval       = interval;
	    this.onNextCallback = getOnNextCallback(interval);
	    this.cancelCallback = getCancelCallback(interval);
	  }

	  AsyncSequence.prototype = new Sequence();

	  AsyncSequence.prototype.isAsync = function isAsync() {
	    return true;
	  };

	  /**
	   * Throws an exception. You cannot manually iterate over an asynchronous
	   * sequence.
	   *
	   * @public
	   * @example
	   * Lazy([1, 2, 3]).async().getIterator() // throws
	   */
	  AsyncSequence.prototype.getIterator = function getIterator() {
	    throw new Error('An AsyncSequence does not support synchronous iteration.');
	  };

	  /**
	   * An asynchronous version of {@link Sequence#each}.
	   *
	   * @public
	   * @param {Function} fn The function to invoke asynchronously on each element in
	   *     the sequence one by one.
	   * @returns {AsyncHandle} An {@link AsyncHandle} providing the ability to
	   *     cancel the asynchronous iteration (by calling `cancel()`) as well as
	   *     supply callback(s) for when an error is encountered (`onError`) or when
	   *     iteration is complete (`onComplete`).
	   */
	  AsyncSequence.prototype.each = function each(fn) {
	    var iterator = this.parent.getIterator(),
	        onNextCallback = this.onNextCallback,
	        cancelCallback = this.cancelCallback,
	        i = 0;

	    var handle = new AsyncHandle(function cancel() {
	      if (cancellationId) {
	        cancelCallback(cancellationId);
	      }
	    });

	    var cancellationId = onNextCallback(function iterate() {
	      cancellationId = null;

	      try {
	        if (iterator.moveNext() && fn(iterator.current(), i++) !== false) {
	          cancellationId = onNextCallback(iterate);

	        } else {
	          handle._resolve();
	        }

	      } catch (e) {
	        handle._reject(e);
	      }
	    });

	    return handle;
	  };

	  /**
	   * An `AsyncHandle` provides a [Promises/A+](http://promises-aplus.github.io/promises-spec/)
	   * compliant interface for an {@link AsyncSequence} that is currently (or was)
	   * iterating over its elements.
	   *
	   * In addition to behaving as a promise, an `AsyncHandle` provides the ability
	   * to {@link AsyncHandle#cancel} iteration (if `cancelFn` is provided)
	   * and also offers convenient {@link AsyncHandle#onComplete} and
	   * {@link AsyncHandle#onError} methods to attach listeners for when iteration
	   * is complete or an error is thrown during iteration.
	   *
	   * @public
	   * @param {Function} cancelFn A function to cancel asynchronous iteration.
	   *     This is passed in to support different cancellation mechanisms for
	   *     different forms of asynchronous sequences (e.g., timeout-based
	   *     sequences, sequences based on I/O, etc.).
	   * @constructor
	   *
	   * @example
	   * // Create a sequence of 100,000 random numbers, in chunks of 100.
	   * var sequence = Lazy.generate(Math.random)
	   *   .chunk(100)
	   *   .async()
	   *   .take(1000);
	   *
	   * // Reduce-style operations -- i.e., operations that return a *value* (as
	   * // opposed to a *sequence*) -- return an AsyncHandle for async sequences.
	   * var handle = sequence.toArray();
	   *
	   * handle.onComplete(function(array) {
	   *   // Do something w/ 1,000-element array.
	   * });
	   *
	   * // Since an AsyncHandle is a promise, you can also use it to create
	   * // subsequent promises using `then` (see the Promises/A+ spec for more
	   * // info).
	   * var flattened = handle.then(function(array) {
	   *   return Lazy(array).flatten();
	   * });
	   */
	  function AsyncHandle(cancelFn) {
	    this.resolveListeners = [];
	    this.rejectListeners = [];
	    this.state = PENDING;
	    this.cancelFn = cancelFn;
	  }

	  // Async handle states
	  var PENDING  = 1,
	      RESOLVED = 2,
	      REJECTED = 3;

	  AsyncHandle.prototype.then = function then(onFulfilled, onRejected) {
	    var promise = new AsyncHandle(this.cancelFn);

	    this.resolveListeners.push(function(value) {
	      try {
	        if (typeof onFulfilled !== 'function') {
	          resolve(promise, value);
	          return;
	        }

	        resolve(promise, onFulfilled(value));

	      } catch (e) {
	        promise._reject(e);
	      }
	    });

	    this.rejectListeners.push(function(reason) {
	      try {
	        if (typeof onRejected !== 'function') {
	          promise._reject(reason);
	          return;
	        }

	        resolve(promise, onRejected(reason));

	      } catch (e) {
	        promise._reject(e);
	      }
	    });

	    if (this.state === RESOLVED) {
	      this._resolve(this.value);
	    }

	    if (this.state === REJECTED) {
	      this._reject(this.reason);
	    }

	    return promise;
	  };

	  AsyncHandle.prototype._resolve = function _resolve(value) {
	    if (this.state === REJECTED) {
	      return;
	    }

	    if (this.state === PENDING) {
	      this.state = RESOLVED;
	      this.value = value;
	    }

	    consumeListeners(this.resolveListeners, this.value);
	  };

	  AsyncHandle.prototype._reject = function _reject(reason) {
	    if (this.state === RESOLVED) {
	      return;
	    }

	    if (this.state === PENDING) {
	      this.state = REJECTED;
	      this.reason = reason;
	    }

	    consumeListeners(this.rejectListeners, this.reason);
	  };

	  /**
	   * Cancels asynchronous iteration.
	   *
	   * @public
	   */
	  AsyncHandle.prototype.cancel = function cancel() {
	    if (this.cancelFn) {
	      this.cancelFn();
	      this.cancelFn = null;
	      this._resolve(false);
	    }
	  };

	  /**
	   * Updates the handle with a callback to execute when iteration is completed.
	   *
	   * @public
	   * @param {Function} callback The function to call when the asynchronous
	   *     iteration is completed.
	   * @return {AsyncHandle} A reference to the handle (for chaining).
	   */
	  AsyncHandle.prototype.onComplete = function onComplete(callback) {
	    this.resolveListeners.push(callback);
	    return this;
	  };

	  /**
	   * Updates the handle with a callback to execute if/when any error is
	   * encountered during asynchronous iteration.
	   *
	   * @public
	   * @param {Function} callback The function to call, with any associated error
	   *     object, when an error occurs.
	   * @return {AsyncHandle} A reference to the handle (for chaining).
	   */
	  AsyncHandle.prototype.onError = function onError(callback) {
	    this.rejectListeners.push(callback);
	    return this;
	  };

	  /**
	   * Promise resolution procedure:
	   * http://promises-aplus.github.io/promises-spec/#the_promise_resolution_procedure
	   */
	  function resolve(promise, x) {
	    if (promise === x) {
	      promise._reject(new TypeError('Cannot resolve a promise to itself'));
	      return;
	    }

	    if (x instanceof AsyncHandle) {
	      x.then(
	        function(value) { resolve(promise, value); },
	        function(reason) { promise._reject(reason); }
	      );
	      return;
	    }

	    var then;
	    try {
	      then = (/function|object/).test(typeof x) && x != null && x.then;
	    } catch (e) {
	      promise._reject(e);
	      return;
	    }

	    var thenableState = PENDING;
	    if (typeof then === 'function') {
	      try {
	        then.call(
	          x,
	          function resolvePromise(value) {
	            if (thenableState !== PENDING) {
	              return;
	            }
	            thenableState = RESOLVED;
	            resolve(promise, value);
	          },
	          function rejectPromise(reason) {
	            if (thenableState !== PENDING) {
	              return;
	            }
	            thenableState = REJECTED;
	            promise._reject(reason);
	          }
	        );
	      } catch (e) {
	        if (thenableState !== PENDING) {
	          return;
	        }

	        promise._reject(e);
	      }

	      return;
	    }

	    promise._resolve(x);
	  }

	  function consumeListeners(listeners, value, callback) {
	    callback || (callback = getOnNextCallback());

	    callback(function() {
	      if (listeners.length > 0) {
	        listeners.shift()(value);
	        consumeListeners(listeners, value, callback);
	      }
	    });
	  }

	  function getOnNextCallback(interval) {
	    if (typeof interval === "undefined") {
	      if (typeof setImmediate === "function") {
	        return setImmediate;
	      }
	    }

	    interval = interval || 0;
	    return function(fn) {
	      return setTimeout(fn, interval);
	    };
	  }

	  function getCancelCallback(interval) {
	    if (typeof interval === "undefined") {
	      if (typeof clearImmediate === "function") {
	        return clearImmediate;
	      }
	    }

	    return clearTimeout;
	  }

	  /**
	   * Transform a value, whether the value is retrieved asynchronously or directly.
	   *
	   * @private
	   * @param {Function} fn The function that transforms the value.
	   * @param {*} value The value to be transformed. This can be an {@link AsyncHandle} when the value
	   *     is retrieved asynchronously, otherwise it can be anything.
	   * @returns {*} An {@link AsyncHandle} when `value` is also an {@link AsyncHandle}, otherwise
	   *     whatever `fn` resulted in.
	   */
	  function transform(fn, value) {
	    if (value instanceof AsyncHandle) {
	      return value.then(function() { fn(value); });
	    }
	    return fn(value);
	  }

	  /**
	   * An async version of {@link Sequence#reverse}.
	   */
	  AsyncSequence.prototype.reverse = function reverse() {
	    return this.parent.reverse().async();
	  };

	  /**
	   * A version of {@link Sequence#find} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {Function} predicate A function to call on (potentially) every element
	   *     in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     the found element, once it is detected, or else `undefined`.
	   */
	  AsyncSequence.prototype.find = function find(predicate) {
	    var found;

	    var handle = this.each(function(e, i) {
	      if (predicate(e, i)) {
	        found = e;
	        return false;
	      }
	    });

	    return handle.then(function() { return found; });
	  };

	  /**
	   * A version of {@link Sequence#indexOf} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     the found index, once it is detected, or -1.
	   */
	  AsyncSequence.prototype.indexOf = function indexOf(value) {
	    var foundIndex = -1;

	    var handle = this.each(function(e, i) {
	      if (e === value) {
	        foundIndex = i;
	        return false;
	      }
	    });

	    return handle.then(function() {
	      return foundIndex;
	    });
	  };

	  /**
	   * A version of {@link Sequence#contains} which returns an {@link AsyncHandle}.
	   *
	   * @public
	   * @param {*} value The element to search for in the sequence.
	   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to
	   *     either `true` or `false` to indicate whether the element was found.
	   */
	  AsyncSequence.prototype.contains = function contains(value) {
	    var found = false;

	    var handle = this.each(function(e) {
	      if (e === value) {
	        found = true;
	        return false;
	      }
	    });

	    return handle.then(function() {
	      return found;
	    });
	  };

	  /**
	   * Just return the same sequence for `AsyncSequence#async` (I see no harm in this).
	   */
	  AsyncSequence.prototype.async = function async() {
	    return this;
	  };

	  /**
	   * See {@link ObjectLikeSequence#watch} for docs.
	   */
	  ObjectWrapper.prototype.watch = function watch(propertyNames) {
	    return new WatchedPropertySequence(this.source, propertyNames);
	  };

	  function WatchedPropertySequence(object, propertyNames) {
	    this.listeners = [];

	    if (!propertyNames) {
	      propertyNames = Lazy(object).keys().toArray();
	    } else if (!(propertyNames instanceof Array)) {
	      propertyNames = [propertyNames];
	    }

	    var listeners = this.listeners,
	        index     = 0;

	    Lazy(propertyNames).each(function(propertyName) {
	      var propertyValue = object[propertyName];

	      Object.defineProperty(object, propertyName, {
	        get: function() {
	          return propertyValue;
	        },

	        set: function(value) {
	          for (var i = listeners.length - 1; i >= 0; --i) {
	            if (listeners[i]({ property: propertyName, value: value }, index) === false) {
	              listeners.splice(i, 1);
	            }
	          }
	          propertyValue = value;
	          ++index;
	        }
	      });
	    });
	  }

	  WatchedPropertySequence.prototype = new AsyncSequence();

	  WatchedPropertySequence.prototype.each = function each(fn) {
	    this.listeners.push(fn);
	  };

	  /**
	   * A StreamLikeSequence comprises a sequence of 'chunks' of data, which are
	   * typically multiline strings.
	   *
	   * @constructor
	   */
	  function StreamLikeSequence() {}

	  StreamLikeSequence.prototype = new AsyncSequence();

	  StreamLikeSequence.prototype.isAsync = function isAsync() {
	    return true;
	  };

	  StreamLikeSequence.prototype.split = function split(delimiter) {
	    return new SplitStreamSequence(this, delimiter);
	  };

	  /**
	   * @constructor
	   */
	  function SplitStreamSequence(parent, delimiter) {
	    this.parent    = parent;
	    this.delimiter = delimiter;
	    this.each      = this.getEachForDelimiter(delimiter);
	  }

	  SplitStreamSequence.prototype = new Sequence();

	  SplitStreamSequence.prototype.getEachForDelimiter = function getEachForDelimiter(delimiter) {
	    if (delimiter instanceof RegExp) {
	      return this.regexEach;
	    }

	    return this.stringEach;
	  };

	  SplitStreamSequence.prototype.regexEach = function each(fn) {
	    var delimiter = cloneRegex(this.delimiter),
	        buffer = '',
	        start = 0, end,
	        index = 0;

	    var handle = this.parent.each(function(chunk) {
	      buffer += chunk;

	      var match;
	      while (match = delimiter.exec(buffer)) {
	        end = match.index;
	        if (fn(buffer.substring(start, end), index++) === false) {
	          return false;
	        }
	        start = end + match[0].length;
	      }

	      buffer = buffer.substring(start);
	      start = 0;
	    });

	    handle.onComplete(function() {
	      if (buffer.length > 0) {
	        fn(buffer, index++);
	      }
	    });

	    return handle;
	  };

	  SplitStreamSequence.prototype.stringEach = function each(fn) {
	    var delimiter  = this.delimiter,
	        pieceIndex = 0,
	        buffer = '',
	        bufferIndex = 0;

	    var handle = this.parent.each(function(chunk) {
	      buffer += chunk;
	      var delimiterIndex;
	      while ((delimiterIndex = buffer.indexOf(delimiter)) >= 0) {
	        var piece = buffer.substr(0,delimiterIndex);
	        buffer = buffer.substr(delimiterIndex+delimiter.length);
	        if (fn(piece,pieceIndex++) === false) {
	          return false;
	        }
	      }
	      return true;
	    });

	    handle.onComplete(function() {
	      fn(buffer, pieceIndex++);
	    });

	    return handle;
	  };

	  StreamLikeSequence.prototype.lines = function lines() {
	    return this.split("\n");
	  };

	  StreamLikeSequence.prototype.match = function match(pattern) {
	    return new MatchedStreamSequence(this, pattern);
	  };

	  /**
	   * @constructor
	   */
	  function MatchedStreamSequence(parent, pattern) {
	    this.parent  = parent;
	    this.pattern = cloneRegex(pattern);
	  }

	  MatchedStreamSequence.prototype = new AsyncSequence();

	  MatchedStreamSequence.prototype.each = function each(fn) {
	    var pattern = this.pattern,
	        done      = false,
	        i         = 0;

	    return this.parent.each(function(chunk) {
	      Lazy(chunk).match(pattern).each(function(match) {
	        if (fn(match, i++) === false) {
	          done = true;
	          return false;
	        }
	      });

	      return !done;
	    });
	  };

	  /**
	   * Defines a wrapper for custom {@link StreamLikeSequence}s. This is useful
	   * if you want a way to handle a stream of events as a sequence, but you can't
	   * use Lazy's existing interface (i.e., you're wrapping an object from a
	   * library with its own custom events).
	   *
	   * This method defines a *factory*: that is, it produces a function that can
	   * be used to wrap objects and return a {@link Sequence}. Hopefully the
	   * example will make this clear.
	   *
	   * @public
	   * @param {Function} initializer An initialization function called on objects
	   *     created by this factory. `this` will be bound to the created object,
	   *     which is an instance of {@link StreamLikeSequence}. Use `emit` to
	   *     generate data for the sequence.
	   * @returns {Function} A function that creates a new {@link StreamLikeSequence},
	   *     initializes it using the specified function, and returns it.
	   *
	   * @example
	   * var factory = Lazy.createWrapper(function(eventSource) {
	   *   var sequence = this;
	   *
	   *   eventSource.handleEvent(function(data) {
	   *     sequence.emit(data);
	   *   });
	   * });
	   *
	   * var eventEmitter = {
	   *   triggerEvent: function(data) {
	   *     eventEmitter.eventHandler(data);
	   *   },
	   *   handleEvent: function(handler) {
	   *     eventEmitter.eventHandler = handler;
	   *   },
	   *   eventHandler: function() {}
	   * };
	   *
	   * var events = [];
	   *
	   * factory(eventEmitter).each(function(e) {
	   *   events.push(e);
	   * });
	   *
	   * eventEmitter.triggerEvent('foo');
	   * eventEmitter.triggerEvent('bar');
	   *
	   * events // => ['foo', 'bar']
	   */
	  Lazy.createWrapper = function createWrapper(initializer) {
	    var ctor = function() {
	      this.listeners = [];
	    };

	    ctor.prototype = new StreamLikeSequence();

	    ctor.prototype.each = function(listener) {
	      this.listeners.push(listener);
	    };

	    ctor.prototype.emit = function(data) {
	      var listeners = this.listeners;

	      for (var len = listeners.length, i = len - 1; i >= 0; --i) {
	        if (listeners[i](data) === false) {
	          listeners.splice(i, 1);
	        }
	      }
	    };

	    return function() {
	      var sequence = new ctor();
	      initializer.apply(sequence, arguments);
	      return sequence;
	    };
	  };

	  /**
	   * Creates a {@link GeneratedSequence} using the specified generator function
	   * and (optionally) length.
	   *
	   * @public
	   * @param {function(number):*} generatorFn The function used to generate the
	   *     sequence. This function accepts an index as a parameter and should return
	   *     a value for that index in the resulting sequence.
	   * @param {number=} length The length of the sequence, for sequences with a
	   *     definite length.
	   * @returns {GeneratedSequence} The generated sequence.
	   *
	   * @examples
	   * var randomNumbers = Lazy.generate(Math.random);
	   * var countingNumbers = Lazy.generate(function(i) { return i + 1; }, 5);
	   *
	   * randomNumbers          // instanceof Lazy.GeneratedSequence
	   * randomNumbers.length() // => undefined
	   * countingNumbers          // sequence: [1, 2, 3, 4, 5]
	   * countingNumbers.length() // => 5
	   */
	  Lazy.generate = function generate(generatorFn, length) {
	    return new GeneratedSequence(generatorFn, length);
	  };

	  /**
	   * Creates a sequence from a given starting value, up to a specified stopping
	   * value, incrementing by a given step. Invalid values for any of these
	   * arguments (e.g., a step of 0) result in an empty sequence.
	   *
	   * @public
	   * @returns {GeneratedSequence} The sequence defined by the given ranges.
	   *
	   * @examples
	   * Lazy.range(3)         // sequence: [0, 1, 2]
	   * Lazy.range(1, 4)      // sequence: [1, 2, 3]
	   * Lazy.range(2, 10, 2)  // sequence: [2, 4, 6, 8]
	   * Lazy.range(5, 1, 2)   // sequence: []
	   * Lazy.range(5, 15, -2) // sequence: []
	   * Lazy.range(3, 10, 3)  // sequence: [3, 6, 9]
	   * Lazy.range(5, 2)      // sequence: [5, 4, 3]
	   * Lazy.range(7, 2, -2)  // sequence: [7, 5, 3]
	   * Lazy.range(3, 5, 0)   // sequence: []
	   */
	  Lazy.range = function range() {
	    var start = arguments.length > 1 ? arguments[0] : 0,
	        stop  = arguments.length > 1 ? arguments[1] : arguments[0],
	        step  = arguments.length > 2 && arguments[2];

	    if (step === false) {
	      step = stop > start ? 1 : -1;
	    }

	    if (step === 0) {
	      return Lazy([]);
	    }

	    return Lazy.generate(function(i) { return start + (step * i); })
	      .take(Math.ceil((stop - start) / step));
	  };

	  /**
	   * Creates a sequence consisting of the given value repeated a specified number
	   * of times.
	   *
	   * @public
	   * @param {*} value The value to repeat.
	   * @param {number=} count The number of times the value should be repeated in
	   *     the sequence. If this argument is omitted, the value will repeat forever.
	   * @returns {GeneratedSequence} The sequence containing the repeated value.
	   *
	   * @examples
	   * Lazy.repeat("hi", 3)          // sequence: ["hi", "hi", "hi"]
	   * Lazy.repeat("young")          // instanceof Lazy.GeneratedSequence
	   * Lazy.repeat("young").length() // => undefined
	   * Lazy.repeat("young").take(3)  // sequence: ["young", "young", "young"]
	   */
	  Lazy.repeat = function repeat(value, count) {
	    return Lazy.generate(function() { return value; }, count);
	  };

	  Lazy.Sequence           = Sequence;
	  Lazy.ArrayLikeSequence  = ArrayLikeSequence;
	  Lazy.ObjectLikeSequence = ObjectLikeSequence;
	  Lazy.StringLikeSequence = StringLikeSequence;
	  Lazy.StreamLikeSequence = StreamLikeSequence;
	  Lazy.GeneratedSequence  = GeneratedSequence;
	  Lazy.AsyncSequence      = AsyncSequence;
	  Lazy.AsyncHandle        = AsyncHandle;

	  /*** Useful utility methods ***/

	  /**
	   * Creates a shallow copy of an array or object.
	   *
	   * @examples
	   * var array  = [1, 2, 3], clonedArray,
	   *     object = { foo: 1, bar: 2 }, clonedObject;
	   *
	   * clonedArray = Lazy.clone(array); // => [1, 2, 3]
	   * clonedArray.push(4); // clonedArray == [1, 2, 3, 4]
	   * array; // => [1, 2, 3]
	   *
	   * clonedObject = Lazy.clone(object); // => { foo: 1, bar: 2 }
	   * clonedObject.baz = 3; // clonedObject == { foo: 1, bar: 2, baz: 3 }
	   * object; // => { foo: 1, bar: 2 }
	   */
	  Lazy.clone = function clone(target) {
	    return Lazy(target).value();
	  };

	  /**
	   * Marks a method as deprecated, so calling it will issue a console warning.
	   */
	  Lazy.deprecate = function deprecate(message, fn) {
	    return function() {
	      console.warn(message);
	      return fn.apply(this, arguments);
	    };
	  };

	  var arrayPop   = Array.prototype.pop,
	      arraySlice = Array.prototype.slice;

	  /**
	   * Creates a callback... you know, Lo-Dash style.
	   *
	   * - for functions, just returns the function
	   * - for strings, returns a pluck-style callback
	   * - for objects, returns a where-style callback
	   *
	   * @private
	   * @param {Function|string|Object} callback A function, string, or object to
	   *     convert to a callback.
	   * @param {*} defaultReturn If the callback is undefined, a default return
	   *     value to use for the function.
	   * @returns {Function} The callback function.
	   *
	   * @examples
	   * createCallback(function() {})                  // instanceof Function
	   * createCallback('foo')                          // instanceof Function
	   * createCallback('foo')({ foo: 'bar'})           // => 'bar'
	   * createCallback({ foo: 'bar' })({ foo: 'bar' }) // => true
	   * createCallback({ foo: 'bar' })({ foo: 'baz' }) // => false
	   */
	  function createCallback(callback, defaultValue) {
	    switch (typeof callback) {
	      case "function":
	        return callback;

	      case "string":
	        return function(e) {
	          return e[callback];
	        };

	      case "object":
	        return function(e) {
	          return Lazy(callback).all(function(value, key) {
	            return e[key] === value;
	          });
	        };

	      case "undefined":
	        return defaultValue ?
	          function() { return defaultValue; } :
	          Lazy.identity;

	      default:
	        throw new Error("Don't know how to make a callback from a " + typeof callback + "!");
	    }
	  }

	  /**
	   * Takes a function that returns a value for one argument and produces a
	   * function that compares two arguments.
	   *
	   * @private
	   * @param {Function|string|Object} callback A function, string, or object to
	   *     convert to a callback using `createCallback`.
	   * @returns {Function} A function that accepts two values and returns 1 if
	   *     the first is greater, -1 if the second is greater, or 0 if they are
	   *     equivalent.
	   *
	   * @examples
	   * createComparator('a')({ a: 1 }, { a: 2 });       // => -1
	   * createComparator('a')({ a: 6 }, { a: 2 });       // => 1
	   * createComparator('a')({ a: 1 }, { a: 1 });       // => 0
	   * createComparator()(3, 5);                        // => -1
	   * createComparator()(7, 5);                        // => 1
	   * createComparator()(3, 3);                        // => 0
	   */
	  function createComparator(callback, descending) {
	    if (!callback) { return compare; }

	    callback = createCallback(callback);

	    return function(x, y) {
	      return compare(callback(x), callback(y));
	    };
	  }

	  /**
	   * Takes a function and returns a function with the same logic but the
	   * arguments reversed. Only applies to functions w/ arity=2 as this is private
	   * and I can do what I want.
	   *
	   * @private
	   * @param {Function} fn The function to "reverse"
	   * @returns {Function} The "reversed" function
	   *
	   * @examples
	   * reverseArguments(function(x, y) { return x + y; })('a', 'b'); // => 'ba'
	   */
	  function reverseArguments(fn) {
	    return function(x, y) { return fn(y, x); };
	  }

	  /**
	   * Creates a Set containing the specified values.
	   *
	   * @param {...Array} values One or more array(s) of values used to populate the
	   *     set.
	   * @returns {Set} A new set containing the values passed in.
	   */
	  function createSet(values) {
	    var set = new Set();
	    Lazy(values || []).flatten().each(function(e) {
	      set.add(e);
	    });
	    return set;
	  }

	  /**
	   * Compares two elements for sorting purposes.
	   *
	   * @private
	   * @param {*} x The left element to compare.
	   * @param {*} y The right element to compare.
	   * @returns {number} 1 if x > y, -1 if x < y, or 0 if x and y are equal.
	   *
	   * @examples
	   * compare(1, 2)     // => -1
	   * compare(1, 1)     // => 0
	   * compare(2, 1)     // => 1
	   * compare('a', 'b') // => -1
	   */
	  function compare(x, y) {
	    if (x === y) {
	      return 0;
	    }

	    return x > y ? 1 : -1;
	  }

	  /**
	   * Iterates over every element in an array.
	   *
	   * @param {Array} array The array.
	   * @param {Function} fn The function to call on every element, which can return
	   *     false to stop the iteration early.
	   * @returns {boolean} True if every element in the entire sequence was iterated,
	   *     otherwise false.
	   */
	  function forEach(array, fn) {
	    var i = -1,
	        len = array.length;

	    while (++i < len) {
	      if (fn(array[i], i) === false) {
	        return false;
	      }
	    }

	    return true;
	  }

	  function getFirst(sequence) {
	    var result;
	    sequence.each(function(e) {
	      result = e;
	      return false;
	    });
	    return result;
	  }

	  /**
	   * Checks if an element exists in an array.
	   *
	   * @private
	   * @param {Array} array
	   * @param {*} element
	   * @returns {boolean} Whether or not the element exists in the array.
	   *
	   * @examples
	   * arrayContains([1, 2], 2)              // => true
	   * arrayContains([1, 2], 3)              // => false
	   * arrayContains([undefined], undefined) // => true
	   * arrayContains([NaN], NaN)             // => true
	   */
	  function arrayContains(array, element) {
	    var i = -1,
	        length = array.length;

	    // Special handling for NaN
	    if (element !== element) {
	      while (++i < length) {
	        if (array[i] !== array[i]) {
	          return true;
	        }
	      }
	      return false;
	    }

	    while (++i < length) {
	      if (array[i] === element) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Checks if an element exists in an array before a given index.
	   *
	   * @private
	   * @param {Array} array
	   * @param {*} element
	   * @param {number} index
	   * @param {Function} keyFn
	   * @returns {boolean}
	   *
	   * @examples
	   * arrayContainsBefore([1, 2, 3], 3, 2) // => false
	   * arrayContainsBefore([1, 2, 3], 3, 3) // => true
	   */
	  function arrayContainsBefore(array, element, index, keyFn) {
	    var i = -1;

	    if (keyFn) {
	      keyFn = createCallback(keyFn);
	      while (++i < index) {
	        if (keyFn(array[i]) === keyFn(element)) {
	          return true;
	        }
	      }

	    } else {
	      while (++i < index) {
	        if (array[i] === element) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  /**
	   * Swaps the elements at two specified positions of an array.
	   *
	   * @private
	   * @param {Array} array
	   * @param {number} i
	   * @param {number} j
	   *
	   * @examples
	   * var array = [1, 2, 3, 4, 5];
	   *
	   * swap(array, 2, 3) // array == [1, 2, 4, 3, 5]
	   */
	  function swap(array, i, j) {
	    var temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	  }

	  /**
	   * "Clones" a regular expression (but makes it always global).
	   *
	   * @private
	   * @param {RegExp|string} pattern
	   * @returns {RegExp}
	   */
	  function cloneRegex(pattern) {
	    return eval("" + pattern + (!pattern.global ? "g" : ""));
	  };

	  /**
	   * A collection of unique elements.
	   *
	   * @private
	   * @constructor
	   *
	   * @examples
	   * var set  = new Set(),
	   *     obj1 = {},
	   *     obj2 = {},
	   *     fn1 = function fn1() {},
	   *     fn2 = function fn2() {};
	   *
	   * set.add('foo')            // => true
	   * set.add('foo')            // => false
	   * set.add(1)                // => true
	   * set.add(1)                // => false
	   * set.add('1')              // => true
	   * set.add('1')              // => false
	   * set.add(obj1)             // => true
	   * set.add(obj1)             // => false
	   * set.add(obj2)             // => true
	   * set.add(fn1)              // => true
	   * set.add(fn2)              // => true
	   * set.add(fn2)              // => false
	   * set.contains('__proto__') // => false
	   * set.add('__proto__')      // => true
	   * set.add('__proto__')      // => false
	   * set.contains('add')       // => false
	   * set.add('add')            // => true
	   * set.add('add')            // => false
	   * set.contains(undefined)   // => false
	   * set.add(undefined)        // => true
	   * set.contains(undefined)   // => true
	   * set.contains('undefined') // => false
	   * set.add('undefined')      // => true
	   * set.contains('undefined') // => true
	   * set.contains(NaN)         // => false
	   * set.add(NaN)              // => true
	   * set.contains(NaN)         // => true
	   * set.contains('NaN')       // => false
	   * set.add('NaN')            // => true
	   * set.contains('NaN')       // => true
	   * set.contains('@foo')      // => false
	   * set.add('@foo')           // => true
	   * set.contains('@foo')      // => true
	   */
	  function Set() {
	    this.table   = {};
	    this.objects = [];
	  }

	  /**
	   * Attempts to add a unique value to the set.
	   *
	   * @param {*} value The value to add.
	   * @returns {boolean} True if the value was added to the set (meaning an equal
	   *     value was not already present), or else false.
	   */
	  Set.prototype.add = function add(value) {
	    var table = this.table,
	        type  = typeof value,

	        // only applies for strings
	        firstChar,

	        // only applies for objects
	        objects;

	    switch (type) {
	      case "number":
	      case "boolean":
	      case "undefined":
	        if (!table[value]) {
	          table[value] = true;
	          return true;
	        }
	        return false;

	      case "string":
	        // Essentially, escape the first character if it could possibly collide
	        // with a number, boolean, or undefined (or a string that happens to start
	        // with the escape character!), OR if it could override a special property
	        // such as '__proto__' or 'constructor'.
	        switch (value.charAt(0)) {
	          case "_": // e.g., __proto__
	          case "f": // for 'false'
	          case "t": // for 'true'
	          case "c": // for 'constructor'
	          case "u": // for 'undefined'
	          case "@": // escaped
	          case "0":
	          case "1":
	          case "2":
	          case "3":
	          case "4":
	          case "5":
	          case "6":
	          case "7":
	          case "8":
	          case "9":
	          case "N": // for NaN
	            value = "@" + value;
	        }
	        if (!table[value]) {
	          table[value] = true;
	          return true;
	        }
	        return false;

	      default:
	        // For objects and functions, we can't really do anything other than store
	        // them in an array and do a linear search for reference equality.
	        objects = this.objects;
	        if (!arrayContains(objects, value)) {
	          objects.push(value);
	          return true;
	        }
	        return false;
	    }
	  };

	  /**
	   * Checks whether the set contains a value.
	   *
	   * @param {*} value The value to check for.
	   * @returns {boolean} True if the set contains the value, or else false.
	   */
	  Set.prototype.contains = function contains(value) {
	    var type = typeof value,

	        // only applies for strings
	        firstChar;

	    switch (type) {
	      case "number":
	      case "boolean":
	      case "undefined":
	        return !!this.table[value];

	      case "string":
	        // Essentially, escape the first character if it could possibly collide
	        // with a number, boolean, or undefined (or a string that happens to start
	        // with the escape character!), OR if it could override a special property
	        // such as '__proto__' or 'constructor'.
	        switch (value.charAt(0)) {
	          case "_": // e.g., __proto__
	          case "f": // for 'false'
	          case "t": // for 'true'
	          case "c": // for 'constructor'
	          case "u": // for 'undefined'
	          case "@": // escaped
	          case "0":
	          case "1":
	          case "2":
	          case "3":
	          case "4":
	          case "5":
	          case "6":
	          case "7":
	          case "8":
	          case "9":
	          case "N": // for NaN
	            value = "@" + value;
	        }
	        return !!this.table[value];

	      default:
	        // For objects and functions, we can't really do anything other than store
	        // them in an array and do a linear search for reference equality.
	        return arrayContains(this.objects, value);
	    }
	  };

	  /**
	   * A "rolling" queue, with a fixed capacity. As items are added to the head,
	   * excess items are dropped from the tail.
	   *
	   * @private
	   * @constructor
	   *
	   * @examples
	   * var queue = new Queue(3);
	   *
	   * queue.add(1).toArray()        // => [1]
	   * queue.add(2).toArray()        // => [1, 2]
	   * queue.add(3).toArray()        // => [1, 2, 3]
	   * queue.add(4).toArray()        // => [2, 3, 4]
	   * queue.add(5).add(6).toArray() // => [4, 5, 6]
	   * queue.add(7).add(8).toArray() // => [6, 7, 8]
	   *
	   * // also want to check corner cases
	   * new Queue(1).add('foo').add('bar').toArray() // => ['bar']
	   * new Queue(0).add('foo').toArray()            // => []
	   * new Queue(-1)                                // throws
	   *
	   * @benchmarks
	   * function populateQueue(count, capacity) {
	   *   var q = new Queue(capacity);
	   *   for (var i = 0; i < count; ++i) {
	   *     q.add(i);
	   *   }
	   * }
	   *
	   * function populateArray(count, capacity) {
	   *   var arr = [];
	   *   for (var i = 0; i < count; ++i) {
	   *     if (arr.length === capacity) { arr.shift(); }
	   *     arr.push(i);
	   *   }
	   * }
	   *
	   * populateQueue(100, 10); // populating a Queue
	   * populateArray(100, 10); // populating an Array
	   */
	  function Queue(capacity) {
	    this.contents = new Array(capacity);
	    this.start    = 0;
	    this.count    = 0;
	  }

	  /**
	   * Adds an item to the queue, and returns the queue.
	   */
	  Queue.prototype.add = function add(element) {
	    var contents = this.contents,
	        capacity = contents.length,
	        start    = this.start;

	    if (this.count === capacity) {
	      contents[start] = element;
	      this.start = (start + 1) % capacity;

	    } else {
	      contents[this.count++] = element;
	    }

	    return this;
	  };

	  /**
	   * Returns an array containing snapshot of the queue's contents.
	   */
	  Queue.prototype.toArray = function toArray() {
	    var contents = this.contents,
	        start    = this.start,
	        count    = this.count;

	    var snapshot = contents.slice(start, start + count);
	    if (snapshot.length < count) {
	      snapshot = snapshot.concat(contents.slice(0, count - snapshot.length));
	    }

	    return snapshot;
	  };

	  /**
	   * Shared base method for defining new sequence types.
	   */
	  function defineSequenceType(base, name, overrides) {
	    /** @constructor */
	    var ctor = function ctor() {};

	    // Make this type inherit from the specified base.
	    ctor.prototype = new base();

	    // Attach overrides to the new sequence type's prototype.
	    for (var override in overrides) {
	      ctor.prototype[override] = overrides[override];
	    }

	    // Define a factory method that sets the new sequence's parent to the caller
	    // and (optionally) applies any additional initialization logic.
	    // Expose this as a chainable method so that we can do:
	    // Lazy(...).map(...).filter(...).blah(...);
	    var factory = function factory() {
	      var sequence = new ctor();

	      // Every sequence needs a reference to its parent in order to work.
	      sequence.parent = this;

	      // If a custom init function was supplied, call it now.
	      if (sequence.init) {
	        sequence.init.apply(sequence, arguments);
	      }

	      return sequence;
	    };

	    var methodNames = typeof name === 'string' ? [name] : name;
	    for (var i = 0; i < methodNames.length; ++i) {
	      base.prototype[methodNames[i]] = factory;
	    }

	    return ctor;
	  }

	  return Lazy;
	});


/***/ },
/* 285 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array ? array.length : 0;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a cache value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * This method is like `_.difference` except that it accepts `comparator`
	 * which is invoked to compare elements of `array` to `values`. Result values
	 * are chosen from the first array. The comparator is invoked with two arguments:
	 * (arrVal, othVal).
	 *
	 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 *
	 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	 * // => [{ 'x': 2, 'y': 1 }]
	 */
	var differenceWith = baseRest(function(array, values) {
	  var comparator = last(values);
	  if (isArrayLikeObject(comparator)) {
	    comparator = undefined;
	  }
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	    : [];
	});

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = differenceWith;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var result,
	      index = -1,
	      length = path.length;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);

	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity]
	 *  The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = filter;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ },
/* 287 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array ? array.length : 0;
	  return length ? baseFlatten(array, 1) : [];
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = flatten;


/***/ },
/* 288 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array ? array.length : 0;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * Checks if a cache value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    Set = getNative(root, 'Set'),
	    nativeCreate = getNative(Object, 'create');

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	  return new Set(values);
	};

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * This method is like `_.union` except that it accepts `comparator` which
	 * is invoked to compare elements of `arrays`. Result values are chosen from
	 * the first array in which the value occurs. The comparator is invoked
	 * with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.unionWith(objects, others, _.isEqual);
	 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	 */
	var unionWith = baseRest(function(arrays) {
	  var comparator = last(arrays);
	  if (isArrayLikeObject(comparator)) {
	    comparator = undefined;
	  }
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	});

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = unionWith;


/***/ },
/* 289 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(293),
	    isArguments = __webpack_require__(299),
	    isArray = __webpack_require__(300),
	    isIndex = __webpack_require__(294);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(295),
	    nativeKeys = __webpack_require__(296);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(289);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = baseRest;


/***/ },
/* 293 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 294 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 295 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(297);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ },
/* 297 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(88);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that invokes `func`, with the `this` binding and arguments
	 * of the created function, while it's called less than `n` times. Subsequent
	 * calls to the created function return the result of the last `func` invocation.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {number} n The number of calls at which `func` is no longer invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * jQuery(element).on('click', _.before(5, addContactToList));
	 * // => Allows adding up to 4 contacts to the list.
	 */
	function before(n, func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	}

	module.exports = before;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLikeObject = __webpack_require__(301);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	module.exports = isArguments;


/***/ },
/* 300 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(23),
	    isObjectLike = __webpack_require__(87);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(86);

	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	module.exports = isFunction;


/***/ },
/* 303 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(87);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(290),
	    baseKeys = __webpack_require__(291),
	    isArrayLike = __webpack_require__(23);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var before = __webpack_require__(298);

	/**
	 * Creates a function that is restricted to invoking `func` once. Repeat calls
	 * to the function return the value of the first invocation. The `func` is
	 * invoked with the `this` binding and arguments of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var initialize = _.once(createApplication);
	 * initialize();
	 * initialize();
	 * // => `createApplication` is invoked once
	 */
	function once(func) {
	  return before(2, func);
	}

	module.exports = once;


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(292),
	    toInteger = __webpack_require__(88);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as
	 * an array.
	 *
	 * **Note:** This method is based on the
	 * [rest parameter](https://mdn.io/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.rest(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function rest(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = start === undefined ? start : toInteger(start);
	  return baseRest(func, start);
	}

	module.exports = rest;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(309);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(86),
	    isSymbol = __webpack_require__(304);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 310 */
/***/ function(module, exports) {

	module.exports = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var map = __webpack_require__(43);
	var filter = __webpack_require__(286);
	var convert = __webpack_require__(312);
	var protocols = __webpack_require__(45);
	var varint = __webpack_require__(28);

	// export codec
	module.exports = {
	  stringToStringTuples: stringToStringTuples,
	  stringTuplesToString: stringTuplesToString,

	  tuplesToStringTuples: tuplesToStringTuples,
	  stringTuplesToTuples: stringTuplesToTuples,

	  bufferToTuples: bufferToTuples,
	  tuplesToBuffer: tuplesToBuffer,

	  bufferToString: bufferToString,
	  stringToBuffer: stringToBuffer,

	  fromString: fromString,
	  fromBuffer: fromBuffer,
	  validateBuffer: validateBuffer,
	  isValidBuffer: isValidBuffer,
	  cleanPath: cleanPath,

	  ParseError: ParseError,
	  protoFromTuple: protoFromTuple,

	  sizeForAddr: sizeForAddr
	};

	// string -> [[str name, str addr]... ]
	function stringToStringTuples(str) {
	  var tuples = [];
	  var parts = str.split('/').slice(1); // skip first empty elem
	  if (parts.length === 1 && parts[0] === '') {
	    return [];
	  }

	  for (var p = 0; p < parts.length; p++) {
	    var part = parts[p];
	    var proto = protocols(part);

	    if (proto.size === 0) {
	      tuples.push([part]);
	      continue;
	    }

	    p++; // advance addr part
	    if (p >= parts.length) {
	      throw ParseError('invalid address: ' + str);
	    }

	    tuples.push([part, parts[p]]);
	  }

	  return tuples;
	}

	// [[str name, str addr]... ] -> string
	function stringTuplesToString(tuples) {
	  var parts = [];
	  map(tuples, function (tup) {
	    var proto = protoFromTuple(tup);
	    parts.push(proto.name);
	    if (tup.length > 1) {
	      parts.push(tup[1]);
	    }
	  });

	  return '/' + parts.join('/');
	}

	// [[str name, str addr]... ] -> [[int code, Buffer]... ]
	function stringTuplesToTuples(tuples) {
	  return map(tuples, function (tup) {
	    if (!Array.isArray(tup)) {
	      tup = [tup];
	    }
	    var proto = protoFromTuple(tup);
	    if (tup.length > 1) {
	      return [proto.code, convert.toBuffer(proto.code, tup[1])];
	    }
	    return [proto.code];
	  });
	}

	// [[int code, Buffer]... ] -> [[str name, str addr]... ]
	function tuplesToStringTuples(tuples) {
	  return map(tuples, function (tup) {
	    var proto = protoFromTuple(tup);
	    if (tup.length > 1) {
	      return [proto.code, convert.toString(proto.code, tup[1])];
	    }
	    return [proto.code];
	  });
	}

	// [[int code, Buffer ]... ] -> Buffer
	function tuplesToBuffer(tuples) {
	  return fromBuffer(Buffer.concat(map(tuples, function (tup) {
	    var proto = protoFromTuple(tup);
	    var buf = new Buffer(varint.encode(proto.code));

	    if (tup.length > 1) {
	      buf = Buffer.concat([buf, tup[1]]); // add address buffer
	    }

	    return buf;
	  })));
	}

	function sizeForAddr(p, addr) {
	  if (p.size > 0) {
	    return p.size / 8;
	  } else if (p.size === 0) {
	    return 0;
	  } else {
	    var size = varint.decode(addr);
	    return size + varint.decode.bytes;
	  }
	}

	// Buffer -> [[int code, Buffer ]... ]
	function bufferToTuples(buf) {
	  var tuples = [];
	  var i = 0;
	  while (i < buf.length) {
	    var code = varint.decode(buf, i);
	    var n = varint.decode.bytes;

	    var p = protocols(code);

	    var size = sizeForAddr(p, buf.slice(i + n));

	    if (size === 0) {
	      tuples.push([code]);
	      i += n;
	      continue;
	    }

	    var addr = buf.slice(i + n, i + n + size);

	    i += size + n;

	    if (i > buf.length) {
	      // did not end _exactly_ at buffer.length
	      throw ParseError('Invalid address buffer: ' + buf.toString('hex'));
	    }

	    // ok, tuple seems good.
	    tuples.push([code, addr]);
	  }

	  return tuples;
	}

	// Buffer -> String
	function bufferToString(buf) {
	  var a = bufferToTuples(buf);
	  var b = tuplesToStringTuples(a);
	  return stringTuplesToString(b);
	}

	// String -> Buffer
	function stringToBuffer(str) {
	  str = cleanPath(str);
	  var a = stringToStringTuples(str);
	  var b = stringTuplesToTuples(a);
	  return tuplesToBuffer(b);
	}

	// String -> Buffer
	function fromString(str) {
	  return stringToBuffer(str);
	}

	// Buffer -> Buffer
	function fromBuffer(buf) {
	  var err = validateBuffer(buf);
	  if (err) throw err;
	  return new Buffer(buf); // copy
	}

	function validateBuffer(buf) {
	  try {
	    bufferToTuples(buf); // try to parse. will throw if breaks
	  } catch (err) {
	    return err;
	  }
	}

	function isValidBuffer(buf) {
	  return validateBuffer(buf) === undefined;
	}

	function cleanPath(str) {
	  return '/' + filter(str.trim().split('/')).join('/');
	}

	function ParseError(str) {
	  return new Error('Error parsing address: ' + str);
	}

	function protoFromTuple(tup) {
	  var proto = protocols(tup[0]);
	  return proto;
	}

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var ip = __webpack_require__(275);
	var protocols = __webpack_require__(45);
	var bs58 = __webpack_require__(18);
	var varint = __webpack_require__(28);

	module.exports = Convert;

	// converts (serializes) addresses
	function Convert(proto, a) {
	  if (a instanceof Buffer) {
	    return Convert.toString(proto, a);
	  } else {
	    return Convert.toBuffer(proto, a);
	  }
	}

	Convert.toString = function convertToString(proto, buf) {
	  proto = protocols(proto);
	  switch (proto.code) {
	    case 4: // ipv4
	    case 41:
	      // ipv6
	      return ip.toString(buf);

	    case 6: // tcp
	    case 17: // udp
	    case 33: // dccp
	    case 132:
	      // sctp
	      return buf2port(buf);

	    case 421:
	      // ipfs
	      return buf2mh(buf);
	    default:
	      return buf.toString('hex'); // no clue. convert to hex
	  }
	};

	Convert.toBuffer = function convertToBuffer(proto, str) {
	  proto = protocols(proto);
	  switch (proto.code) {
	    case 4: // ipv4
	    case 41:
	      // ipv6
	      return ip.toBuffer(str);

	    case 6: // tcp
	    case 17: // udp
	    case 33: // dccp
	    case 132:
	      // sctp
	      return port2buf(parseInt(str, 10));

	    case 421:
	      // ipfs
	      return mh2buf(str);
	    default:
	      return new Buffer(str, 'hex'); // no clue. convert from hex
	  }
	};

	function port2buf(port) {
	  var buf = new Buffer(2);
	  buf.writeUInt16BE(port, 0);
	  return buf;
	}

	function buf2port(buf) {
	  return buf.readUInt16BE(0);
	}

	function mh2buf(hash) {
	  // the address is a varint prefixed multihash string representation
	  var mh = new Buffer(bs58.decode(hash));
	  var size = new Buffer(varint.encode(mh.length));
	  return Buffer.concat([size, mh]);
	}

	function buf2mh(buf) {
	  var size = varint.decode(buf);
	  var address = buf.slice(varint.decode.bytes);

	  if (address.length !== size) {
	    throw new Error('inconsistent lengths');
	  }

	  return bs58.encode(address);
	}

/***/ },
/* 313 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	exports.names = {
	  sha1: 0x11,
	  'sha2-256': 0x12,
	  'sha2-512': 0x13,
	  sha3: 0x14,
	  blake2b: 0x40,
	  blake2s: 0x41
	};

	exports.codes = {
	  0x11: 'sha1',
	  0x12: 'sha2-256',
	  0x13: 'sha2-512',
	  0x14: 'sha3',
	  0x40: 'blake2b',
	  0x41: 'blake2s'
	};

	exports.defaultLengths = {
	  0x11: 20,
	  0x12: 32,
	  0x13: 64,
	  0x14: 64,
	  0x40: 64,
	  0x41: 32
	};

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var Sandwich = __webpack_require__(359).SandwichStream
	var stream = __webpack_require__(3)
	var inherits = __webpack_require__(1)
	var isStream = __webpack_require__(277)

	var CRNL = '\r\n'

	module.exports = Multipart

	/**
	 * Multipart request constructor.
	 * @constructor
	 * @param {object} [opts]
	 * @param {string} [opts.boundary] - The boundary to be used. If omitted one is generated.
	 * @returns {function} Returns the multipart stream.
	 */
	function Multipart(boundary) {
		if(!this instanceof Multipart) {
			return new Multipart(boundary)
		}

		this.boundary = boundary || Math.random().toString(36).slice(2)

		Sandwich.call(this, {
			head: '--' + this.boundary + CRNL,
			tail: CRNL + '--' + this.boundary + '--',
			separator: CRNL + '--' + this.boundary + CRNL
		})

		this._add = this.add
		this.add = this.addPart
	}

	inherits(Multipart, Sandwich)

	/**
	 * Adds a new part to the request.
	 * @param {object} [part={}]
	 * @param {object} [part.headers={}]
	 * @param {string|buffer|stream} [part.body=\r\n]
	 * @returns {function} Returns the multipart stream.
	 */
	Multipart.prototype.addPart = function(part) {
		part = part || {}
		var partStream = new stream.PassThrough()

		if(part.headers) {
			for(var key in part.headers) {
				var header = part.headers[key]
				partStream.write(key + ': ' + header + CRNL)
			}
		}

		partStream.write(CRNL)

		if(isStream(part.body)) {
			part.body.pipe(partStream)
		} else {
			partStream.end(part.body)
		}

		this._add(partStream)
	}


/***/ },
/* 315 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(315);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(10).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(19).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }

	      if (state.needReadable)
	        emitReadable(stream);

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(19).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;

	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }

	    if (state.length === 0)
	      endReadable(this);

	    return ret;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;

	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;

	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}

	function emitReadable_(stream) {
	  stream.emit('readable');
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }

	  function onend() {
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);

	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}

	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;

	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }

	  while (state.pipesCount && null !== (chunk = src.read())) {

	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);

	    src.emit('data', chunk);

	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }

	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;

	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }

	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}

	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};

	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};

	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;

	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }

	  var paused = startPaused || false;
	  var readable = false;

	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;

	  stream.on('readable', function() {
	    readable = true;

	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);

	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });

	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };

	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };

	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(92);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  var ts = this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(92);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);

	  return ret;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;

	    doWrite(stream, state, len, chunk, encoding, cb);

	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }

	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(317)


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	var Transform = __webpack_require__(319)
	  , inherits  = __webpack_require__(4).inherits
	  , xtend     = __webpack_require__(35)

	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}

	inherits(DestroyableTransform, Transform)

	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}

	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}


	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }

	    if (typeof transform != 'function')
	      transform = noop

	    if (typeof flush != 'function')
	      flush = null

	    return construct(options, transform, flush)
	  }
	}


	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)

	    this.options = xtend(options, override)

	    DestroyableTransform.call(this, this.options)
	  }

	  inherits(Through2, DestroyableTransform)

	  Through2.prototype._transform = transform

	  if (flush)
	    Through2.prototype._flush = flush

	  return Through2
	})


	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var JSONStorage, KEY_FOR_EMPTY_STRING, LocalStorage, MetaKey, QUOTA_EXCEEDED_ERR, StorageEvent, _emptyDirectory, _escapeKey, _rm, createMap, events, fs, path, writeSync,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  path = __webpack_require__(12);

	  fs = __webpack_require__(11);

	  events = __webpack_require__(10);

	  writeSync = __webpack_require__(385).sync;

	  KEY_FOR_EMPTY_STRING = '---.EMPTY_STRING.---';

	  _emptyDirectory = function(target) {
	    var i, len, p, ref, results;
	    ref = fs.readdirSync(target);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      p = ref[i];
	      results.push(_rm(path.join(target, p)));
	    }
	    return results;
	  };

	  _rm = function(target) {
	    if (fs.statSync(target).isDirectory()) {
	      _emptyDirectory(target);
	      return fs.rmdirSync(target);
	    } else {
	      return fs.unlinkSync(target);
	    }
	  };

	  _escapeKey = function(key) {
	    var newKey;
	    if (key === '') {
	      newKey = KEY_FOR_EMPTY_STRING;
	    } else {
	      newKey = key.toString();
	    }
	    return newKey;
	  };

	  QUOTA_EXCEEDED_ERR = (function(superClass) {
	    extend(QUOTA_EXCEEDED_ERR, superClass);

	    function QUOTA_EXCEEDED_ERR(message) {
	      this.message = message != null ? message : 'Unknown error.';
	      if (Error.captureStackTrace != null) {
	        Error.captureStackTrace(this, this.constructor);
	      }
	      this.name = this.constructor.name;
	    }

	    QUOTA_EXCEEDED_ERR.prototype.toString = function() {
	      return this.name + ": " + this.message;
	    };

	    return QUOTA_EXCEEDED_ERR;

	  })(Error);

	  StorageEvent = (function() {
	    function StorageEvent(key1, oldValue1, newValue1, url, storageArea) {
	      this.key = key1;
	      this.oldValue = oldValue1;
	      this.newValue = newValue1;
	      this.url = url;
	      this.storageArea = storageArea != null ? storageArea : 'localStorage';
	    }

	    return StorageEvent;

	  })();

	  MetaKey = (function() {
	    function MetaKey(key1, index1) {
	      this.key = key1;
	      this.index = index1;
	      if (!(this instanceof MetaKey)) {
	        return new MetaKey(this.key, this.index);
	      }
	    }

	    return MetaKey;

	  })();

	  createMap = function() {
	    var Map;
	    Map = function() {};
	    Map.prototype = Object.create(null);
	    return new Map();
	  };

	  LocalStorage = (function(superClass) {
	    var instanceMap;

	    extend(LocalStorage, superClass);

	    instanceMap = {};

	    function LocalStorage(_location, quota) {
	      this._location = _location;
	      this.quota = quota != null ? quota : 5 * 1024 * 1024;
	      if (!(this instanceof LocalStorage)) {
	        return new LocalStorage(this._location, this.quota);
	      }
	      this._location = path.resolve(this._location);
	      if (instanceMap[this._location] != null) {
	        return instanceMap[this._location];
	      }
	      this.length = 0;
	      this._bytesInUse = 0;
	      this._keys = [];
	      this._metaKeyMap = createMap();
	      this._eventUrl = "pid:" + process.pid;
	      this._init();
	      this._QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;
	      instanceMap[this._location] = this;
	      return instanceMap[this._location];
	    }

	    LocalStorage.prototype._init = function() {
	      var _MetaKey, _decodedKey, _keys, error, i, index, k, len, stat;
	      try {
	        stat = fs.statSync(this._location);
	        if ((stat != null) && !stat.isDirectory()) {
	          throw new Error("A file exists at the location '" + this._location + "' when trying to create/open localStorage");
	        }
	        this._bytesInUse = 0;
	        this.length = 0;
	        _keys = fs.readdirSync(this._location);
	        for (index = i = 0, len = _keys.length; i < len; index = ++i) {
	          k = _keys[index];
	          _decodedKey = decodeURIComponent(k);
	          this._keys.push(_decodedKey);
	          _MetaKey = new MetaKey(k, index);
	          this._metaKeyMap[_decodedKey] = _MetaKey;
	          stat = this._getStat(k);
	          if ((stat != null ? stat.size : void 0) != null) {
	            _MetaKey.size = stat.size;
	            this._bytesInUse += stat.size;
	          }
	        }
	        this.length = _keys.length;
	      } catch (error) {
	        fs.mkdirSync(this._location);
	      }
	    };

	    LocalStorage.prototype.setItem = function(key, value) {
	      var encodedKey, evnt, existsBeforeSet, filename, hasListeners, metaKey, oldLength, oldValue, valueString, valueStringLength;
	      hasListeners = events.EventEmitter.listenerCount(this, 'storage');
	      oldValue = null;
	      if (hasListeners) {
	        oldValue = this.getItem(key);
	      }
	      key = _escapeKey(key);
	      encodedKey = encodeURIComponent(key);
	      filename = path.join(this._location, encodedKey);
	      valueString = value.toString();
	      valueStringLength = valueString.length;
	      metaKey = this._metaKeyMap[key];
	      existsBeforeSet = !!metaKey;
	      if (existsBeforeSet) {
	        oldLength = metaKey.size;
	      } else {
	        oldLength = 0;
	      }
	      if (this._bytesInUse - oldLength + valueStringLength > this.quota) {
	        throw new QUOTA_EXCEEDED_ERR();
	      }
	      writeSync(filename, valueString, 'utf8');
	      if (!existsBeforeSet) {
	        metaKey = new MetaKey(encodedKey, (this._keys.push(key)) - 1);
	        metaKey.size = valueStringLength;
	        this._metaKeyMap[key] = metaKey;
	        this.length += 1;
	        this._bytesInUse += valueStringLength;
	      }
	      if (hasListeners) {
	        evnt = new StorageEvent(key, oldValue, value, this._eventUrl);
	        return this.emit('storage', evnt);
	      }
	    };

	    LocalStorage.prototype.getItem = function(key) {
	      var filename, metaKey;
	      key = _escapeKey(key);
	      metaKey = this._metaKeyMap[key];
	      if (!!metaKey) {
	        filename = path.join(this._location, metaKey.key);
	        return fs.readFileSync(filename, 'utf8');
	      } else {
	        return null;
	      }
	    };

	    LocalStorage.prototype._getStat = function(key) {
	      var error, filename;
	      key = _escapeKey(key);
	      filename = path.join(this._location, encodeURIComponent(key));
	      try {
	        return fs.statSync(filename);
	      } catch (error) {
	        return null;
	      }
	    };

	    LocalStorage.prototype.removeItem = function(key) {
	      var evnt, filename, hasListeners, k, meta, metaKey, oldValue, ref, v;
	      key = _escapeKey(key);
	      metaKey = this._metaKeyMap[key];
	      if (!!metaKey) {
	        hasListeners = events.EventEmitter.listenerCount(this, 'storage');
	        oldValue = null;
	        if (hasListeners) {
	          oldValue = this.getItem(key);
	        }
	        delete this._metaKeyMap[key];
	        this.length -= 1;
	        this._bytesInUse -= metaKey.size;
	        filename = path.join(this._location, metaKey.key);
	        this._keys.splice(metaKey.index, 1);
	        ref = this._metaKeyMap;
	        for (k in ref) {
	          v = ref[k];
	          meta = this._metaKeyMap[k];
	          if (meta.index > metaKey.index) {
	            meta.index -= 1;
	          }
	        }
	        _rm(filename);
	        if (hasListeners) {
	          evnt = new StorageEvent(key, oldValue, null, this._eventUrl);
	          return this.emit('storage', evnt);
	        }
	      }
	    };

	    LocalStorage.prototype.key = function(n) {
	      return this._keys[n];
	    };

	    LocalStorage.prototype.clear = function() {
	      var evnt;
	      _emptyDirectory(this._location);
	      this._metaKeyMap = createMap();
	      this._keys = [];
	      this.length = 0;
	      this._bytesInUse = 0;
	      if (events.EventEmitter.listenerCount(this, 'storage')) {
	        evnt = new StorageEvent(null, null, null, this._eventUrl);
	        return this.emit('storage', evnt);
	      }
	    };

	    LocalStorage.prototype._getBytesInUse = function() {
	      return this._bytesInUse;
	    };

	    LocalStorage.prototype._deleteLocation = function() {
	      delete instanceMap[this._location];
	      _rm(this._location);
	      this._metaKeyMap = {};
	      this._keys = [];
	      this.length = 0;
	      return this._bytesInUse = 0;
	    };

	    return LocalStorage;

	  })(events.EventEmitter);

	  JSONStorage = (function(superClass) {
	    extend(JSONStorage, superClass);

	    function JSONStorage() {
	      return JSONStorage.__super__.constructor.apply(this, arguments);
	    }

	    JSONStorage.prototype.setItem = function(key, value) {
	      var newValue;
	      newValue = JSON.stringify(value);
	      return JSONStorage.__super__.setItem.call(this, key, newValue);
	    };

	    JSONStorage.prototype.getItem = function(key) {
	      return JSON.parse(JSONStorage.__super__.getItem.call(this, key));
	    };

	    return JSONStorage;

	  })(LocalStorage);

	  exports.LocalStorage = LocalStorage;

	  exports.JSONStorage = JSONStorage;

	  exports.QUOTA_EXCEEDED_ERR = QUOTA_EXCEEDED_ERR;

	}).call(this);


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
	// Fedor, you are amazing.

	var asn1 = __webpack_require__(29)

	var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('modulus').int(),
	    this.key('publicExponent').int(),
	    this.key('privateExponent').int(),
	    this.key('prime1').int(),
	    this.key('prime2').int(),
	    this.key('exponent1').int(),
	    this.key('exponent2').int(),
	    this.key('coefficient').int()
	  )
	})
	exports.RSAPrivateKey = RSAPrivateKey

	var RSAPublicKey = asn1.define('RSAPublicKey', function () {
	  this.seq().obj(
	    this.key('modulus').int(),
	    this.key('publicExponent').int()
	  )
	})
	exports.RSAPublicKey = RSAPublicKey

	var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPublicKey').bitstr()
	  )
	})
	exports.PublicKey = PublicKey

	var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
	  this.seq().obj(
	    this.key('algorithm').objid(),
	    this.key('none').null_().optional(),
	    this.key('curve').objid().optional(),
	    this.key('params').seq().obj(
	      this.key('p').int(),
	      this.key('q').int(),
	      this.key('g').int()
	    ).optional()
	  )
	})

	var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('algorithm').use(AlgorithmIdentifier),
	    this.key('subjectPrivateKey').octstr()
	  )
	})
	exports.PrivateKey = PrivateKeyInfo
	var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
	  this.seq().obj(
	    this.key('algorithm').seq().obj(
	      this.key('id').objid(),
	      this.key('decrypt').seq().obj(
	        this.key('kde').seq().obj(
	          this.key('id').objid(),
	          this.key('kdeparams').seq().obj(
	            this.key('salt').octstr(),
	            this.key('iters').int()
	          )
	        ),
	        this.key('cipher').seq().obj(
	          this.key('algo').objid(),
	          this.key('iv').octstr()
	        )
	      )
	    ),
	    this.key('subjectPrivateKey').octstr()
	  )
	})

	exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

	var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('p').int(),
	    this.key('q').int(),
	    this.key('g').int(),
	    this.key('pub_key').int(),
	    this.key('priv_key').int()
	  )
	})
	exports.DSAPrivateKey = DSAPrivateKey

	exports.DSAparam = asn1.define('DSAparam', function () {
	  this.int()
	})
	var ECPrivateKey = asn1.define('ECPrivateKey', function () {
	  this.seq().obj(
	    this.key('version').int(),
	    this.key('privateKey').octstr(),
	    this.key('parameters').optional().explicit(0).use(ECParameters),
	    this.key('publicKey').optional().explicit(1).bitstr()
	  )
	})
	exports.ECPrivateKey = ECPrivateKey
	var ECParameters = asn1.define('ECParameters', function () {
	  this.choice({
	    namedCurve: this.objid()
	  })
	})

	exports.signature = asn1.define('signature', function () {
	  this.seq().obj(
	    this.key('r').int(),
	    this.key('s').int()
	  )
	})


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	// adapted from https://github.com/apatil/pemstrip
	var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
	var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
	var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
	var evp = __webpack_require__(258)
	var ciphers = __webpack_require__(79)
	module.exports = function (okey, password) {
	  var key = okey.toString()
	  var match = key.match(findProc)
	  var decrypted
	  if (!match) {
	    var match2 = key.match(fullRegex)
	    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
	  } else {
	    var suite = 'aes' + match[1]
	    var iv = new Buffer(match[2], 'hex')
	    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
	    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
	    var out = []
	    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
	    out.push(cipher.update(cipherText))
	    out.push(cipher.final())
	    decrypted = Buffer.concat(out)
	  }
	  var tag = key.match(startRegex)[1] + ' KEY'
	  return {
	    tag: tag,
	    data: decrypted
	  }
	}


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var parse = __webpack_require__(325)
	var stringify = __webpack_require__(326)

	module.exports = parse
	module.exports.parse = parse
	module.exports.stringify = stringify


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var tokenize = __webpack_require__(327)
	var MAX_RANGE = 0x1FFFFFFF

	var onfieldoptions = function (tokens) {
	  var opts = {}

	  while (tokens.length) {
	    switch (tokens[0]) {
	      case '[':
	      case ',':
	        tokens.shift()
	        var name = tokens.shift()
	        if (name === '(') {       // handling [(A) = B]
	          name = tokens.shift()
	          tokens.shift()          // remove the end of bracket
	        }
	        if (tokens[0] !== '=') throw new Error('Unexpected token in field options: ' + tokens[0])
	        tokens.shift()
	        if (tokens[0] === ']') throw new Error('Unexpected ] in field option')
	        opts[name] = tokens.shift()
	        break
	      case ']':
	        tokens.shift()
	        return opts

	      default:
	        throw new Error('Unexpected token in field options: ' + tokens[0])
	    }
	  }

	  throw new Error('No closing tag for field options')
	}

	var onfield = function (tokens) {
	  var field = {
	    name: null,
	    type: null,
	    tag: 0,
	    map: null,
	    oneof: null,
	    required: false,
	    repeated: false,
	    options: {}
	  }

	  while (tokens.length) {
	    switch (tokens[0]) {
	      case '=':
	        tokens.shift()
	        field.tag = Number(tokens.shift())
	        break

	      case 'map':
	        field.type = 'map'
	        field.map = {from: null, to: null}
	        tokens.shift()
	        if (tokens[0] !== '<') throw new Error('Unexpected token in map type: ' + tokens[0])
	        tokens.shift()
	        field.map.from = tokens.shift()
	        if (tokens[0] !== ',') throw new Error('Unexpected token in map type: ' + tokens[0])
	        tokens.shift()
	        field.map.to = tokens.shift()
	        if (tokens[0] !== '>') throw new Error('Unexpected token in map type: ' + tokens[0])
	        tokens.shift()
	        field.name = tokens.shift()
	        break

	      case 'repeated':
	      case 'required':
	      case 'optional':
	        var t = tokens.shift()
	        field.required = t === 'required'
	        field.repeated = t === 'repeated'
	        field.type = tokens.shift()
	        field.name = tokens.shift()
	        break

	      case '[':
	        field.options = onfieldoptions(tokens)
	        break

	      case ';':
	        tokens.shift()
	        return field

	      default:
	        throw new Error('Unexpected token in message field: ' + tokens[0])
	    }
	  }

	  throw new Error('No ; found for message field')
	}

	var onmessagebody = function (tokens) {
	  var body = {
	    enums: [],
	    messages: [],
	    fields: [],
	    extensions: null
	  }

	  while (tokens.length) {
	    switch (tokens[0]) {
	      case 'map':
	      case 'repeated':
	      case 'optional':
	      case 'required':
	        body.fields.push(onfield(tokens))
	        break

	      case 'enum':
	        body.enums.push(onenum(tokens))
	        break

	      case 'message':
	        body.messages.push(onmessage(tokens))
	        break

	      case 'extensions':
	        body.extensions = onextensions(tokens)
	        break

	      case 'oneof':
	        tokens.shift()
	        var name = tokens.shift()
	        if (tokens[0] !== '{') throw new Error('Unexpected token in oneof: ' + tokens[0])
	        tokens.shift()
	        while (tokens[0] !== '}') {
	          tokens.unshift('optional')
	          var field = onfield(tokens)
	          field.oneof = name
	          body.fields.push(field)
	        }
	        tokens.shift()
	        break

	      case ';':
	        tokens.shift()
	        break

	      default:
	        // proto3 does not require the use of optional/required, assumed as optional
	        // "singular: a well-formed message can have zero or one of this field (but not more than one)."
	        // https://developers.google.com/protocol-buffers/docs/proto3#specifying-field-rules
	        tokens.unshift('optional')
	        body.fields.push(onfield(tokens))
	    }
	  }

	  return body
	}

	var onextend = function (tokens) {
	  var out = {
	    name: tokens[1],
	    message: onmessage(tokens)
	  }
	  return out
	}

	var onextensions = function (tokens) {
	  tokens.shift()
	  var from = Number(tokens.shift())
	  if (isNaN(from)) throw new Error('Invalid from in extensions definition')
	  if (tokens.shift() !== 'to') throw new Error("Expected keyword 'to' in extensions definition")
	  var to = tokens.shift()
	  if (to === 'max') to = MAX_RANGE
	  to = Number(to)
	  if (isNaN(to)) throw new Error('Invalid to in extensions definition')
	  if (tokens.shift() !== ';') throw new Error('Missing ; in extensions definition')
	  return {from: from, to: to}
	}
	var onmessage = function (tokens) {
	  tokens.shift()

	  var lvl = 1
	  var body = []
	  var msg = {
	    name: tokens.shift(),
	    enums: [],
	    messages: [],
	    fields: []
	  }

	  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
	  tokens.shift()

	  while (tokens.length) {
	    if (tokens[0] === '{') lvl++
	    else if (tokens[0] === '}') lvl--

	    if (!lvl) {
	      tokens.shift()
	      body = onmessagebody(body)
	      msg.enums = body.enums
	      msg.messages = body.messages
	      msg.fields = body.fields
	      msg.extensions = body.extensions
	      return msg
	    }

	    body.push(tokens.shift())
	  }

	  if (lvl) throw new Error('No closing tag for message')
	}

	var onpackagename = function (tokens) {
	  tokens.shift()
	  var name = tokens.shift()
	  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])
	  tokens.shift()
	  return name
	}

	var onsyntaxversion = function (tokens) {
	  tokens.shift()

	  if (tokens[0] !== '=') throw new Error('Expected = but found ' + tokens[0])
	  tokens.shift()

	  var version = tokens.shift()
	  switch (version) {
	    case '"proto2"':
	      version = 2
	      break

	    case '"proto3"':
	      version = 3
	      break

	    default:
	      throw new Error('Expected protobuf syntax version but found ' + version)
	  }

	  if (tokens[0] !== ';') throw new Error('Expected ; but found ' + tokens[0])
	  tokens.shift()

	  return version
	}

	var onenumvalue = function (tokens) {
	  if (tokens.length < 4) throw new Error('Invalid enum value: ' + tokens.slice(0, 3).join(' '))
	  if (tokens[1] !== '=') throw new Error('Expected = but found ' + tokens[1])
	  if (tokens[3] !== ';') throw new Error('Expected ; but found ' + tokens[1])

	  var name = tokens.shift()
	  tokens.shift()

	  var value = Number(tokens.shift())
	  tokens.shift()

	  return {
	    name: name,
	    value: value
	  }
	}

	var onenum = function (tokens) {
	  tokens.shift()

	  var e = {
	    name: tokens.shift(),
	    values: {}
	  }

	  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
	  tokens.shift()

	  while (tokens.length) {
	    if (tokens[0] === '}') {
	      tokens.shift()
	      // there goes optional semicolon after the enclosing "}"
	      if (tokens[0] === ';') tokens.shift()
	      return e
	    }
	    if (tokens[0] === 'option') {
	      // just skip "option allow_alias = true;"
	      while (tokens.shift() !== ';') {
	        // do nothing
	      }
	    }
	    var val = onenumvalue(tokens)
	    e.values[val.name] = val.value
	  }

	  throw new Error('No closing tag for enum')
	}

	var onoption = function (tokens) {
	  var name = null
	  var value = null

	  var parse = function (value) {
	    if (value === 'true') return true
	    if (value === 'false') return false
	    return value.replace(/^"+|"+$/gm, '')
	  }

	  while (tokens.length) {
	    if (tokens[0] === ';') {
	      tokens.shift()
	      return {name: name, value: value}
	    }
	    switch (tokens[0]) {
	      case 'option':
	        tokens.shift()

	        var hasBracket = tokens[0] === '('
	        if (hasBracket) tokens.shift()

	        name = tokens.shift()

	        if (hasBracket) {
	          if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
	          tokens.shift()
	        }
	        break

	      case '=':
	        tokens.shift()
	        if (name === null) throw new Error('Expected key for option with value: ' + tokens[0])
	        value = parse(tokens.shift())

	        if (name === 'optimize_for' && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {
	          throw new Error('Unexpected value for option optimize_for: ' + value)
	        } else if (value === '{') {
	          // option foo = {bar: baz}
	          value = onoptionMap(tokens)
	        }
	        break

	      default:
	        throw new Error('Unexpected token in option: ' + tokens[0])
	    }
	  }
	}

	var onoptionMap = function (tokens) {
	  var parse = function (value) {
	    if (value === 'true') return true
	    if (value === 'false') return false
	    return value.replace(/^"+|"+$/gm, '')
	  }

	  var map = {}

	  while (tokens.length) {
	    if (tokens[0] === '}') {
	      tokens.shift()
	      return map
	    }

	    var hasBracket = tokens[0] === '('
	    if (hasBracket) tokens.shift()

	    var key = tokens.shift()
	    if (hasBracket) {
	      if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
	      tokens.shift()
	    }

	    var value = null

	    switch (tokens[0]) {
	      case ':':
	        if (map[key] !== undefined) throw new Error('Duplicate option map key ' + key)

	        tokens.shift()

	        value = parse(tokens.shift())

	        if (value === '{') {
	          // option foo = {bar: baz}
	          value = onoptionMap(tokens)
	        }

	        map[key] = value
	        break

	      case '{':
	        tokens.shift()
	        value = onoptionMap(tokens)

	        if (map[key] === undefined) map[key] = []
	        if (!Array.isArray(map[key])) throw new Error('Duplicate option map key ' + key)

	        map[key].push(value)
	        break

	      default:
	        throw new Error('Unexpected token in option map: ' + tokens[0])
	    }
	  }

	  throw new Error('No closing tag for option map')
	}

	var onimport = function (tokens) {
	  tokens.shift()
	  var file = tokens.shift().replace(/^"+|"+$/gm, '')

	  if (tokens[0] !== ';') throw new Error('Unexpected token: ' + tokens[0] + '. Expected ";"')

	  tokens.shift()
	  return file
	}

	var onservice = function (tokens) {
	  tokens.shift()

	  var service = {
	    name: tokens.shift(),
	    methods: [],
	    options: {}
	  }

	  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
	  tokens.shift()

	  while (tokens.length) {
	    if (tokens[0] === '}') {
	      tokens.shift()
	      // there goes optional semicolon after the enclosing "}"
	      if (tokens[0] === ';') tokens.shift()
	      return service
	    }

	    switch (tokens[0]) {
	      case 'option':
	        var opt = onoption(tokens)
	        if (service.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)
	        service.options[opt.name] = opt.value
	        break
	      case 'rpc':
	        service.methods.push(onrpc(tokens))
	        break
	      default:
	        throw new Error('Unexpected token in service: ' + tokens[0])
	    }
	  }

	  throw new Error('No closing tag for service')
	}

	var onrpc = function (tokens) {
	  tokens.shift()

	  var rpc = {
	    name: tokens.shift(),
	    input_type: null,
	    output_type: null,
	    client_streaming: false,
	    server_streaming: false,
	    options: {}
	  }

	  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])
	  tokens.shift()

	  if (tokens[0] === 'stream') {
	    tokens.shift()
	    rpc.client_streaming = true
	  }

	  rpc.input_type = tokens.shift()

	  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
	  tokens.shift()

	  if (tokens[0] !== 'returns') throw new Error('Expected returns but found ' + tokens[0])
	  tokens.shift()

	  if (tokens[0] !== '(') throw new Error('Expected ( but found ' + tokens[0])
	  tokens.shift()

	  if (tokens[0] === 'stream') {
	    tokens.shift()
	    rpc.server_streaming = true
	  }

	  rpc.output_type = tokens.shift()

	  if (tokens[0] !== ')') throw new Error('Expected ) but found ' + tokens[0])
	  tokens.shift()

	  if (tokens[0] === ';') {
	    tokens.shift()
	    return rpc
	  }

	  if (tokens[0] !== '{') throw new Error('Expected { but found ' + tokens[0])
	  tokens.shift()

	  while (tokens.length) {
	    if (tokens[0] === '}') {
	      tokens.shift()
	      // there goes optional semicolon after the enclosing "}"
	      if (tokens[0] === ';') tokens.shift()
	      return rpc
	    }

	    if (tokens[0] === 'option') {
	      var opt = onoption(tokens)
	      if (rpc.options[opt.name] !== undefined) throw new Error('Duplicate option ' + opt.name)
	      rpc.options[opt.name] = opt.value
	    } else {
	      throw new Error('Unexpected token in rpc options: ' + tokens[0])
	    }
	  }

	  throw new Error('No closing tag for rpc')
	}

	var parse = function (buf) {
	  var tokens = tokenize(buf.toString())
	  // check for isolated strings in tokens by looking for opening quote
	  for (var i = 0; i < tokens.length; i++) {
	    if (/^(\"|\')([^\'\"]*)$/.test(tokens[i])) {
	      var j
	      if (tokens[i].length === 1) {
	        j = i + 1
	      } else {
	        j = i
	      }
	      // look ahead for the closing quote and collapse all
	      // in-between tokens into a single token
	      for (j; j < tokens.length; j++) {
	        if (/^([^\'\"]*)(\"|\')$/.test(tokens[j])) {
	          tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join('')).concat(tokens.slice(j + 1))
	          break
	        }
	      }
	    }
	  }
	  var schema = {
	    syntax: 3,
	    package: null,
	    imports: [],
	    enums: [],
	    messages: [],
	    options: {},
	    extends: []
	  }

	  var firstline = true

	  while (tokens.length) {
	    switch (tokens[0]) {
	      case 'package':
	        schema.package = onpackagename(tokens)
	        break

	      case 'syntax':
	        if (!firstline) throw new Error('Protobuf syntax version should be first thing in file')
	        schema.syntax = onsyntaxversion(tokens)
	        break

	      case 'message':
	        schema.messages.push(onmessage(tokens))
	        break

	      case 'enum':
	        schema.enums.push(onenum(tokens))
	        break

	      case 'option':
	        var opt = onoption(tokens)
	        if (schema.options[opt.name]) throw new Error('Duplicate option ' + opt.name)
	        schema.options[opt.name] = opt.value
	        break

	      case 'import':
	        schema.imports.push(onimport(tokens))
	        break

	      case 'extend':
	        schema.extends.push(onextend(tokens))
	        break

	      case 'service':
	        if (!schema.services) schema.services = []
	        schema.services.push(onservice(tokens))
	        break

	      default:
	        throw new Error('Unexpected token: ' + tokens[0])
	    }
	    firstline = false
	  }

	  // now iterate over messages and propagate extends
	  schema.extends.forEach(function (ext) {
	    schema.messages.forEach(function (msg) {
	      if (msg.name === ext.name) {
	        ext.message.fields.forEach(function (field) {
	          if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {
	            throw new Error(msg.name + ' does not declare ' + field.tag + ' as an extension number')
	          }
	          msg.fields.push(field)
	        })
	      }
	    })
	  })

	  return schema
	}

	module.exports = parse


/***/ },
/* 326 */
/***/ function(module, exports) {

	var onfield = function (f, result) {
	  var prefix = f.repeated ? 'repeated' : f.required ? 'required' : 'optional'
	  if (f.type === 'map') prefix = 'map<' + f.map.from + ',' + f.map.to + '>'
	  if (f.oneof) prefix = ''

	  var opts = Object.keys(f.options || {}).map(function (key) {
	    return key + ' = ' + f.options[key]
	  }).join(',')

	  if (opts) opts = ' [' + opts + ']'

	  result.push((prefix ? prefix + ' ' : '') + (f.map === 'map' ? '' : f.type + ' ') + f.name + ' = ' + f.tag + opts + ';')
	  return result
	}

	var onmessage = function (m, result) {
	  result.push('message ' + m.name + ' {')

	  if (!m.enums) m.enums = []
	  m.enums.forEach(function (e) {
	    result.push(onenum(e, []))
	  })

	  if (!m.messages) m.messages = []
	  m.messages.forEach(function (m) {
	    result.push(onmessage(m, []))
	  })

	  var oneofs = {}

	  if (!m.fields) m.fields = []
	  m.fields.forEach(function (f) {
	    if (f.oneof) {
	      if (!oneofs[f.oneof]) oneofs[f.oneof] = []
	      oneofs[f.oneof].push(onfield(f, []))
	    } else {
	      result.push(onfield(f, []))
	    }
	  })

	  Object.keys(oneofs).forEach(function (n) {
	    oneofs[n].unshift('oneof ' + n + ' {')
	    oneofs[n].push('}')
	    result.push(oneofs[n])
	  })

	  result.push('}', '')
	  return result
	}

	var onenum = function (e, result) {
	  result.push('enum ' + e.name + ' {')

	  var vals = Object.keys(e.values).map(function (key) {
	    return key + ' = ' + e.values[key] + ';'
	  })

	  result.push(vals)
	  result.push('}', '')
	  return result
	}

	var onoption = function (o, result) {
	  var keys = Object.keys(o)
	  keys.forEach(function (option) {
	    var v = o[option]

	    if (~option.indexOf('.')) option = '(' + option + ')'

	    var type = typeof v

	    if (type === 'object') {
	      v = onoptionMap(v, [])
	      if (v.length) result.push('option ' + option + ' = {', v, '};')
	    } else {
	      if (type === 'string' && option !== 'optimize_for') v = '"' + v + '"'
	      result.push('option ' + option + ' = ' + v + ';')
	    }
	  })
	  if (keys.length > 0) {
	    result.push('')
	  }

	  return result
	}

	var onoptionMap = function (o, result) {
	  var keys = Object.keys(o)
	  keys.forEach(function (k) {
	    var v = o[k]

	    var type = typeof v

	    if (type === 'object') {
	      if (Array.isArray(v)) {
	        v.forEach(function (v) {
	          v = onoptionMap(v, [])
	          if (v.length) result.push(k + ' {', v, '}')
	        })
	      } else {
	        v = onoptionMap(v, [])
	        if (v.length) result.push(k + ' {', v, '}')
	      }
	    } else {
	      if (type === 'string') v = '"' + v + '"'
	      result.push(k + ': ' + v)
	    }
	  })

	  return result
	}

	var onservices = function (s, result) {
	  result.push('service ' + s.name + ' {')

	  if (!s.options) s.options = {}

	  onoption(s.options, result)

	  if (!s.methods) s.methods = []
	  s.methods.forEach(function (m) {
	    result.push(onrpc(m, []))
	  })

	  result.push('}', '')
	  return result
	}

	var onrpc = function (rpc, result) {
	  var def = 'rpc ' + rpc.name + '('
	  if (rpc.client_streaming) def += 'stream '
	  def += rpc.input_type + ') returns ('
	  if (rpc.server_streaming) def += 'stream '
	  def += rpc.output_type + ')'

	  if (!rpc.options) rpc.options = {}

	  var options = onoption(rpc.options, [])
	  if (options.length > 1) {
	    result.push(def + ' {', options.slice(0, -1), '}')
	  } else {
	    result.push(def + ';')
	  }

	  return result
	}

	var indent = function (lvl) {
	  return function (line) {
	    if (Array.isArray(line)) return line.map(indent(lvl + '  ')).join('\n')
	    return lvl + line
	  }
	}

	module.exports = function (schema) {
	  var result = []

	  result.push('syntax = "proto' + schema.syntax + '";', '')

	  if (schema.package) result.push('package ' + schema.package + ';', '')

	  if (!schema.options) schema.options = {}

	  onoption(schema.options, result)

	  if (!schema.enums) schema.enums = []
	  schema.enums.forEach(function (e) {
	    onenum(e, result)
	  })

	  if (!schema.messages) schema.messages = []
	  schema.messages.forEach(function (m) {
	    onmessage(m, result)
	  })

	  if (schema.services) {
	    schema.services.forEach(function (s) {
	      onservices(s, result)
	    })
	  }

	  return result.map(indent('')).join('\n')
	}


/***/ },
/* 327 */
/***/ function(module, exports) {

	module.exports = function (sch) {
	  var noComments = function (line) {
	    var i = line.indexOf('//')
	    return i > -1 ? line.slice(0, i) : line
	  }

	  var noMultilineComments = function () {
	    var inside = false
	    return function (token) {
	      if (token === '/*') {
	        inside = true
	        return false
	      }
	      if (token === '*/') {
	        inside = false
	        return false
	      }
	      return !inside
	    }
	  }

	  var trim = function (line) {
	    return line.trim()
	  }

	  return sch
	    .replace(/([;,{}\(\)=\:\[\]<>]|\/\*|\*\/)/g, ' $1 ')
	    .split(/\n/)
	    .map(trim)
	    .filter(Boolean)
	    .map(noComments)
	    .map(trim)
	    .filter(Boolean)
	    .join('\n')
	    .split(/\s+|\n+/gm)
	    .filter(noMultilineComments())
	}


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable no-spaced-func */
	/* eslint-disable no-unexpected-multiline */
	var encodings = __webpack_require__(329)
	var varint = __webpack_require__(28)
	var genobj = __webpack_require__(262)
	var genfun = __webpack_require__(261)

	var skip = function (type, buffer, offset) {
	  switch (type) {
	    case 0:
	      varint.decode(buffer, offset)
	      return offset + varint.decode.bytes

	    case 1:
	      return offset + 8

	    case 2:
	      var len = varint.decode(buffer, offset)
	      return offset + varint.decode.bytes + len

	    case 3:
	    case 4:
	      throw new Error('Groups are not supported')

	    case 5:
	      return offset + 4
	  }

	  throw new Error('Unknown wire type: ' + type)
	}

	var defined = function (val) {
	  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
	}

	var isString = function (def) {
	  try {
	    return !!def && typeof JSON.parse(def) === 'string'
	  } catch (err) {
	    return false
	  }
	}

	var defaultValue = function (f, def) {
	  if (f.map) return '{}'
	  if (f.repeated) return '[]'

	  switch (f.type) {
	    case 'string':
	      return isString(def) ? def : '""'

	    case 'bool':
	      if (def === 'true') return 'true'
	      return 'false'

	    case 'float':
	    case 'double':
	    case 'sfixed32':
	    case 'fixed32':
	    case 'varint':
	    case 'enum':
	    case 'uint64':
	    case 'uint32':
	    case 'int64':
	    case 'int32':
	    case 'sint64':
	    case 'sint32':
	      return '' + Number(def || 0)

	    default:
	      return 'null'
	  }
	}

	module.exports = function (schema, extraEncodings) {
	  var messages = {}
	  var enums = {}
	  var cache = {}

	  var visit = function (schema, prefix) {
	    if (schema.enums) {
	      schema.enums.forEach(function (e) {
	        e.id = prefix + (prefix ? '.' : '') + e.name
	        enums[e.id] = e
	        visit(e, e.id)
	      })
	    }
	    if (schema.messages) {
	      schema.messages.forEach(function (m) {
	        m.id = prefix + (prefix ? '.' : '') + m.name
	        messages[m.id] = m
	        m.fields.forEach(function (f) {
	          if (!f.map) return

	          var name = 'Map_' + f.map.from + '_' + f.map.to
	          var map = {
	            name: name,
	            enums: [],
	            messages: [],
	            fields: [{
	              name: 'key',
	              type: f.map.from,
	              tag: 1,
	              repeated: false,
	              required: true
	            }, {
	              name: 'value',
	              type: f.map.to,
	              tag: 2,
	              repeated: false,
	              required: false
	            }],
	            extensions: null,
	            id: prefix + (prefix ? '.' : '') + name
	          }

	          if (!messages[map.id]) {
	            messages[map.id] = map
	            schema.messages.push(map)
	          }
	          f.type = name
	          f.repeated = true
	        })
	        visit(m, m.id)
	      })
	    }
	  }

	  visit(schema, '')

	  var compileEnum = function (e) {
	    var conditions = Object.keys(e.values)
	      .map(function (k) {
	        return 'val !== ' + parseInt(e.values[k], 10)
	      })
	      .join(' && ')

	    if (!conditions) conditions = 'true'

	    var encode = genfun()
	      ('function encode (val, buf, offset) {')
	        ('if (%s) throw new Error("Invalid enum value: "+val)', conditions)
	        ('varint.encode(val, buf, offset)')
	        ('encode.bytes = varint.encode.bytes')
	        ('return buf')
	      ('}')
	      .toFunction({
	        varint: varint
	      })

	    var decode = genfun()
	      ('function decode (buf, offset) {')
	        ('var val = varint.decode(buf, offset)')
	        ('if (%s) throw new Error("Invalid enum value: "+val)', conditions)
	        ('decode.bytes = varint.decode.bytes')
	        ('return val')
	      ('}')
	      .toFunction({
	        varint: varint
	      })

	    return encodings.make(0, encode, decode, varint.encodingLength)
	  }

	  var compileMessage = function (m, exports) {
	    m.messages.forEach(function (nested) {
	      exports[nested.name] = resolve(nested.name, m.id)
	    })

	    m.enums.forEach(function (val) {
	      exports[val.name] = val.values
	    })

	    exports.type = 2
	    exports.message = true
	    exports.name = m.name

	    var oneofs = {}

	    m.fields.forEach(function (f) {
	      if (!f.oneof) return
	      if (!oneofs[f.oneof]) oneofs[f.oneof] = []
	      oneofs[f.oneof].push(f.name)
	    })

	    var enc = m.fields.map(function (f) {
	      return resolve(f.type, m.id)
	    })

	    var forEach = function (fn) {
	      for (var i = 0; i < enc.length; i++) fn(enc[i], m.fields[i], genobj('obj', m.fields[i].name), i)
	    }

	    // compile encodingLength

	    var encodingLength = genfun()
	      ('function encodingLength (obj) {')
	        ('var length = 0')

	    Object.keys(oneofs).forEach(function (name) {
	      var msg = JSON.stringify('only one of the properties defined in oneof ' + name + ' can be set')
	      var cnt = oneofs[name]
	        .map(function (prop) {
	          return '+defined(' + genobj('obj', prop) + ')'
	        })
	        .join(' + ')

	      encodingLength('if ((%s) > 1) throw new Error(%s)', cnt, msg)
	    })

	    forEach(function (e, f, val, i) {
	      var packed = f.repeated && f.options && f.options.packed && f.options.packed !== 'false'
	      var hl = varint.encodingLength(f.tag << 3 | e.type)

	      if (f.required) encodingLength('if (!defined(%s)) throw new Error(%s)', val, JSON.stringify(f.name + ' is required'))
	      else encodingLength('if (defined(%s)) {', val)

	      if (f.map) {
	        encodingLength()
	          ('var tmp = Object.keys(%s)', val)
	          ('for (var i = 0; i < tmp.length; i++) {')
	            ('tmp[i] = {key: tmp[i], value: %s[tmp[i]]}', val)
	          ('}')
	        val = 'tmp'
	      }

	      if (packed) {
	        encodingLength()
	          ('var packedLen = 0')
	          ('for (var i = 0; i < %s.length; i++) {', val)
	            ('if (!defined(%s)) continue', val + '[i]')
	            ('var len = enc[%d].encodingLength(%s)', i, val + '[i]')
	            ('packedLen += len')

	        if (e.message) encodingLength('packedLen += varint.encodingLength(len)')

	        encodingLength('}')
	          ('if (packedLen) {')
	            ('length += %d + packedLen + varint.encodingLength(packedLen)', hl)
	          ('}')
	      } else {
	        if (f.repeated) {
	          encodingLength('for (var i = 0; i < %s.length; i++) {', val)
	          val += '[i]'
	          encodingLength('if (!defined(%s)) continue', val)
	        }

	        encodingLength('var len = enc[%d].encodingLength(%s)', i, val)
	        if (e.message) encodingLength('length += varint.encodingLength(len)')
	        encodingLength('length += %d + len', hl)
	        if (f.repeated) encodingLength('}')
	      }

	      if (!f.required) encodingLength('}')
	    })

	    encodingLength()
	        ('return length')
	      ('}')

	    encodingLength = encodingLength.toFunction({
	      defined: defined,
	      varint: varint,
	      enc: enc
	    })

	    // compile encode

	    var encode = genfun()
	      ('function encode (obj, buf, offset) {')
	        ('if (!offset) offset = 0')
	        ('if (!buf) buf = new Buffer(encodingLength(obj))')
	        ('var oldOffset = offset')

	    Object.keys(oneofs).forEach(function (name) {
	      var msg = JSON.stringify('only one of the properties defined in oneof ' + name + ' can be set')
	      var cnt = oneofs[name]
	        .map(function (prop) {
	          return '+defined(' + genobj('obj', prop) + ')'
	        })
	        .join(' + ')

	      encode('if ((%s) > 1) throw new Error(%s)', cnt, msg)
	    })

	    forEach(function (e, f, val, i) {
	      if (f.required) encode('if (!defined(%s)) throw new Error(%s)', val, JSON.stringify(f.name + ' is required'))
	      else encode('if (defined(%s)) {', val)

	      var packed = f.repeated && f.options && f.options.packed && f.options.packed !== 'false'
	      var p = varint.encode(f.tag << 3 | 2)
	      var h = varint.encode(f.tag << 3 | e.type)
	      var j

	      if (f.map) {
	        encode()
	          ('var tmp = Object.keys(%s)', val)
	          ('for (var i = 0; i < tmp.length; i++) {')
	            ('tmp[i] = {key: tmp[i], value: %s[tmp[i]]}', val)
	          ('}')
	        val = 'tmp'
	      }

	      if (packed) {
	        encode()
	          ('var packedLen = 0')
	          ('for (var i = 0; i < %s.length; i++) {', val)
	            ('if (!defined(%s)) continue', val + '[i]')
	            ('packedLen += enc[%d].encodingLength(%s)', i, val + '[i]')
	          ('}')

	        encode('if (packedLen) {')
	        for (j = 0; j < h.length; j++) encode('buf[offset++] = %d', p[j])
	        encode('varint.encode(packedLen, buf, offset)')
	        encode('offset += varint.encode.bytes')
	        encode('}')
	      }

	      if (f.repeated) {
	        encode('for (var i = 0; i < %s.length; i++) {', val)
	        val += '[i]'
	        encode('if (!defined(%s)) continue', val)
	      }

	      if (!packed) for (j = 0; j < h.length; j++) encode('buf[offset++] = %d', h[j])

	      if (e.message) {
	        encode('varint.encode(enc[%d].encodingLength(%s), buf, offset)', i, val)
	        encode('offset += varint.encode.bytes')
	      }

	      encode('enc[%d].encode(%s, buf, offset)', i, val)
	      encode('offset += enc[%d].encode.bytes', i)

	      if (f.repeated) encode('}')
	      if (!f.required) encode('}')
	    })

	    encode()
	        ('encode.bytes = offset - oldOffset')
	        ('return buf')
	      ('}')

	    encode = encode.toFunction({
	      encodingLength: encodingLength,
	      defined: defined,
	      varint: varint,
	      enc: enc,
	      Buffer: Buffer
	    })

	    // compile decode

	    var invalid = m.fields
	      .map(function (f, i) {
	        return f.required && '!found' + i
	      })
	      .filter(function (f) {
	        return f
	      })
	      .join(' || ')

	    var decode = genfun()

	    var objectKeys = []
	    forEach(function (e, f) {
	      var def = f.options && f.options.default
	      var resolved = resolve(f.type, m.id, false)
	      var vals = resolved && resolved.values

	      if (vals) { // is enum
	        if (f.repeated) {
	          objectKeys.push(genobj.property(f.name) + ': []')
	        } else {
	          def = (def && def in vals) ? vals[def] : vals[Object.keys(vals)[0]]
	          objectKeys.push(genobj.property(f.name) + ': ' + parseInt(def || 0, 10))
	        }
	        return
	      }

	      if (!f.oneof) {
	        objectKeys.push(genobj.property(f.name) + ': ' + defaultValue(f, def))
	      }
	    })

	    decode()
	      ('function decode (buf, offset, end) {')
	        ('if (!offset) offset = 0')
	        ('if (!end) end = buf.length')
	        ('if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")')
	        ('var oldOffset = offset')
	        ('var obj = {')

	    objectKeys.forEach(function (prop, i) {
	      decode(prop + (i === objectKeys.length - 1 ? '' : ','))
	    })

	    decode('}')

	    forEach(function (e, f, val, i) {
	      if (f.required) decode('var found%d = false', i)
	    })

	    decode('while (true) {')
	      ('if (end <= offset) {')
	        (invalid && 'if (%s) throw new Error("Decoded message is not valid")', invalid)
	        ('decode.bytes = offset - oldOffset')
	        ('return obj')
	      ('}')
	      ('var prefix = varint.decode(buf, offset)')
	      ('offset += varint.decode.bytes')
	      ('var tag = prefix >> 3')
	      ('switch (tag) {')

	    forEach(function (e, f, val, i) {
	      var packed = f.repeated && f.options && f.options.packed && f.options.packed !== 'false'

	      decode('case %d:', f.tag)

	      if (f.oneof) {
	        m.fields.forEach(function (otherField) {
	          if (otherField.oneof === f.oneof && f.name !== otherField.name) {
	            decode('delete %s', genobj('obj', otherField.name))
	          }
	        })
	      }

	      if (packed) {
	        decode()
	          ('var packedEnd = varint.decode(buf, offset)')
	          ('offset += varint.decode.bytes')
	          ('packedEnd += offset')
	          ('while (offset < packedEnd) {')
	      }

	      if (e.message) {
	        decode('var len = varint.decode(buf, offset)')
	        decode('offset += varint.decode.bytes')
	        if (f.map) {
	          decode('var tmp = enc[%d].decode(buf, offset, offset + len)', i)
	          decode('%s[tmp.key] = tmp.value', val)
	        } else if (f.repeated) {
	          decode('%s.push(enc[%d].decode(buf, offset, offset + len))', val, i)
	        } else {
	          decode('%s = enc[%d].decode(buf, offset, offset + len)', val, i)
	        }
	      } else {
	        if (f.repeated) {
	          decode('%s.push(enc[%d].decode(buf, offset))', val, i)
	        } else {
	          decode('%s = enc[%d].decode(buf, offset)', val, i)
	        }
	      }

	      decode('offset += enc[%d].decode.bytes', i)

	      if (packed) decode('}')
	      if (f.required) decode('found%d = true', i)
	      decode('break')
	    })

	    decode()
	          ('default:')
	          ('offset = skip(prefix & 7, buf, offset)')
	        ('}')
	      ('}')
	    ('}')

	    decode = decode.toFunction({
	      varint: varint,
	      skip: skip,
	      enc: enc
	    })

	    // end of compilation - return all the things

	    encode.bytes = decode.bytes = 0

	    exports.buffer = true
	    exports.encode = encode
	    exports.decode = decode
	    exports.encodingLength = encodingLength

	    return exports
	  }

	  var resolve = function (name, from, compile) {
	    if (extraEncodings && extraEncodings[name]) return extraEncodings[name]
	    if (encodings[name]) return encodings[name]

	    var m = (from ? from + '.' + name : name).split('.')
	      .map(function (part, i, list) {
	        return list.slice(0, i).concat(name).join('.')
	      })
	      .reverse()
	      .reduce(function (result, id) {
	        return result || messages[id] || enums[id]
	      }, null)

	    if (compile === false) return m
	    if (!m) throw new Error('Could not resolve ' + name)

	    if (m.values) return compileEnum(m)
	    return cache[m.id] || compileMessage(m, cache[m.id] = {})
	  }

	  return (schema.enums || []).concat((schema.messages || []).map(function (message) {
	    return resolve(message.id)
	  }))
	}


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var varint = __webpack_require__(28)
	var svarint = __webpack_require__(360)

	var encoder = function (type, encode, decode, encodingLength) {
	  encode.bytes = decode.bytes = 0

	  return {
	    type: type,
	    encode: encode,
	    decode: decode,
	    encodingLength: encodingLength
	  }
	}

	exports.make = encoder

	exports.bytes = (function (tag) {
	  var bufferLength = function (val) {
	    return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val)
	  }

	  var encodingLength = function (val) {
	    var len = bufferLength(val)
	    return varint.encodingLength(len) + len
	  }

	  var encode = function (val, buffer, offset) {
	    var oldOffset = offset
	    var len = bufferLength(val)

	    varint.encode(len, buffer, offset)
	    offset += varint.encode.bytes

	    if (Buffer.isBuffer(val)) val.copy(buffer, offset)
	    else buffer.write(val, offset, len)
	    offset += len

	    encode.bytes = offset - oldOffset
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var oldOffset = offset

	    var len = varint.decode(buffer, offset)
	    offset += varint.decode.bytes

	    var val = buffer.slice(offset, offset + len)
	    offset += val.length

	    decode.bytes = offset - oldOffset
	    return val
	  }

	  return encoder(2, encode, decode, encodingLength)
	})()

	exports.string = (function () {
	  var encodingLength = function (val) {
	    var len = Buffer.byteLength(val)
	    return varint.encodingLength(len) + len
	  }

	  var encode = function (val, buffer, offset) {
	    var oldOffset = offset
	    var len = Buffer.byteLength(val)

	    varint.encode(len, buffer, offset, 'utf-8')
	    offset += varint.encode.bytes

	    buffer.write(val, offset, len)
	    offset += len

	    encode.bytes = offset - oldOffset
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var oldOffset = offset

	    var len = varint.decode(buffer, offset)
	    offset += varint.decode.bytes

	    var val = buffer.toString('utf-8', offset, offset + len)
	    offset += len

	    decode.bytes = offset - oldOffset
	    return val
	  }

	  return encoder(2, encode, decode, encodingLength)
	})()

	exports.bool = (function () {
	  var encodingLength = function (val) {
	    return 1
	  }

	  var encode = function (val, buffer, offset) {
	    buffer[offset] = val ? 1 : 0
	    encode.bytes = 1
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var bool = buffer[offset] > 0
	    decode.bytes = 1
	    return bool
	  }

	  return encoder(0, encode, decode, encodingLength)
	})()

	exports.int32 = (function () {
	  var decode = function (buffer, offset) {
	    var val = varint.decode(buffer, offset)
	    decode.bytes = varint.decode.bytes
	    return val > 2147483647 ? val - 4294967296 : val
	  }

	  var encode = function (val, buffer, offset) {
	    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset)
	    encode.bytes = varint.encode.bytes
	    return buffer
	  }

	  var encodingLength = function (val) {
	    return varint.encodingLength(val < 0 ? val + 4294967296 : val)
	  }

	  return encoder(0, varint.encode, decode, encodingLength)
	})()

	exports.int64 = (function () {
	  var decode = function (buffer, offset) {
	    var val = varint.decode(buffer, offset)
	    if (val >= Math.pow(2, 63)) {
	      var limit = 9
	      while (buffer[offset + limit - 1] === 0xff) limit--
	      limit = limit || 9
	      var subset = new Buffer(limit)
	      buffer.copy(subset, 0, offset, offset + limit)
	      subset[limit - 1] = subset[limit - 1] & 0x7f
	      val = -1 * varint.decode(subset, 0)
	      decode.bytes = 10
	    } else {
	      decode.bytes = varint.decode.bytes
	    }
	    return val
	  }

	  var encode = function (val, buffer, offset) {
	    if (val < 0) {
	      var last = offset + 9
	      varint.encode(val * -1, buffer, offset)
	      offset += varint.encode.bytes - 1
	      buffer[offset] = buffer[offset] | 0x80
	      while (offset < last - 1) {
	        offset++
	        buffer[offset] = 0xff
	      }
	      buffer[last] = 0x01
	      encode.bytes = 10
	    } else {
	      varint.encode(val, buffer, offset)
	      encode.bytes = varint.encode.bytes
	    }
	    return buffer
	  }

	  var encodingLength = function (val) {
	    return val < 0 ? 10 : varint.encodingLength(val)
	  }

	  return encoder(0, encode, decode, encodingLength)
	})()

	exports.sint32 =
	exports.sint64 = (function () {
	  return encoder(0, svarint.encode, svarint.decode, svarint.encodingLength)
	})()

	exports.uint32 =
	exports.uint64 =
	exports.enum =
	exports.varint = (function () {
	  return encoder(0, varint.encode, varint.decode, varint.encodingLength)
	})()

	// we cannot represent these in javascript so we just use buffers
	exports.fixed64 =
	exports.sfixed64 = (function () {
	  var encodingLength = function (val) {
	    return 8
	  }

	  var encode = function (val, buffer, offset) {
	    val.copy(buffer, offset)
	    encode.bytes = 8
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var val = buffer.slice(offset, offset + 8)
	    decode.bytes = 8
	    return val
	  }

	  return encoder(1, encode, decode, encodingLength)
	})()

	exports.double = (function () {
	  var encodingLength = function (val) {
	    return 8
	  }

	  var encode = function (val, buffer, offset) {
	    buffer.writeDoubleLE(val, offset)
	    encode.bytes = 8
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var val = buffer.readDoubleLE(offset)
	    decode.bytes = 8
	    return val
	  }

	  return encoder(1, encode, decode, encodingLength)
	})()

	exports.fixed32 = (function () {
	  var encodingLength = function (val) {
	    return 4
	  }

	  var encode = function (val, buffer, offset) {
	    buffer.writeUInt32LE(val, offset)
	    encode.bytes = 4
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var val = buffer.readUInt32LE(offset)
	    decode.bytes = 4
	    return val
	  }

	  return encoder(5, encode, decode, encodingLength)
	})()

	exports.sfixed32 = (function () {
	  var encodingLength = function (val) {
	    return 4
	  }

	  var encode = function (val, buffer, offset) {
	    buffer.writeInt32LE(val, offset)
	    encode.bytes = 4
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var val = buffer.readInt32LE(offset)
	    decode.bytes = 4
	    return val
	  }

	  return encoder(5, encode, decode, encodingLength)
	})()

	exports.float = (function () {
	  var encodingLength = function (val) {
	    return 4
	  }

	  var encode = function (val, buffer, offset) {
	    buffer.writeFloatLE(val, offset)
	    encode.bytes = 4
	    return buffer
	  }

	  var decode = function (buffer, offset) {
	    var val = buffer.readFloatLE(offset)
	    decode.bytes = 4
	    return val
	  }

	  return encoder(5, encode, decode, encodingLength)
	})()


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var schema = __webpack_require__(324)
	var compile = __webpack_require__(328)

	module.exports = function (proto, opts) {
	  if (!opts) opts = {}
	  if (!proto) throw new Error('Pass in a .proto string or a protobuf-schema parsed object')

	  var sch = (typeof proto === 'object' && !Buffer.isBuffer(proto)) ? proto : schema.parse(proto)

	  // to not make toString,toJSON enumarable we make a fire-and-forget prototype
	  var Messages = function () {
	    var self = this

	    compile(sch, opts.encodings || {}).forEach(function (m) {
	      self[m.name] = m.values || m
	    })
	  }

	  Messages.prototype.toString = function () {
	    return schema.stringify(sch)
	  }

	  Messages.prototype.toJSON = function () {
	    return sch
	  }

	  return new Messages()
	}


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(9);
	if (typeof crypto.publicEncrypt !== 'function') {
	  crypto = __webpack_require__(48);
	}
	exports.publicEncrypt = crypto.publicEncrypt;
	exports.privateDecrypt = crypto.privateDecrypt;

	if (typeof crypto.privateEncrypt !== 'function') {
	  exports.privateEncrypt = __webpack_require__(48).privateEncrypt;
	} else {
	  exports.privateEncrypt = crypto.privateEncrypt;
	}

	if (typeof crypto.publicDecrypt !== 'function') {
	  exports.publicDecrypt = __webpack_require__(48).publicDecrypt;
	} else {
	  exports.publicDecrypt = crypto.publicDecrypt;
	}

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var parseKeys = __webpack_require__(94);
	var mgf = __webpack_require__(96);
	var xor = __webpack_require__(98);
	var bn = __webpack_require__(5);
	var crt = __webpack_require__(80);
	var createHash = __webpack_require__(32);
	var withPublic = __webpack_require__(97);
	module.exports = function privateDecrypt(private_key, enc, reverse) {
	  var padding;
	  if (private_key.padding) {
	    padding = private_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  
	  var key = parseKeys(private_key);
	  var k = key.modulus.byteLength();
	  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
	    throw new Error('decryption error');
	  }
	  var msg;
	  if (reverse) {
	    msg = withPublic(new bn(enc), key);
	  } else {
	    msg = crt(enc, key);
	  }
	  var zBuffer = new Buffer(k - msg.length);
	  zBuffer.fill(0);
	  msg = Buffer.concat([zBuffer, msg], k);
	  if (padding === 4) {
	    return oaep(key, msg);
	  } else if (padding === 1) {
	    return pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    return msg;
	  } else {
	    throw new Error('unknown padding');
	  }
	};

	function oaep(key, msg){
	  var n = key.modulus;
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (msg[0] !== 0) {
	    throw new Error('decryption error');
	  }
	  var maskedSeed = msg.slice(1, hLen + 1);
	  var maskedDb =  msg.slice(hLen + 1);
	  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
	  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
	  if (compare(iHash, db.slice(0, hLen))) {
	    throw new Error('decryption error');
	  }
	  var i = hLen;
	  while (db[i] === 0) {
	    i++;
	  }
	  if (db[i++] !== 1) {
	    throw new Error('decryption error');
	  }
	  return db.slice(i);
	}

	function pkcs1(key, msg, reverse){
	  var p1 = msg.slice(0, 2);
	  var i = 2;
	  var status = 0;
	  while (msg[i++] !== 0) {
	    if (i >= msg.length) {
	      status++;
	      break;
	    }
	  }
	  var ps = msg.slice(2, i - 1);
	  var p2 = msg.slice(i - 1, i);

	  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
	    status++;
	  }
	  if (ps.length < 8) {
	    status++;
	  }
	  if (status) {
	    throw new Error('decryption error');
	  }
	  return  msg.slice(i);
	}
	function compare(a, b){
	  a = new Buffer(a);
	  b = new Buffer(b);
	  var dif = 0;
	  var len = a.length;
	  if (a.length !== b.length) {
	    dif++;
	    len = Math.min(a.length, b.length);
	  }
	  var i = -1;
	  while (++i < len) {
	    dif += (a[i] ^ b[i]);
	  }
	  return dif;
	}

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var parseKeys = __webpack_require__(94);
	var randomBytes = __webpack_require__(52);
	var createHash = __webpack_require__(32);
	var mgf = __webpack_require__(96);
	var xor = __webpack_require__(98);
	var bn = __webpack_require__(5);
	var withPublic = __webpack_require__(97);
	var crt = __webpack_require__(80);

	var constants = {
	  RSA_PKCS1_OAEP_PADDING: 4,
	  RSA_PKCS1_PADDIN: 1,
	  RSA_NO_PADDING: 3
	};

	module.exports = function publicEncrypt(public_key, msg, reverse) {
	  var padding;
	  if (public_key.padding) {
	    padding = public_key.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  var key = parseKeys(public_key);
	  var paddedMsg;
	  if (padding === 4) {
	    paddedMsg = oaep(key, msg);
	  } else if (padding === 1) {
	    paddedMsg = pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    paddedMsg = new bn(msg);
	    if (paddedMsg.cmp(key.modulus) >= 0) {
	      throw new Error('data too long for modulus');
	    }
	  } else {
	    throw new Error('unknown padding');
	  }
	  if (reverse) {
	    return crt(paddedMsg, key);
	  } else {
	    return withPublic(paddedMsg, key);
	  }
	};

	function oaep(key, msg){
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash('sha1').update(new Buffer('')).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (mLen > k - hLen2 - 2) {
	    throw new Error('message too long');
	  }
	  var ps = new Buffer(k - mLen - hLen2 - 2);
	  ps.fill(0);
	  var dblen = k - hLen - 1;
	  var seed = randomBytes(hLen);
	  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
	  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
	  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
	}
	function pkcs1(key, msg, reverse){
	  var mLen = msg.length;
	  var k = key.modulus.byteLength();
	  if (mLen > k - 11) {
	    throw new Error('message too long');
	  }
	  var ps;
	  if (reverse) {
	    ps = new Buffer(k - mLen - 3);
	    ps.fill(0xff);
	  } else {
	    ps = nonZero(k - mLen - 3);
	  }
	  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
	}
	function nonZero(len, crypto) {
	  var out = new Buffer(len);
	  var i = 0;
	  var cache = randomBytes(len*2);
	  var cur = 0;
	  var num;
	  while (i < len) {
	    if (cur === cache.length) {
	      cache = randomBytes(len*2);
	      cur = 0;
	    }
	    num = cache[cur++];
	    if (num) {
	      out[i++] = num;
	    }
	  }
	  return out;
	}

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var sources  = __webpack_require__(345)
	var sinks    = __webpack_require__(339)
	var throughs = __webpack_require__(351)

	exports = module.exports = __webpack_require__(335)

	for(var k in sources)
	  exports[k] = sources[k]

	for(var k in throughs)
	  exports[k] = throughs[k]

	for(var k in sinks)
	  exports[k] = sinks[k]



/***/ },
/* 335 */
/***/ function(module, exports) {

	"use strict";
	'use strict'

	module.exports = function pull (a) {
	  var length = arguments.length
	  if (typeof a === 'function' && a.length === 1) {
	    var args = new Array(length)
	    for(var i = 0; i < length; i++)
	      args[i] = arguments[i]
	    return function (read) {
	      if (args == null) {
	        throw new TypeError("partial sink should only be called once!")
	      }

	      // Grab the reference after the check, because it's always an array now
	      // (engines like that kind of consistency).
	      var ref = args
	      args = null

	      // Prioritize common case of small number of pulls.
	      switch (length) {
	      case 1: return pull(read, ref[0])
	      case 2: return pull(read, ref[0], ref[1])
	      case 3: return pull(read, ref[0], ref[1], ref[2])
	      case 4: return pull(read, ref[0], ref[1], ref[2], ref[3])
	      default:
	        ref.unshift(read)
	        return pull.apply(null, ref)
	      }
	    }
	  }

	  var read = a

	  if (read && typeof read.source === 'function') {
	    read = read.source
	  }

	  for (var i = 1; i < length; i++) {
	    var s = arguments[i]
	    if (typeof s === 'function') {
	      read = s(read)
	    } else if (s && typeof s === 'object') {
	      s.sink(read)
	      read = s.source
	    }
	  }

	  return read
	}


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var reduce = __webpack_require__(49)

	module.exports = function collect (cb) {
	  return reduce(function (arr, item) {
	    arr.push(item)
	    return arr
	  }, [], cb)
	}


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var reduce = __webpack_require__(49)

	module.exports = function concat (cb) {
	  return reduce(function (a, b) {
	    return a + b
	  }, '', cb)
	}


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	function id (e) { return e }
	var prop = __webpack_require__(26)
	var drain = __webpack_require__(25)

	module.exports = function find (test, cb) {
	  var ended = false
	  if(!cb)
	    cb = test, test = id
	  else
	    test = prop(test) || id

	  return drain(function (data) {
	    if(test(data)) {
	      ended = true
	      cb(null, data)
	    return false
	    }
	  }, function (err) {
	    if(ended) return //already called back
	    cb(err === true ? null : err, null)
	  })
	}






/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	module.exports = {
	  drain: __webpack_require__(25),
	  onEnd: __webpack_require__(341),
	  log: __webpack_require__(340),
	  find: __webpack_require__(338),
	  reduce: __webpack_require__(49),
	  collect: __webpack_require__(336),
	  concat: __webpack_require__(337)
	}



/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var drain = __webpack_require__(25)

	module.exports = function log (done) {
	  return drain(function (data) {
	    console.log(data)
	  }, done)
	}


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var drain = __webpack_require__(25)

	module.exports = function onEnd (done) {
	  return drain(null, done)
	}


/***/ },
/* 342 */
/***/ function(module, exports) {

	"use strict";
	'use strict'

	module.exports = function count (max) {
	  var i = 0; max = max || Infinity
	  return function (end, cb) {
	    if(end) return cb && cb(end)
	    if(i > max)
	      return cb(true)
	    cb(null, i++)
	  }
	}




/***/ },
/* 343 */
/***/ function(module, exports) {

	"use strict";
	'use strict'
	//a stream that ends immediately.
	module.exports = function empty () {
	  return function (abort, cb) {
	    cb(true)
	  }
	}


/***/ },
/* 344 */
/***/ function(module, exports) {

	"use strict";
	'use strict'
	//a stream that errors immediately.
	module.exports = function error (err) {
	  return function (abort, cb) {
	    cb(err)
	  }
	}



/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'
	module.exports = {
	  keys: __webpack_require__(347),
	  once: __webpack_require__(99),
	  values: __webpack_require__(50),
	  count: __webpack_require__(342),
	  infinite: __webpack_require__(346),
	  empty: __webpack_require__(343),
	  error: __webpack_require__(344)
	}


/***/ },
/* 346 */
/***/ function(module, exports) {

	"use strict";
	'use strict'
	module.exports = function infinite (generate) {
	  generate = generate || Math.random
	  return function (end, cb) {
	    if(end) return cb && cb(end)
	    return cb(null, generate())
	  }
	}




/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'
	var values = __webpack_require__(50)
	module.exports = function (object) {
	  return values(Object.keys(object))
	}




/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	function id (e) { return e }
	var prop = __webpack_require__(26)

	module.exports = function asyncMap (map) {
	  if(!map) return id
	  map = prop(map)
	  var busy = false, abortCb, aborted
	  return function (read) {
	    return function next (abort, cb) {
	      if(aborted) return cb(aborted)
	      if(abort) {
	        aborted = abort
	        if(!busy) read(abort, cb)
	        else read(abort, function () {
	          //if we are still busy, wait for the mapper to complete.
	          if(busy) abortCb = cb
	          else cb(abort)
	        })
	      }
	      else
	        read(null, function (end, data) {
	          if(end) cb(end)
	          else if(aborted) cb(aborted)
	          else {
	            busy = true
	            map(data, function (err, data) {
	              busy = false
	              if(aborted) {
	                cb(aborted)
	                abortCb(aborted)
	              }
	              else if(err) next (err, cb)
	              else cb(null, data)
	            })
	          }
	        })
	    }
	  }
	}




/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var tester = __webpack_require__(102)
	var filter = __webpack_require__(51)

	module.exports = function filterNot (test) {
	  test = tester(test)
	  return filter(function (data) { return !test(data) })
	}


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var values = __webpack_require__(50)
	var once = __webpack_require__(99)

	//convert a stream of arrays or streams into just a stream.
	module.exports = function flatten () {
	  return function (read) {
	    var _read
	    return function (abort, cb) {
	      if (abort) { //abort the current stream, and then stream of streams.
	        _read ? _read(abort, function(err) {
	          read(err || abort, cb)
	        }) : read(abort, cb)
	      }
	      else if(_read) nextChunk()
	      else nextStream()

	      function nextChunk () {
	        _read(null, function (err, data) {
	          if (err === true) nextStream()
	          else if (err) {
	            read(true, function(abortErr) {
	              // TODO: what do we do with the abortErr?
	              cb(err)
	            })
	          }
	          else cb(null, data)
	        })
	      }
	      function nextStream () {
	        _read = null
	        read(null, function (end, stream) {
	          if(end)
	            return cb(end)
	          if(Array.isArray(stream) || stream && 'object' === typeof stream)
	            stream = values(stream)
	          else if('function' != typeof stream)
	            stream = once(stream)
	          _read = stream
	          nextChunk()
	        })
	      }
	    }
	  }
	}



/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	module.exports = {
	  map: __webpack_require__(352),
	  asyncMap: __webpack_require__(348),
	  filter: __webpack_require__(51),
	  filterNot: __webpack_require__(349),
	  through: __webpack_require__(355),
	  take: __webpack_require__(354),
	  unique: __webpack_require__(100),
	  nonUnique: __webpack_require__(353),
	  flatten: __webpack_require__(350)
	}





/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	function id (e) { return e }
	var prop = __webpack_require__(26)

	module.exports = function map (mapper) {
	  if(!mapper) return id
	  mapper = prop(mapper)
	  return function (read) {
	    return function (abort, cb) {
	      read(abort, function (end, data) {
	        try {
	        data = !end ? mapper(data) : null
	        } catch (err) {
	          return read(err, function () {
	            return cb(err)
	          })
	        }
	        cb(end, data)
	      })
	    }
	  }
	}


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict'

	var unique = __webpack_require__(100)

	//passes an item through when you see it for the second time.
	module.exports = function nonUnique (field) {
	  return unique(field, true)
	}


/***/ },
/* 354 */
/***/ function(module, exports) {

	"use strict";
	'use strict'

	//read a number of items and then stop.
	module.exports = function take (test, opts) {
	  opts = opts || {}
	  var last = opts.last || false // whether the first item for which !test(item) should still pass
	  var ended = false
	  if('number' === typeof test) {
	    last = true
	    var n = test; test = function () {
	      return --n
	    }
	  }

	  return function (read) {

	    function terminate (cb) {
	      read(true, function (err) {
	        last = false; cb(err || true)
	      })
	    }

	    return function (end, cb) {
	      if(ended)            last ? terminate(cb) : cb(ended)
	      else if(ended = end) read(ended, cb)
	      else
	        read(null, function (end, data) {
	          if(ended = ended || end) {
	            //last ? terminate(cb) :
	            cb(ended)
	          }
	          else if(!test(data)) {
	            ended = true
	            last ? cb(null, data) : terminate(cb)
	          }
	          else
	            cb(null, data)
	        })
	    }
	  }
	}


/***/ },
/* 355 */
/***/ function(module, exports) {

	"use strict";
	'use strict'

	//a pass through stream that doesn't change the value.
	module.exports = function through (op, onEnd) {
	  var a = false

	  function once (abort) {
	    if(a || !onEnd) return
	    a = true
	    onEnd(abort === true ? null : abort)
	  }

	  return function (read) {
	    return function (end, cb) {
	      if(end) once(end)
	      return read(end, function (end, data) {
	        if(!end) op && op(data)
	        else once(end)
	        cb(end, data)
	      })
	    }
	  }
	}


/***/ },
/* 356 */
/***/ function(module, exports) {

	
	var once = exports.once =
	function (value) {
	  return function (abort, cb) {
	    if(abort) return cb(abort)
	    if(value != null) {
	      var _value = value; value = null
	      cb(null, _value)
	    } else
	      cb(true)
	  }
	}

	var depthFirst = exports.depthFirst =
	function (start, createStream) {
	  var reads = [], ended

	  reads.unshift(once(start))

	  return function next (end, cb) {
	    if(!reads.length)
	      return cb(true)
	    if(ended)
	      return cb(ended)

	    reads[0](end, function (end, data) {
	      if(end) {
	        if(end !== true) {
	          ended = end
	          reads.shift()

	          while(reads.length)
	            reads.shift()(end, function () {})
	          
	          return cb(end)
	        }
	        //if this stream has ended, go to the next queue
	        reads.shift()
	        return next(null, cb)
	      }
	      reads.unshift(createStream(data))
	      cb(end, data)
	    })
	  }
	}
	//width first is just like depth first,
	//but push each new stream onto the end of the queue
	var widthFirst = exports.widthFirst = 
	function (start, createStream) {
	  var reads = []

	  reads.push(once(start))

	  return function next (end, cb) {
	    if(!reads.length)
	      return cb(true)
	    reads[0](end, function (end, data) {
	      if(end) {
	        reads.shift()
	        return next(null, cb)
	      }
	      reads.push(createStream(data))
	      cb(end, data)
	    })
	  }
	}

	//this came out different to the first (strm)
	//attempt at leafFirst, but it's still a valid
	//topological sort.
	var leafFirst = exports.leafFirst = 
	function (start, createStream) {
	  var reads = []
	  var output = []
	  reads.push(once(start))
	  
	  return function next (end, cb) {
	    reads[0](end, function (end, data) {
	      if(end) {
	        reads.shift()
	        if(!output.length)
	          return cb(true)
	        return cb(null, output.shift())
	      }
	      reads.unshift(createStream(data))
	      output.unshift(data)
	      next(null, cb)
	    })
	  }
	}



/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(15)


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(104);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var Readable = __webpack_require__(3).Readable;
	var PassThrough = __webpack_require__(3).PassThrough;

	function SandwichStream(options) {
	  Readable.call(this, options);
	  options = options || {};
	  this._streamsActive = false;
	  this._streamsAdded = false;
	  this._streams = [];
	  this._currentStream = undefined;
	  this._errorsEmitted = false;

	  if (options.head) {
	    this._head = options.head;
	  }
	  if (options.tail) {
	    this._tail = options.tail;
	  }
	  if (options.separator) {
	    this._separator = options.separator;
	  }
	}

	SandwichStream.prototype = Object.create(Readable.prototype, {
	  constructor: SandwichStream
	});

	SandwichStream.prototype._read = function () {
	  if (!this._streamsActive) {
	    this._streamsActive = true;
	    this._pushHead();
	    this._streamNextStream();
	  }
	};

	SandwichStream.prototype.add = function (newStream) {
	  if (!this._streamsActive) {
	    this._streamsAdded = true;
	    this._streams.push(newStream);
	    newStream.on('error', this._substreamOnError.bind(this));
	  }
	  else {
	    throw new Error('SandwichStream error adding new stream while streaming');
	  }
	};

	SandwichStream.prototype._substreamOnError = function (error) {
	  this._errorsEmitted = true;
	  this.emit('error', error);
	};

	SandwichStream.prototype._pushHead = function () {
	  if (this._head) {
	    this.push(this._head);
	  }
	};

	SandwichStream.prototype._streamNextStream = function () {
	  if (this._nextStream()) {
	    this._bindCurrentStreamEvents();
	  }
	  else {
	    this._pushTail();
	    this.push(null);
	  }
	};

	SandwichStream.prototype._nextStream = function () {
	  this._currentStream = this._streams.shift();
	  return this._currentStream !== undefined;
	};

	SandwichStream.prototype._bindCurrentStreamEvents = function () {
	  this._currentStream.on('readable', this._currentStreamOnReadable.bind(this));
	  this._currentStream.on('end', this._currentStreamOnEnd.bind(this));
	};

	SandwichStream.prototype._currentStreamOnReadable = function () {
	  this.push(this._currentStream.read() || '');
	};

	SandwichStream.prototype._currentStreamOnEnd = function () {
	  this._pushSeparator();
	  this._streamNextStream();
	};

	SandwichStream.prototype._pushSeparator = function () {
	  if (this._streams.length > 0 && this._separator) {
	    this.push(this._separator);
	  }
	};

	SandwichStream.prototype._pushTail = function () {
	  if (this._tail) {
	    this.push(this._tail);
	  }
	};

	function sandwichStream(options) {
	  var stream = new SandwichStream(options);
	  return stream;
	}

	sandwichStream.SandwichStream = SandwichStream;

	module.exports = sandwichStream;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var varint = __webpack_require__(363)
	exports.encode = function encode (v, b, o) {
	  v = v >= 0 ? v*2 : v*-2 - 1
	  var r = varint.encode(v, b, o)
	  encode.bytes = varint.encode.bytes
	  return r
	}
	exports.decode = function decode (b, o) {
	  var v = varint.decode(b, o)
	  decode.bytes = varint.decode.bytes
	  return v & 1 ? (v+1) / -2 : v / 2
	}

	exports.encodingLength = function (v) {
	  return varint.encodingLength(v >= 0 ? v*2 : v*-2 - 1)
	}


/***/ },
/* 361 */
/***/ function(module, exports) {

	module.exports = read

	var MSB = 0x80
	  , REST = 0x7F

	function read(buf, offset) {
	  var res    = 0
	    , offset = offset || 0
	    , shift  = 0
	    , counter = offset
	    , b
	    , l = buf.length
	  
	  do {
	    if(counter >= l) {
	      read.bytesRead = 0
	      return undefined
	    }
	    b = buf[counter++]
	    res += shift < 28
	      ? (b & REST) << shift
	      : (b & REST) * Math.pow(2, shift)
	    shift += 7
	  } while (b >= MSB)
	  
	  read.bytes = counter - offset
	  
	  return res
	}


/***/ },
/* 362 */
/***/ function(module, exports) {

	module.exports = encode

	var MSB = 0x80
	  , REST = 0x7F
	  , MSBALL = ~REST
	  , INT = Math.pow(2, 31)

	function encode(num, out, offset) {
	  out = out || []
	  offset = offset || 0
	  var oldOffset = offset

	  while(num >= INT) {
	    out[offset++] = (num & 0xFF) | MSB
	    num /= 128
	  }
	  while(num & MSBALL) {
	    out[offset++] = (num & 0xFF) | MSB
	    num >>>= 7
	  }
	  out[offset] = num | 0
	  
	  encode.bytes = offset - oldOffset + 1
	  
	  return out
	}


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    encode: __webpack_require__(362)
	  , decode: __webpack_require__(361)
	  , encodingLength: __webpack_require__(364)
	}


/***/ },
/* 364 */
/***/ function(module, exports) {

	
	var N1 = Math.pow(2,  7)
	var N2 = Math.pow(2, 14)
	var N3 = Math.pow(2, 21)
	var N4 = Math.pow(2, 28)
	var N5 = Math.pow(2, 35)
	var N6 = Math.pow(2, 42)
	var N7 = Math.pow(2, 49)

	module.exports = function (value) {
	  return (
	    value < N1 ? 1
	  : value < N2 ? 2
	  : value < N3 ? 3
	  : value < N4 ? 4
	  : value < N5 ? 5
	  : value < N6 ? 6
	  : value < N7 ? 7
	  :              8
	  )
	}


/***/ },
/* 365 */
/***/ function(module, exports) {

	
	/*
	usage:

	// do something to a list of things
	asyncMap(myListOfStuff, function (thing, cb) { doSomething(thing.foo, cb) }, cb)
	// do more than one thing to each item
	asyncMap(list, fooFn, barFn, cb)

	*/

	module.exports = asyncMap

	function asyncMap () {
	  var steps = Array.prototype.slice.call(arguments)
	    , list = steps.shift() || []
	    , cb_ = steps.pop()
	  if (typeof cb_ !== "function") throw new Error(
	    "No callback provided to asyncMap")
	  if (!list) return cb_(null, [])
	  if (!Array.isArray(list)) list = [list]
	  var n = steps.length
	    , data = [] // 2d array
	    , errState = null
	    , l = list.length
	    , a = l * n
	  if (!a) return cb_(null, [])
	  function cb (er) {
	    if (er && !errState) errState = er

	    var argLen = arguments.length
	    for (var i = 1; i < argLen; i ++) if (arguments[i] !== undefined) {
	      data[i - 1] = (data[i - 1] || []).concat(arguments[i])
	    }
	    // see if any new things have been added.
	    if (list.length > l) {
	      var newList = list.slice(l)
	      a += (list.length - l) * n
	      l = list.length
	      process.nextTick(function () {
	        newList.forEach(function (ar) {
	          steps.forEach(function (fn) { fn(ar, cb) })
	        })
	      })
	    }

	    if (--a === 0) cb_.apply(null, [errState].concat(data))
	  }
	  // expect the supplied cb function to be called
	  // "n" times for each thing in the array.
	  list.forEach(function (ar) {
	    steps.forEach(function (fn) { fn(ar, cb) })
	  })
	}


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = chain
	var bindActor = __webpack_require__(106)
	chain.first = {} ; chain.last = {}
	function chain (things, cb) {
	  var res = []
	  ;(function LOOP (i, len) {
	    if (i >= len) return cb(null,res)
	    if (Array.isArray(things[i]))
	      things[i] = bindActor.apply(null,
	        things[i].map(function(i){
	          return (i===chain.first) ? res[0]
	           : (i===chain.last)
	             ? res[res.length - 1] : i }))
	    if (!things[i]) return LOOP(i + 1, len)
	    things[i](function (er, data) {
	      if (er) return cb(er, res)
	      if (data !== undefined) res = res.concat(data)
	      LOOP(i + 1, len)
	    })
	  })(0, things.length) }


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	exports.asyncMap = __webpack_require__(365)
	exports.bindActor = __webpack_require__(106)
	exports.chain = __webpack_require__(366)


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	Copyright (c) 2014, Matteo Collina <hello@matteocollina.com>

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
	IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	*/

	'use strict';

	var through = __webpack_require__(374)

	function transform(chunk, enc, cb) {
	  var list = chunk.toString('utf8').split(this.matcher)
	    , remaining = list.pop()
	    , i

	  if (list.length >= 1) {
	    push(this, this.mapper((this._last + list.shift())))
	  } else {
	    remaining = this._last + remaining
	  }

	  for (i = 0; i < list.length; i++) {
	    push(this, this.mapper(list[i]))
	  }

	  this._last = remaining

	  cb()
	}

	function flush(cb) {
	  if (this._last)
	    push(this, this.mapper(this._last))

	  cb()
	}

	function push(self, val) {
	  if (val !== undefined)
	    self.push(val)
	}

	function noop(incoming) {
	  return incoming
	}

	function split(matcher, mapper, options) {

	  if (typeof matcher === 'object' && !(matcher instanceof RegExp)) {
	    options = matcher
	    matcher = null
	  }

	  if (typeof matcher === 'function') {
	    mapper = matcher
	    matcher = null
	  }

	  options = options || {}

	  var stream = through(options, transform, flush)

	  // this stream is in objectMode only in the readable part
	  stream._readableState.objectMode = true;

	  stream._last = ''
	  stream.matcher = matcher || /\r?\n/
	  stream.mapper = mapper || noop

	  return stream
	}

	module.exports = split


/***/ },
/* 369 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(369);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(10).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(19).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }

	      if (state.needReadable)
	        emitReadable(stream);

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(19).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;

	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }

	    if (state.length === 0)
	      endReadable(this);

	    return ret;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;

	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;

	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}

	function emitReadable_(stream) {
	  stream.emit('readable');
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }

	  function onend() {
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);

	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}

	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;

	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }

	  while (state.pipesCount && null !== (chunk = src.read())) {

	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);

	    src.emit('data', chunk);

	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }

	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;

	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }

	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}

	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};

	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};

	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;

	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }

	  var paused = startPaused || false;
	  var readable = false;

	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;

	  stream.on('readable', function() {
	    readable = true;

	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);

	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });

	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };

	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };

	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(107);

	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  var ts = this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(7);
	util.inherits = __webpack_require__(1);
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(107);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);

	  return ret;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;

	    doWrite(stream, state, len, chunk, encoding, cb);

	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }

	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(371)


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var Transform = __webpack_require__(373)
	  , inherits  = __webpack_require__(4).inherits
	  , xtend     = __webpack_require__(35)

	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}

	inherits(DestroyableTransform, Transform)

	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}

	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}


	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }

	    if (typeof transform != 'function')
	      transform = noop

	    if (typeof flush != 'function')
	      flush = null

	    return construct(options, transform, flush)
	  }
	}


	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)

	    this.options = xtend(options, override)

	    DestroyableTransform.call(this, this.options)
	  }

	  inherits(Through2, DestroyableTransform)

	  Through2.prototype._transform = transform

	  if (flush)
	    Through2.prototype._flush = flush

	  return Through2
	})


	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	//! stable.js 0.1.5, https://github.com/Two-Screen/stable
	//!  2014 Angry Bytes and contributors. MIT licensed.

	(function() {

	// A stable array sort, because `Array#sort()` is not guaranteed stable.
	// This is an implementation of merge sort, without recursion.

	var stable = function(arr, comp) {
	    return exec(arr.slice(), comp);
	};

	stable.inplace = function(arr, comp) {
	    var result = exec(arr, comp);

	    // This simply copies back if the result isn't in the original array,
	    // which happens on an odd number of passes.
	    if (result !== arr) {
	        pass(result, null, arr.length, arr);
	    }

	    return arr;
	};

	// Execute the sort using the input array and a second buffer as work space.
	// Returns one of those two, containing the final result.
	function exec(arr, comp) {
	    if (typeof(comp) !== 'function') {
	        comp = function(a, b) {
	            return String(a).localeCompare(b);
	        };
	    }

	    // Short-circuit when there's nothing to sort.
	    var len = arr.length;
	    if (len <= 1) {
	        return arr;
	    }

	    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
	    // Chunks are the size of the left or right hand in merge sort.
	    // Stop when the left-hand covers all of the array.
	    var buffer = new Array(len);
	    for (var chk = 1; chk < len; chk *= 2) {
	        pass(arr, comp, chk, buffer);

	        var tmp = arr;
	        arr = buffer;
	        buffer = tmp;
	    }

	    return arr;
	}

	// Run a single pass with the given chunk size.
	var pass = function(arr, comp, chk, result) {
	    var len = arr.length;
	    var i = 0;
	    // Step size / double chunk size.
	    var dbl = chk * 2;
	    // Bounds of the left and right chunks.
	    var l, r, e;
	    // Iterators over the left and right chunk.
	    var li, ri;

	    // Iterate over pairs of chunks.
	    for (l = 0; l < len; l += dbl) {
	        r = l + chk;
	        e = r + chk;
	        if (r > len) r = len;
	        if (e > len) e = len;

	        // Iterate both chunks in parallel.
	        li = l;
	        ri = r;
	        while (true) {
	            // Compare the chunks.
	            if (li < r && ri < e) {
	                // This works for a regular `sort()` compatible comparator,
	                // but also for a simple comparator like: `a > b`
	                if (comp(arr[li], arr[ri]) <= 0) {
	                    result[i++] = arr[li++];
	                }
	                else {
	                    result[i++] = arr[ri++];
	                }
	            }
	            // Nothing to compare, just flush what's left.
	            else if (li < r) {
	                result[i++] = arr[li++];
	            }
	            else if (ri < e) {
	                result[i++] = arr[ri++];
	            }
	            // Both iterators are at the chunk ends.
	            else {
	                break;
	            }
	        }
	    }
	};

	// Export using CommonJS or to the window.
	if (true) {
	    module.exports = stable;
	}
	else {
	    window.stable = stable;
	}

	})();


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var util = __webpack_require__(4);
	var stream = __webpack_require__(3);

	module.exports.createReadStream = function (object, options) {
	  return new MultiStream (object, options);
	};

	var MultiStream = function (object, options) {
	  if (object instanceof Buffer || typeof object === 'string') {
	    options = options || {};
	    stream.Readable.call(this, {
	      highWaterMark: options.highWaterMark,
	      encoding: options.encoding
	    });
	  } else {
	    stream.Readable.call(this, { objectMode: true });
	  }
	  this._object = object;
	};

	util.inherits(MultiStream, stream.Readable);

	MultiStream.prototype._read = function () {
	  this.push(this._object);
	  this._object = null;
	};

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4)
	var bl = __webpack_require__(31)
	var xtend = __webpack_require__(35)
	var headers = __webpack_require__(108)

	var Writable = __webpack_require__(27).Writable
	var PassThrough = __webpack_require__(27).PassThrough

	var noop = function () {}

	var overflow = function (size) {
	  size &= 511
	  return size && 512 - size
	}

	var emptyStream = function (self, offset) {
	  var s = new Source(self, offset)
	  s.end()
	  return s
	}

	var mixinPax = function (header, pax) {
	  if (pax.path) header.name = pax.path
	  if (pax.linkpath) header.linkname = pax.linkpath
	  header.pax = pax
	  return header
	}

	var Source = function (self, offset) {
	  this._parent = self
	  this.offset = offset
	  PassThrough.call(this)
	}

	util.inherits(Source, PassThrough)

	Source.prototype.destroy = function (err) {
	  this._parent.destroy(err)
	}

	var Extract = function (opts) {
	  if (!(this instanceof Extract)) return new Extract(opts)
	  Writable.call(this, opts)

	  this._offset = 0
	  this._buffer = bl()
	  this._missing = 0
	  this._onparse = noop
	  this._header = null
	  this._stream = null
	  this._overflow = null
	  this._cb = null
	  this._locked = false
	  this._destroyed = false
	  this._pax = null
	  this._paxGlobal = null
	  this._gnuLongPath = null
	  this._gnuLongLinkPath = null

	  var self = this
	  var b = self._buffer

	  var oncontinue = function () {
	    self._continue()
	  }

	  var onunlock = function (err) {
	    self._locked = false
	    if (err) return self.destroy(err)
	    if (!self._stream) oncontinue()
	  }

	  var onstreamend = function () {
	    self._stream = null
	    var drain = overflow(self._header.size)
	    if (drain) self._parse(drain, ondrain)
	    else self._parse(512, onheader)
	    if (!self._locked) oncontinue()
	  }

	  var ondrain = function () {
	    self._buffer.consume(overflow(self._header.size))
	    self._parse(512, onheader)
	    oncontinue()
	  }

	  var onpaxglobalheader = function () {
	    var size = self._header.size
	    self._paxGlobal = headers.decodePax(b.slice(0, size))
	    b.consume(size)
	    onstreamend()
	  }

	  var onpaxheader = function () {
	    var size = self._header.size
	    self._pax = headers.decodePax(b.slice(0, size))
	    if (self._paxGlobal) self._pax = xtend(self._paxGlobal, self._pax)
	    b.consume(size)
	    onstreamend()
	  }

	  var ongnulongpath = function () {
	    var size = self._header.size
	    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size))
	    b.consume(size)
	    onstreamend()
	  }

	  var ongnulonglinkpath = function () {
	    var size = self._header.size
	    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size))
	    b.consume(size)
	    onstreamend()
	  }

	  var onheader = function () {
	    var offset = self._offset
	    var header
	    try {
	      header = self._header = headers.decode(b.slice(0, 512))
	    } catch (err) {
	      self.emit('error', err)
	    }
	    b.consume(512)

	    if (!header) {
	      self._parse(512, onheader)
	      oncontinue()
	      return
	    }
	    if (header.type === 'gnu-long-path') {
	      self._parse(header.size, ongnulongpath)
	      oncontinue()
	      return
	    }
	    if (header.type === 'gnu-long-link-path') {
	      self._parse(header.size, ongnulonglinkpath)
	      oncontinue()
	      return
	    }
	    if (header.type === 'pax-global-header') {
	      self._parse(header.size, onpaxglobalheader)
	      oncontinue()
	      return
	    }
	    if (header.type === 'pax-header') {
	      self._parse(header.size, onpaxheader)
	      oncontinue()
	      return
	    }

	    if (self._gnuLongPath) {
	      header.name = self._gnuLongPath
	      self._gnuLongPath = null
	    }

	    if (self._gnuLongLinkPath) {
	      header.linkname = self._gnuLongLinkPath
	      self._gnuLongLinkPath = null
	    }

	    if (self._pax) {
	      self._header = header = mixinPax(header, self._pax)
	      self._pax = null
	    }

	    self._locked = true

	    if (!header.size) {
	      self._parse(512, onheader)
	      self.emit('entry', header, emptyStream(self, offset), onunlock)
	      return
	    }

	    self._stream = new Source(self, offset)

	    self.emit('entry', header, self._stream, onunlock)
	    self._parse(header.size, onstreamend)
	    oncontinue()
	  }

	  this._parse(512, onheader)
	}

	util.inherits(Extract, Writable)

	Extract.prototype.destroy = function (err) {
	  if (this._destroyed) return
	  this._destroyed = true

	  if (err) this.emit('error', err)
	  this.emit('close')
	  if (this._stream) this._stream.emit('close')
	}

	Extract.prototype._parse = function (size, onparse) {
	  if (this._destroyed) return
	  this._offset += size
	  this._missing = size
	  this._onparse = onparse
	}

	Extract.prototype._continue = function () {
	  if (this._destroyed) return
	  var cb = this._cb
	  this._cb = noop
	  if (this._overflow) this._write(this._overflow, undefined, cb)
	  else cb()
	}

	Extract.prototype._write = function (data, enc, cb) {
	  if (this._destroyed) return

	  var s = this._stream
	  var b = this._buffer
	  var missing = this._missing

	  // we do not reach end-of-chunk now. just forward it

	  if (data.length < missing) {
	    this._missing -= data.length
	    this._overflow = null
	    if (s) return s.write(data, cb)
	    b.append(data)
	    return cb()
	  }

	  // end-of-chunk. the parser should call cb.

	  this._cb = cb
	  this._missing = 0

	  var overflow = null
	  if (data.length > missing) {
	    overflow = data.slice(missing)
	    data = data.slice(0, missing)
	  }

	  if (s) s.end(data)
	  else b.append(data)

	  this._overflow = overflow
	  this._onparse()
	}

	module.exports = Extract


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	exports.extract = __webpack_require__(377)
	exports.pack = __webpack_require__(379)


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(109)
	var eos = __webpack_require__(256)
	var util = __webpack_require__(4)

	var Readable = __webpack_require__(27).Readable
	var Writable = __webpack_require__(27).Writable
	var StringDecoder = __webpack_require__(387).StringDecoder

	var headers = __webpack_require__(108)

	var DMODE = parseInt('755', 8)
	var FMODE = parseInt('644', 8)

	var END_OF_TAR = new Buffer(1024)
	END_OF_TAR.fill(0)

	var noop = function () {}

	var overflow = function (self, size) {
	  size &= 511
	  if (size) self.push(END_OF_TAR.slice(0, 512 - size))
	}

	function modeToType (mode) {
	  switch (mode & constants.S_IFMT) {
	    case constants.S_IFBLK: return 'block-device'
	    case constants.S_IFCHR: return 'character-device'
	    case constants.S_IFDIR: return 'directory'
	    case constants.S_IFIFO: return 'fifo'
	    case constants.S_IFLNK: return 'symlink'
	  }

	  return 'file'
	}

	var Sink = function (to) {
	  Writable.call(this)
	  this.written = 0
	  this._to = to
	  this._destroyed = false
	}

	util.inherits(Sink, Writable)

	Sink.prototype._write = function (data, enc, cb) {
	  this.written += data.length
	  if (this._to.push(data)) return cb()
	  this._to._drain = cb
	}

	Sink.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true
	  this.emit('close')
	}

	var LinkSink = function () {
	  Writable.call(this)
	  this.linkname = ''
	  this._decoder = new StringDecoder('utf-8')
	  this._destroyed = false
	}

	util.inherits(LinkSink, Writable)

	LinkSink.prototype._write = function (data, enc, cb) {
	  this.linkname += this._decoder.write(data)
	  cb()
	}

	LinkSink.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true
	  this.emit('close')
	}

	var Void = function () {
	  Writable.call(this)
	  this._destroyed = false
	}

	util.inherits(Void, Writable)

	Void.prototype._write = function (data, enc, cb) {
	  cb(new Error('No body allowed for this entry'))
	}

	Void.prototype.destroy = function () {
	  if (this._destroyed) return
	  this._destroyed = true
	  this.emit('close')
	}

	var Pack = function (opts) {
	  if (!(this instanceof Pack)) return new Pack(opts)
	  Readable.call(this, opts)

	  this._drain = noop
	  this._finalized = false
	  this._finalizing = false
	  this._destroyed = false
	  this._stream = null
	}

	util.inherits(Pack, Readable)

	Pack.prototype.entry = function (header, buffer, callback) {
	  if (this._stream) throw new Error('already piping an entry')
	  if (this._finalized || this._destroyed) return

	  if (typeof buffer === 'function') {
	    callback = buffer
	    buffer = null
	  }

	  if (!callback) callback = noop

	  var self = this

	  if (!header.size || header.type === 'symlink') header.size = 0
	  if (!header.type) header.type = modeToType(header.mode)
	  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
	  if (!header.uid) header.uid = 0
	  if (!header.gid) header.gid = 0
	  if (!header.mtime) header.mtime = new Date()

	  if (typeof buffer === 'string') buffer = new Buffer(buffer)
	  if (Buffer.isBuffer(buffer)) {
	    header.size = buffer.length
	    this._encode(header)
	    this.push(buffer)
	    overflow(self, header.size)
	    process.nextTick(callback)
	    return new Void()
	  }

	  if (header.type === 'symlink' && !header.linkname) {
	    var linkSink = new LinkSink()
	    eos(linkSink, function (err) {
	      if (err) { // stream was closed
	        self.destroy()
	        return callback(err)
	      }

	      header.linkname = linkSink.linkname
	      self._encode(header)
	      callback()
	    })

	    return linkSink
	  }

	  this._encode(header)

	  if (header.type !== 'file' && header.type !== 'contiguous-file') {
	    process.nextTick(callback)
	    return new Void()
	  }

	  var sink = new Sink(this)

	  this._stream = sink

	  eos(sink, function (err) {
	    self._stream = null

	    if (err) { // stream was closed
	      self.destroy()
	      return callback(err)
	    }

	    if (sink.written !== header.size) { // corrupting tar
	      self.destroy()
	      return callback(new Error('size mismatch'))
	    }

	    overflow(self, header.size)
	    if (self._finalizing) self.finalize()
	    callback()
	  })

	  return sink
	}

	Pack.prototype.finalize = function () {
	  if (this._stream) {
	    this._finalizing = true
	    return
	  }

	  if (this._finalized) return
	  this._finalized = true
	  this.push(END_OF_TAR)
	  this.push(null)
	}

	Pack.prototype.destroy = function (err) {
	  if (this._destroyed) return
	  this._destroyed = true

	  if (err) this.emit('error', err)
	  this.emit('close')
	  if (this._stream && this._stream.destroy) this._stream.destroy()
	}

	Pack.prototype._encode = function (header) {
	  if (!header.pax) {
	    var buf = headers.encode(header)
	    if (buf) {
	      this.push(buf)
	      return
	    }
	  }
	  this._encodePax(header)
	}

	Pack.prototype._encodePax = function (header) {
	  var paxHeader = headers.encodePax({
	    name: header.name,
	    linkname: header.linkname,
	    pax: header.pax
	  })

	  var newHeader = {
	    name: 'PaxHeader',
	    mode: header.mode,
	    uid: header.uid,
	    gid: header.gid,
	    size: paxHeader.length,
	    mtime: header.mtime,
	    type: 'pax-header',
	    linkname: header.linkname && 'PaxHeader',
	    uname: header.uname,
	    gname: header.gname,
	    devmajor: header.devmajor,
	    devminor: header.devminor
	  }

	  this.push(headers.encode(newHeader))
	  this.push(paxHeader)
	  overflow(this, paxHeader.length)

	  newHeader.size = header.size
	  newHeader.type = header.type
	  this.push(headers.encode(newHeader))
	}

	Pack.prototype._read = function (n) {
	  var drain = this._drain
	  this._drain = noop
	  drain()
	}

	module.exports = Pack


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	module.exports = __webpack_require__(4).deprecate;


/***/ },
/* 381 */
/***/ function(module, exports) {

	module.exports = read

	var MSB = 0x80
	  , REST = 0x7F

	function read(buf, offset) {
	  var res    = 0
	    , offset = offset || 0
	    , shift  = 0
	    , counter = offset
	    , b
	    , l = buf.length

	  do {
	    if(counter >= l) {
	      read.bytes = 0
	      read.bytesRead = 0 // DEPRECATED
	      return undefined
	    }
	    b = buf[counter++]
	    res += shift < 28
	      ? (b & REST) << shift
	      : (b & REST) * Math.pow(2, shift)
	    shift += 7
	  } while (b >= MSB)

	  read.bytes = counter - offset

	  return res
	}


/***/ },
/* 382 */
/***/ function(module, exports) {

	module.exports = encode

	var MSB = 0x80
	  , REST = 0x7F
	  , MSBALL = ~REST
	  , INT = Math.pow(2, 31)

	function encode(num, out, offset) {
	  out = out || []
	  offset = offset || 0
	  var oldOffset = offset

	  while(num >= INT) {
	    out[offset++] = (num & 0xFF) | MSB
	    num /= 128
	  }
	  while(num & MSBALL) {
	    out[offset++] = (num & 0xFF) | MSB
	    num >>>= 7
	  }
	  out[offset] = num | 0
	  
	  encode.bytes = offset - oldOffset + 1
	  
	  return out
	}


/***/ },
/* 383 */
/***/ function(module, exports) {

	
	var N1 = Math.pow(2,  7)
	var N2 = Math.pow(2, 14)
	var N3 = Math.pow(2, 21)
	var N4 = Math.pow(2, 28)
	var N5 = Math.pow(2, 35)
	var N6 = Math.pow(2, 42)
	var N7 = Math.pow(2, 49)
	var N8 = Math.pow(2, 56)
	var N9 = Math.pow(2, 63)

	module.exports = function (value) {
	  return (
	    value < N1 ? 1
	  : value < N2 ? 2
	  : value < N3 ? 3
	  : value < N4 ? 4
	  : value < N5 ? 5
	  : value < N6 ? 6
	  : value < N7 ? 7
	  : value < N8 ? 8
	  : value < N9 ? 9
	  :              10
	  )
	}


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	var isNode = !global.window

	if (isNode) {
	  module.exports = __webpack_require__(9)
	} else {
	  module.exports = __webpack_require__(240)
	}


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* WEBPACK VAR INJECTION */(function(__filename) {'use strict'
	var fs = __webpack_require__(264)
	var chain = __webpack_require__(367).chain
	var MurmurHash3 = __webpack_require__(272)
	var extend = Object.assign || __webpack_require__(4)._extend

	function murmurhex () {
	  var hash = new MurmurHash3()
	  for (var ii = 0; ii < arguments.length; ++ii) hash.hash('' + arguments[ii])
	  return hash.result()
	}
	var invocations = 0
	var getTmpname = function (filename) {
	  return filename + '.' + murmurhex(__filename, process.pid, ++invocations)
	}

	module.exports = function writeFile (filename, data, options, callback) {
	  if (options instanceof Function) {
	    callback = options
	    options = null
	  }
	  if (!options) options = {}
	  var tmpfile = getTmpname(filename)

	  if (options.mode && options.chmod) {
	    return thenWriteFile()
	  } else {
	    // Either mode or chown is not explicitly set
	    // Default behavior is to copy it from original file
	    return fs.stat(filename, function (err, stats) {
	      options = extend({}, options)
	      if (!err && stats && !options.mode) {
	        options.mode = stats.mode
	      }
	      if (!err && stats && !options.chown && process.getuid) {
	        options.chown = { uid: stats.uid, gid: stats.gid }
	      }
	      return thenWriteFile()
	    })
	  }

	  function thenWriteFile () {
	    chain([
	      [fs, fs.writeFile, tmpfile, data, options.encoding || 'utf8'],
	      options.mode && [fs, fs.chmod, tmpfile, options.mode],
	      options.chown && [fs, fs.chown, tmpfile, options.chown.uid, options.chown.gid],
	      [fs, fs.rename, tmpfile, filename]
	    ], function (err) {
	      err ? fs.unlink(tmpfile, function () { callback(err) })
	        : callback()
	    })
	  }
	}

	module.exports.sync = function writeFileSync (filename, data, options) {
	  if (!options) options = {}
	  var tmpfile = getTmpname(filename)

	  try {
	    if (!options.mode || !options.chmod) {
	      // Either mode or chown is not explicitly set
	      // Default behavior is to copy it from original file
	      try {
	        var stats = fs.statSync(filename)

	        options = extend({}, options)
	        if (!options.mode) {
	          options.mode = stats.mode
	        }
	        if (!options.chown && process.getuid) {
	          options.chown = { uid: stats.uid, gid: stats.gid }
	        }
	      } catch (ex) {
	        // ignore stat errors
	      }
	    }

	    fs.writeFileSync(tmpfile, data, options.encoding || 'utf8')
	    if (options.chown) fs.chownSync(tmpfile, options.chown.uid, options.chown.gid)
	    if (options.mode) fs.chmodSync(tmpfile, options.mode)
	    fs.renameSync(tmpfile, filename)
	  } catch (err) {
	    try { fs.unlinkSync(tmpfile) } catch (e) {}
	    throw err
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, "/index.js"))

/***/ },
/* 386 */
/***/ function(module, exports) {

	module.exports = require("https");

/***/ },
/* 387 */
/***/ function(module, exports) {

	module.exports = require("string_decoder");

/***/ },
/* 388 */
/***/ function(module, exports) {

	module.exports = require("vm");

/***/ }
/******/ ]);